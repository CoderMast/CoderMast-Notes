# Leetcode 62. 不同路径-动态规划DP秒解不同路径
## 题目描述
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

示例 1：

输入：m = 3, n = 7
输出：28
示例 2：

输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
   示例 3：

输入：m = 7, n = 3
输出：28
示例 4：

输入：m = 3, n = 3
输出：6
 

提示：

1 <= m, n <= 100
题目数据保证答案小于等于 2 * 109

## 题目地址
[Leetcode 62. 不同路径](https://leetcode.cn/problems/unique-paths/solution/dong-tai-gui-hua-dpmiao-jie-bu-tong-lu-j-61ut/)

## 思路解析
1. 首先从题目中可知，机器人仅能向右或者向下移动一个单位，则可以推断到达任何一的网格之中仅有两种方式。
    - 从上边网格向下移动
    - 从左边网格向右移动
2. 对于所有的网格就只有这两种方式到达，但有的网格只有这两种方式的其中一个，故此需要判断边界条件。
    - 当走到第一行时，仅能从左边网格向右移动。
    - 当走到第一列时，仅能从上边网格向下移动。
    - 其他网格，既能从上边网格向下移动，又能从左边网格向右移动。
3. 所有网格我们分成了3个类型，当计算移动到一个网格的路径时需要依赖**到达上边网格的路径数** ，**到达左边网格的路径数**这两个数值。
4. 递推公式为：到达当前网格的路径数 = **到达上边网格的路径数** + **到达左边网格的路径数**
5. 故此我们从 [0][0] 位置开始循环，可以按行S形遍历，也可以按列S型遍历，注意边界控制即可。

## 代码示例
```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] grid = new int[m][n];

        int i = 0;
        int j = 0;
        grid[0][0] = 1;

        while(i < m && j < n){
            int left = 0;
            int up = 0;

            // 此时必然有上和左
            if (i != 0 && j != 0){
                left = grid[i][j - 1];
                up = grid[i - 1][j];
            }
            // 此时仅有上
            if (i != 0 && j == 0){
                up = grid[i - 1][j];
            }

            // 此时仅有左
            if (i == 0 && j != 0){
                left = grid[i][j - 1];
            }

            grid[i][j] = left + up + grid[i][j];

            j++;

            if (j % n == 0){
                j = 0;
                i ++;
            }
        }
        return grid[m -1][n -1];
    }
}
```