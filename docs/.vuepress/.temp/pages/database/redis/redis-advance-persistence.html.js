export const data = JSON.parse("{\"key\":\"v-b6a85f34\",\"path\":\"/database/redis/redis-advance-persistence.html\",\"title\":\"Redis进阶 - Redis持久化\",\"lang\":\"zh-CN\",\"frontmatter\":{\"order\":13,\"description\":\"Redis进阶 - Redis持久化 单点Redis的问题 数据丢失问题：Redis 是内存存储，服务重启可能会丢失数据。通过实现 Redis 数据持久化解决。 并发能力问题：单节点 Redis 并发能力虽然不错，但是也无法满足如 618 这样的高并发场景。搭建主从集群，实现读写分离解决。 故障恢复问题：如果 Redis 宕机，则服务不可用，需要一种自动的故障恢复手段。利用 Redis 哨兵，实现健康检测和自动恢复。 存储能力问题：Redis 基于内存，单点能存储的数据量难以满足海量数据需求。搭建分片集群，利用插槽机制实现动态扩容。\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://www.codermast.com/database/redis/redis-advance-persistence.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"编程桅杆\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"Redis进阶 - Redis持久化\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"Redis进阶 - Redis持久化 单点Redis的问题 数据丢失问题：Redis 是内存存储，服务重启可能会丢失数据。通过实现 Redis 数据持久化解决。 并发能力问题：单节点 Redis 并发能力虽然不错，但是也无法满足如 618 这样的高并发场景。搭建主从集群，实现读写分离解决。 故障恢复问题：如果 Redis 宕机，则服务不可用，需要一种自动的故障恢复手段。利用 Redis 哨兵，实现健康检测和自动恢复。 存储能力问题：Redis 基于内存，单点能存储的数据量难以满足海量数据需求。搭建分片集群，利用插槽机制实现动态扩容。\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"article:author\",\"content\":\"CoderMast\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"Redis进阶 - Redis持久化\\\",\\\"image\\\":[\\\"\\\"],\\\"dateModified\\\":null,\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"CoderMast\\\",\\\"url\\\":\\\"https://www.codermast.com\\\",\\\"email\\\":\\\"codermast@163.com\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"RDB持久化\",\"slug\":\"rdb持久化\",\"link\":\"#rdb持久化\",\"children\":[]},{\"level\":2,\"title\":\"AOF持久化\",\"slug\":\"aof持久化\",\"link\":\"#aof持久化\",\"children\":[]},{\"level\":2,\"title\":\"RDB与AOF对比\",\"slug\":\"rdb与aof对比\",\"link\":\"#rdb与aof对比\",\"children\":[]}],\"readingTime\":{\"minutes\":5.46,\"words\":1637},\"filePathRelative\":\"database/redis/redis-advance-persistence.md\",\"excerpt\":\"<h1> Redis进阶 - Redis持久化</h1>\\n<div class=\\\"hint-container warning\\\">\\n<p class=\\\"hint-container-title\\\">单点Redis的问题</p>\\n<ul>\\n<li>数据丢失问题：Redis 是内存存储，服务重启可能会丢失数据。通过<strong>实现 Redis 数据持久化解决。</strong></li>\\n<li>并发能力问题：单节点 Redis 并发能力虽然不错，但是也无法满足如 618 这样的高并发场景。<strong>搭建主从集群，实现读写分离解决。</strong></li>\\n<li>故障恢复问题：如果 Redis 宕机，则服务不可用，需要一种自动的故障恢复手段。<strong>利用 Redis 哨兵，实现健康检测和自动恢复。</strong></li>\\n<li>存储能力问题：Redis 基于内存，单点能存储的数据量难以满足海量数据需求。<strong>搭建分片集群，利用插槽机制实现动态扩容。</strong></li>\\n</ul>\\n</div>\",\"autoDesc\":true}")

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
