export const pagesRoutes = [
  ["v-8daa1a0e","/",{"y":"h","t":"编程桅杆","i":"home"},["/readme.md"]],
  ["v-70bc2959","/algorithm/",{"e":"<h1> 算法题解</h1>\n","y":"a","t":"算法题解"},["/algorithm/Readme.md"]],
  ["v-14c69af4","/java/",{"e":"<h1> Java</h1>\n","y":"a","t":"Java"},["/java/readme.md"]],
  ["v-2e25198a","/database/",{"e":"<h1> 数据库</h1>\n","y":"a","t":"数据库"},["/database/readme.md"]],
  ["v-884a0bbc","/problems/",{"e":"<h1> 题解</h1>\n","y":"a","t":"题解"},["/problems/Readme.md"]],
  ["v-4165b7de","/spring-series/",{"e":"<h1> Spring 系列</h1>\n","y":"a","t":"Spring 系列"},["/spring-series/readme.md"]],
  ["v-d440f426","/tools/",{"e":"<h1> 工具使用</h1>\n","y":"a","t":"工具使用"},["/tools/readme.md"]],
  ["v-eb37a446","/java/basic/JDK.html",{"e":"<h1> Java - Java 开发环境配置</h1>\n","y":"a","t":"Java - Java 开发环境配置","O":1},[":md"]],
  ["v-ffb97496","/java/basic/",{"e":"<h1> Java 基础知识</h1>\n","y":"a","t":"Java 基础知识","O":2},["/java/basic/readme.md"]],
  ["v-724d33df","/java/collection/ArrayList.html",{"e":"<h1> ArrayList 源码解析</h1>\n","y":"a","t":"ArrayList 源码解析"},[":md"]],
  ["v-16722c46","/java/collection/",{"e":"<h1> Java 集合框架</h1>\n<figure><figcaption></figcaption></figure>\n","y":"a","t":"Java 集合框架","O":4},["/java/collection/readme.md"]],
  ["v-6ce7b6da","/java/oop/",{"e":"<h1> Java 面向对象</h1>\n<p>待更新</p>\n","y":"a","t":"Java 面向对象","O":3},["/java/oop/readme.md"]],
  ["v-dfa09558","/database/mysql/constraint.html",{"e":"<h1> MySQL基础 - 约束</h1>\n<h2> 概念</h2>\n<p>约束是作用于表中字段上的规则，用于限制存储在表中的数据。</p>\n<h2> 目的</h2>\n<p>为了保证数据库中数据的正确、有效性和完整性。</p>\n<h2> 分类</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">约束</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">关键字</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">非空约束</td>\n<td style=\"text-align:center\">限制该字段的数据不能为null</td>\n<td style=\"text-align:center\">NOT NULL</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">唯一约束</td>\n<td style=\"text-align:center\">保证该字段的所有数据都是唯一，不重复的</td>\n<td style=\"text-align:center\">UNIQUE</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">主键约束</td>\n<td style=\"text-align:center\">主键是一行数据的唯一标识，要求非空且唯一</td>\n<td style=\"text-align:center\">PRIMARY KEY</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">默认约束</td>\n<td style=\"text-align:center\">保存数据时，如果未指定该字段的值，则赋予该默认值</td>\n<td style=\"text-align:center\">DEFULT</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">条件约束</td>\n<td style=\"text-align:center\">保证字段值满足指定的条件</td>\n<td style=\"text-align:center\">CHECK</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">外键约束</td>\n<td style=\"text-align:center\">用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td>\n<td style=\"text-align:center\">FOREIGN KEY</td>\n</tr>\n</tbody>\n</table>","y":"a","t":"MySQL基础 - 约束","O":4},[":md"]],
  ["v-6c2bb6d0","/database/mysql/dividing-databases-tables.html",{"e":"<h1> MySQL运维 - 分库分表</h1>\n","y":"a","t":"MySQL运维 - 分库分表","O":35},[":md"]],
  ["v-0ca649bb","/database/mysql/function-base.html",{"e":"<h1> MySQL基础 - 函数</h1>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">函数</p>\n<p>函数是一段可以直接被另一段程序调用的程序或者代码。</p>\n</div>\n<h2> 字符串函数</h2>\n<p>MySQL中内置了很多的字符串函数，常用的几个如下所示:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">CONCAT(S1,S2,...,Sn)</td>\n<td style=\"text-align:center\">字符串拼接，将S1、S2、...、Sn按照顺序拼接成一个字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LOWER(str)</td>\n<td style=\"text-align:center\">将字符串str全部转成小写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">UPPER(str)</td>\n<td style=\"text-align:center\">将字符串str全部转成大写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LPAD(str,n,pad)</td>\n<td style=\"text-align:center\">左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RPAD(str,n,pad)</td>\n<td style=\"text-align:center\">右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">TRIM(str)</td>\n<td style=\"text-align:center\">去掉字符串头部和尾部的空格</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SUBSTRING(str,start,len)</td>\n<td style=\"text-align:center\">返回字符串str从start位置开始的len个长度的字符串</td>\n</tr>\n</tbody>\n</table>","y":"a","t":"MySQL基础 - 函数","O":3},[":md"]],
  ["v-b9856e14","/database/mysql/innodb-engine.html",{"e":"<h1> MySQL进阶 - InnoDB存储引擎</h1>\n<h2> 逻辑存储结构</h2>\n<p><br>\nInnoDB引擎的存储结构主要包含5个部分：</p>\n<ol>\n<li>表空间Tablespace</li>\n</ol>\n<p>主要是MySQL中的ibd文件，一个MySQL实例可以对应多个表空间，用于存储记录、索引等数据。表空间用来管理多个Segment段。</p>\n<ol start=\"2\">\n<li>段Segment</li>\n</ol>\n<p>段分为数据段(Leaf node segment)、索引段(Non-leaf node segment)、回滚段(Rollback segment)，InnoDB是索引组织表，数据段就是B+树的叶子结点，索引段即为B+树的非叶子结点。段用来管理多个Extent区。</p>","y":"a","t":"MySQL进阶 - InnoDB存储引擎","O":19},[":md"]],
  ["v-b1f4f0e2","/database/mysql/innodb-mvcc.html",{"e":"<h1> MySQL进阶 - MVCC多版本并发控制</h1>\n<h2> 概念介绍</h2>\n<h3> MVCC</h3>\n<p>MVCC全称为Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐藏字段、undo log 日志、readView。</p>\n<h3> 当前读</h3>\n<p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：<br>\nselect ... lock in share mode （共享锁），select ... for update 、insert、delete（排他锁）都是一种当前读。</p>","y":"a","t":"MySQL进阶 - MVCC多版本并发控制","O":20},[":md"]],
  ["v-8965f874","/database/mysql/master-slave-replication.html",{"e":"<h1> MySQL运维 - 主从复制</h1>\n","y":"a","t":"MySQL运维 - 主从复制","O":38},[":md"]],
  ["v-49034968","/database/mysql/multi-table-query.html",{"e":"<h1> MySQL基础 - 多表查询</h1>\n<h2> 多表关系</h2>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<p>在正式学习数据库的多表查询之前，我们需要了解到需要多表查询的场景，以及有哪些多表查询的情况，也就是数据表之间的关系。</p>\n</div>\n<h3> 一对一</h3>\n<p>一对一关系是我们比较常见的关系，比如数据表A中的一条值对应数据表B中的一条值，这种情况经常用于多表的拆分。例如将最常用的字段抽取出来，使得提高查询的效率。</p>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">实现</p>\n<p>在任意一方加入外键，关联另外一方的主键，并且设置唯一约束(UNIQUE)。</p>\n</div>","y":"a","t":"MySQL基础 - 多表查询","O":5},[":md"]],
  ["v-43c7fd75","/database/mysql/mysql-base.html",{"e":"<h1> MySQL基础 - 基础概念</h1>\n<h2> 基本概念</h2>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">区别</p>\n<p>在学习MySQL之前，我们需要明确一些基本概念，以便于后续的理解和学习。</p>\n</div>\n<ul>\n<li>数据库</li>\n</ul>\n<p>数据库是存储数据的仓库，数据是有组织的进行存储。简写为DataBase （DB）</p>\n<ul>\n<li>数据库管理系统</li>\n</ul>\n<p>操纵和管理数据库的大型软件系统。简写为DataBase Management System （DBMS）</p>","y":"a","t":"MySQL基础 - 基础概念","O":1},[":md"]],
  ["v-60dc87cc","/database/mysql/mysql-index.html",{"e":"<h1> MySQL进阶 - 索引</h1>\n<h2> 索引概述</h2>\n<h3> 概念</h3>\n<p>索引是帮助MySQL的<code>数据结构</code>（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式饮用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p>\n<h3> 优缺点</h3>\n<ul>\n<li>优点</li>\n</ul>\n<ol>\n<li>提高数据检索的效率，降低数据库的IO成本</li>\n<li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li>\n</ol>\n<ul>\n<li>缺点</li>\n</ul>","y":"a","t":"MySQL进阶 - 索引","O":13},[":md"]],
  ["v-789e275b","/database/mysql/mysql-lock.html",{"e":"<h1> MySQL进阶 - 锁</h1>\n<h2> 介绍</h2>\n<p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除了传统的计算机资源(CPU、RAM、I/O)的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>\n<h2> 全局锁</h2>\n<h3> 介绍</h3>\n<p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p>","y":"a","t":"MySQL进阶 - 锁","O":19},[":md"]],
  ["v-43a7dcb0","/database/mysql/mysql-log.html",{"e":"<h1> MySQL运维 - 日志</h1>\n","y":"a","t":"MySQL运维 - 日志","O":36},[":md"]],
  ["v-10ff6421","/database/mysql/mysql-manage.html",{"e":"<h1> MySQL进阶 - MySQL管理</h1>\n","y":"a","t":"MySQL进阶 - MySQL管理","O":23},[":md"]],
  ["v-4cf6c634","/database/mysql/mysql-trigger.html",{"e":"<h1> MySQL进阶 - 触发器</h1>\n<h2> 介绍</h2>\n<p>触发器是于表有关的数据库对象，指在insert、update、delete之前或者之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以与协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</p>\n<p>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p>\n<div class=\"hint-container note\">\n<p class=\"hint-container-title\">举例</p>\n<p>语句级触发：执行一次SQL，触发器会触发一次，无论影响多少行。<br>\n行级触发：如一个SQL语句更新了3行数据，则触发器会触发三次。</p>\n</div>","y":"a","t":"MySQL进阶 - 触发器","O":18},[":md"]],
  ["v-524a0e21","/database/mysql/mysql-view.html",{"e":"<h1> MySQL进阶 - 视图</h1>\n<h2> 介绍和基本语法</h2>\n<h3> 介绍</h3>\n<p>视图View是一种虚拟存在的表，视图中的数据并不在数据库中实际存在，行和列数据来自定义视图中使用的表，并且是在使用视图时动态生成的。</p>\n<p>简单的来说，视图不保存数据，只是保存了查询的SQL逻辑，不保存查询的结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">简单理解</p>\n<p>可以理解为给SQL语句设置别名，我们在使用的时候可以直接使用别名进行子查询、联合查询等操作。</p>\n</div>","y":"a","t":"MySQL进阶 - 视图","O":16},[":md"]],
  ["v-78afab36","/database/mysql/read-write-separation.html",{"e":"<h1> MySQL运维 - 读写分离</h1>\n","y":"a","t":"MySQL运维 - 读写分离","O":37},[":md"]],
  ["v-21ba2ec8","/database/mysql/",{"e":"<h1> MySQL 数据库</h1>\n<h2> 学习目录</h2>\n<ul>\n<li>基础篇\n<ol>\n<li>MySQL基础</li>\n<li>SQL基础语法</li>\n<li>函数</li>\n<li>约束</li>\n<li>多表查询</li>\n<li>事务</li>\n</ol>\n</li>\n<li>进阶篇\n<ol>\n<li>存储引擎</li>\n<li>索引</li>\n<li>SQL优化</li>\n<li>视图</li>\n<li>存储过程</li>\n<li>触发器</li>\n<li>锁</li>\n<li>InnoDB引擎</li>\n<li>MySQL管理</li>\n</ol>\n</li>\n<li>运维篇\n<ol>\n<li>日志</li>\n<li>主从复制</li>\n<li>分库分表</li>\n<li>读写分离</li>\n</ol>\n</li>\n</ul>","y":"a","t":"MySQL 数据库"},["/database/mysql/readme.md"]],
  ["v-149399ac","/database/mysql/sql-general-syntax.html",{"e":"<h1> MySQL基础 - SQL基础语法</h1>\n<h2> 通用语法</h2>\n<ol>\n<li>SQL语句可以单行或者多行书写，以分号结尾。</li>\n<li>SQL语句可以使用空格/缩进符来增强语句的可读性。</li>\n<li>MySQL数据库的SQL语言不区分大小写，关键字建议使用大写。</li>\n<li>注释</li>\n</ol>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">注释</p>\n<ul>\n<li>单行注释：-- 注释内容 或者 # 注释内容(MySQL特有的语法)</li>\n<li>多行注释：使用/* 注释内容 */</li>\n</ul>\n</div>","y":"a","t":"MySQL基础 - SQL基础语法","O":2},[":md"]],
  ["v-e01d4ed6","/database/mysql/sql-optimize.html",{"e":"<h1> MySQL进阶 - SQL优化</h1>\n<h2> insert优化</h2>\n<h3> 批量插入</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> table_name <span class=\"token keyword\">values</span> <span class=\"token punctuation\">(</span>values_list<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>","y":"a","t":"MySQL进阶 - SQL优化","O":15},[":md"]],
  ["v-21422c2d","/database/mysql/sql-perfomance-analysis.html",{"e":"<h1> MySQL进阶 - SQL性能分析</h1>\n<h2> SQL执行频率</h2>\n<p>MySQL客户端连接成功后，通过 SHOW [session | global] status 命令可以查看服务器状态信息。</p>\n<p>通过如下指令，可以查看当前数据库的INSERT、SELECT、UPDATE、DELETE操作的访问频次：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">GLOBAL</span> <span class=\"token keyword\">STATUS</span> <span class=\"token operator\">LIKE</span> <span class=\"token string\">\"Com_______\"</span><span class=\"token punctuation\">;</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>","y":"a","t":"MySQL进阶 - SQL性能分析","O":14},[":md"]],
  ["v-9f994086","/database/mysql/storage-engine.html",{"e":"<h1> MySQL进阶 - 存储引擎</h1>\n<h2> MySQL的体系结构</h2>\n<figure><figcaption>MySQL的体系结构示意图</figcaption></figure>\n<ul>\n<li>\n<p>连接层<br>\n连接层处于MySQL体系结构中的最上层，是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、以及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>\n</li>\n<li>\n<p>服务层<br>\n服务层处于MySQL体系结构中的第二层，主要完成大多书的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有存储引擎的功能也在这一层实现，如 过程、函数等。</p>\n</li>\n<li>\n<p>引擎层</p>\n</li>\n</ul>","y":"a","t":"MySQL进阶 - 存储引擎","O":22},[":md"]],
  ["v-79533b1a","/database/mysql/store-procedure.html",{"e":"<h1> MySQL进阶 - 存储过程</h1>\n<h2> 介绍</h2>\n<p>存储过程是事先经过编译并且存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p>\n<p>存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。</p>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">个人理解</p>\n<p>这里我个人理解的是 类似于 编程语言中的函数，将一些语句封装起来，直接进行函数的调用即可。</p>\n</div>","y":"a","t":"MySQL进阶 - 存储过程","O":17},[":md"]],
  ["v-13f32783","/database/mysql/transaction.html",{"e":"<h1> MySQL基础 - 事务</h1>\n<p>事务是一组操作的集合，他是一个不可分隔的工作单位，事务会把所有的操作作为一个整体一起向系统提交或者撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>\n<h2> 事务操作</h2>\n<ul>\n<li>查看/设置事务提交方式</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">SELECT</span> @<span class=\"token variable\">@autocommit</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SET</span> @<span class=\"token variable\">@autocommit</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"MySQL基础 - 事务","O":6},[":md"]],
  ["v-a94b64b0","/problems/leetcode/leetcode15.html",{"e":"<h1> 15.三数之和</h1>\n<h2> 题目描述</h2>\n<p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</p>\n<p>你返回所有和为 0 且不重复的三元组。</p>\n<p>注意：答案中不可以包含重复的三元组。</p>\n<p>示例 1：</p>\n<p>输入：nums = [-1,0,1,2,-1,-4]<br>\n输出：[[-1,-1,2],[-1,0,1]]</p>\n<p>解释：<br>\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。<br>\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。<br>\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。<br>\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br>\n注意，输出的顺序和三元组的顺序并不重要。<br>\n示例 2：</p>","y":"a","t":"15.三数之和","O":15},[":md"]],
  ["v-ebd584f6","/problems/leetcode/leetcode1646.html",{"e":"<h1> 1646. 获取生成数组中的最大值</h1>\n<h2> 题目介绍</h2>\n<p>给你一个整数 n 。按下述规则生成一个长度为 n + 1 的数组 nums ：</p>\n<p>nums[0] = 0<br>\nnums[1] = 1<br>\n当 2 &lt;= 2 * i &lt;= n 时，nums[2 * i] = nums[i]<br>\n当 2 &lt;= 2 * i + 1 &lt;= n 时，nums[2 * i + 1] = nums[i] + nums[i + 1]<br>\n返回生成数组 nums 中的 最大 值。</p>\n<h2> 题目地址</h2>\n<p><a href=\"https://leetcode-cn.com/problems/get-maximum-in-generated-array/\" target=\"_blank\" rel=\"noopener noreferrer\">1646. 获取生成数组中的最大值</a></p>","y":"a","t":"1646. 获取生成数组中的最大值","O":1646},[":md"]],
  ["v-004e2d72","/problems/leetcode/leetcode455.html",{"e":"<h1> 455.分发饼干</h1>\n<h2> 题目描述</h2>\n<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>\n<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>\n<p>示例 1:</p>\n<p>输入: g = [1,2,3], s = [1,1]<br>\n输出: 1<br>\n解释:<br>\n你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>\n虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>\n所以你应该输出1。<br>\n示例 2:</p>","y":"a","t":"455.分发饼干","O":455},[":md"]],
  ["v-66839488","/problems/leetcode/leetcode509.html",{"e":"<h1> 509. 斐波那契数</h1>\n<h2> 题目描述</h2>\n<p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>\n<p>F(0) = 0，F(1) = 1<br>\nF(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>\n给定 n ，请计算 F(n) 。</p>\n<p>示例 1：</p>\n<p>输入：n = 2<br>\n输出：1<br>\n解释：F(2) = F(1) + F(0) = 1 + 0 = 1</p>\n<p>示例 2：<br>\n输入：n = 3<br>\n输出：2<br>\n解释：F(3) = F(2) + F(1) = 1 + 1 = 2</p>","y":"a","t":"509. 斐波那契数","O":509},[":md"]],
  ["v-a28a27e0","/problems/leetcode/leetcode62.html",{"e":"<h1> 62.不同路径</h1>\n<h2> 题目描述</h2>\n<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>\n<p>问总共有多少条不同的路径？</p>\n<p>示例 1：</p>\n<p>输入：m = 3, n = 7<br>\n输出：28<br>\n示例 2：</p>\n<p>输入：m = 3, n = 2<br>\n输出：3<br>\n解释：<br>\n从左上角开始，总共有 3 条路径可以到达右下角。</p>\n<ol>\n<li>向右 -&gt; 向下 -&gt; 向下</li>\n<li>向下 -&gt; 向下 -&gt; 向右</li>\n<li>向下 -&gt; 向右 -&gt; 向下<br>\n示例 3：</li>\n</ol>","y":"a","t":"62.不同路径","O":62},[":md"]],
  ["v-71afee22","/problems/leetcode/leetcode6322.html",{"e":"<h1> 6322.检查骑士巡视方案</h1>\n<h2> 题目描述</h2>\n<p>骑士在一张 n x n 的棋盘上巡视。在有效的巡视方案中，骑士会从棋盘的 左上角 出发，并且访问棋盘上的每个格子 恰好一次 。</p>\n<p>给你一个 n x n 的整数矩阵 grid ，由范围 [0, n * n - 1] 内的不同整数组成，其中 grid[row][col] 表示单元格 (row, col) 是骑士访问的第 grid[row][col] 个单元格。骑士的行动是从下标 0 开始的。</p>\n<p>如果 grid 表示了骑士的有效巡视方案，返回 true；否则返回 false。</p>\n<p>注意，骑士行动时可以垂直移动两个格子且水平移动一个格子，或水平移动两个格子且垂直移动一个格子。下图展示了骑士从某个格子出发可能的八种行动路线。</p>","y":"a","t":"6322.检查骑士巡视方案","O":6322},[":md"]],
  ["v-3f9113da","/problems/leetcode/leetcode70.html",{"e":"<h1> 70. 爬楼梯</h1>\n<h2> 题目描述</h2>\n<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n<p>示例 1：</p>\n<p>输入：n = 2<br>\n输出：2<br>\n解释：有两种方法可以爬到楼顶。</p>\n<ol>\n<li>1 阶 + 1 阶</li>\n<li>2 阶<br>\n示例 2：</li>\n</ol>\n<p>输入：n = 3<br>\n输出：3<br>\n解释：有三种方法可以爬到楼顶。</p>\n<ol>\n<li>1 阶 + 1 阶 + 1 阶</li>\n<li>1 阶 + 2 阶</li>\n<li>2 阶 + 1 阶</li>\n</ol>","y":"a","t":"70. 爬楼梯","O":70},[":md"]],
  ["v-04c0516d","/problems/leetcode/leetcode746.html",{"e":"<h1> 746. 使用最小花费爬楼梯</h1>\n<h2> 题目描述</h2>\n<p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>\n<p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p>\n<p>请你计算并返回达到楼梯顶部的最低花费。</p>\n<p>示例 1：</p>\n<p>输入：cost = [10,15,20]<br>\n输出：15<br>\n解释：你将从下标为 1 的台阶开始。</p>\n<ul>\n<li>支付 15 ，向上爬两个台阶，到达楼梯顶部。<br>\n总花费为 15 。<br>\n示例 2：</li>\n</ul>","y":"a","t":"746. 使用最小花费爬楼梯","O":746},[":md"]],
  ["v-22c4764c","/problems/leetcode/leetcode88.html",{"e":"<h1> 88.合并两个有序数组</h1>\n<h2> 题目介绍</h2>\n<p>给你两个按 非递减顺序 排列的整数数组&nbsp;nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>\n<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>\n<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>\n<p>示例 1：</p>","y":"a","t":"88.合并两个有序数组","O":88},[":md"]],
  ["v-56c36d18","/problems/leetcode/",{"e":"<h1> Leetcode 题解</h1>\n","y":"a","t":"Leetcode 题解"},["/problems/leetcode/readme.md"]],
  ["v-9a72c4ae","/computer/cn/",{"e":"<h1> 计算机网络</h1>\n","y":"a","t":"计算机网络","O":4},["/computer/cn/Readme.md"]],
  ["v-1be8c5c4","/computer/cn/cn-tcp-3-4.html",{"e":"<h1> TCP三次握手和四次挥手图文详解</h1>\n<figure><figcaption>tcp连接</figcaption></figure>\n<h2> 什么是TCP连接？</h2>\n<p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议是同一层内另一个重要的传输协议。在因特网协议族中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。</p>\n<h2> 三次握手</h2>\n<p>三次握手是发生在TCP的连接过程中的，具体的步骤如下：</p>","y":"a","t":"TCP三次握手和四次挥手图文详解"},[":md"]],
  ["v-9a72c470","/computer/co/",{"e":"<h1> 计算机组成原理</h1>\n","y":"a","t":"计算机组成原理","O":2},["/computer/co/readme.md"]],
  ["v-2921a50f","/database/redis/",{"e":"<h1> Redis 数据库</h1>\n<figure><figcaption>Redis</figcaption></figure>\n<h2> 大纲</h2>\n<h3> Redis入门</h3>\n<ul>\n<li><a href=\"https://www.codermast.com/database/redis/redis-introduction-concept-fundamental.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis入门 - Redis概念和基础</a></li>\n<li><a href=\"https://www.codermast.com/database/redis/redis-introduction-base-commind.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis入门 - 基础通用指令</a></li>\n<li><a href=\"https://www.codermast.com/database/redis/redis-introduction-five-base-datatype.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis入门 - 5种基本数据类型</a></li>\n<li><a href=\"https://www.codermast.com/database/redis/redis-introduction-three-special-datatype.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis入门 - 3种特殊数据类型</a></li>\n<li><a href=\"https://www.codermast.com/database/redis/redis-introduction-pub-sub.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis入门 - 发布订阅</a></li>\n<li><a href=\"https://www.codermast.com/database/redis/redis-introduction-transaction.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis入门 - 事务</a></li>\n<li><a href=\"https://www.codermast.com/database/redis/redis-introduction-scription.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis入门 - Lua脚本</a></li>\n<li><a href=\"https://www.codermast.com/database/redis/redis-introduction-stream.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redis入门 - Redis Stream</a></li>\n</ul>","y":"a","t":"Redis 数据库"},["/database/redis/readme.md"]],
  ["v-a164f926","/database/redis/redis-advance-batch-optimization.html",{"e":"<h1> Redis进阶 - 批处理优化</h1>\n","y":"a","t":"Redis进阶 - 批处理优化","O":22},[":md"]],
  ["v-20c7d348","/database/redis/redis-advance-cache-issues.html",{"e":"<h1> Redis进阶 - 缓存问题</h1>\n<h2> 缓存</h2>\n<p>缓存就是数据交换的缓冲区（Cache），是存储数据的临时地方，一般读写性能比较高。</p>\n<ul>\n<li>例如</li>\n</ul>\n<ol>\n<li>内存是硬盘的缓存</li>\n<li>cache 是内存的缓存</li>\n</ol>\n<ul>\n<li>作用</li>\n</ul>\n<ol>\n<li>降低后端负载</li>\n<li>提高读写效率，降低响应时间</li>\n</ol>\n<ul>\n<li>成本</li>\n</ul>\n<ol>\n<li>数据一致性成本</li>\n<li>代码维护成本</li>\n</ol>","y":"a","t":"Redis进阶 - 缓存问题","O":13},[":md"]],
  ["v-519b40a0","/database/redis/redis-advance-cache-synchronization.html",{"e":"<h1> Redis进阶 - 缓存同步</h1>\n","y":"a","t":"Redis进阶 - 缓存同步","O":20},[":md"]],
  ["v-75198dab","/database/redis/redis-advance-cluster-best-practices.html",{"e":"<h1> Redis进阶 - 集群最佳实践</h1>\n","y":"a","t":"Redis进阶 - 集群最佳实践","O":24},[":md"]],
  ["v-10b5d72d","/database/redis/redis-advance-jvm-process-cache.html",{"e":"<h1> Redis进阶 - JVM进程缓存</h1>\n<p><strong>传统缓存的问题</strong></p>\n<p>传统的缓存策略一般是请求到达 Tomcat 后，先查询 Redis ，如果未命中则查询数据库，存在下面的问题：</p>\n<ul>\n<li>请求要经过 Tomcat 处理，Tomcat 的性能成为整个系统的瓶颈</li>\n<li>Redis 缓存失效时，会对数据库产生冲击</li>\n</ul>\n<figure><figcaption></figcaption></figure>\n<p><strong>多级缓存方案</strong></p>\n<p>多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻 Tomcat 压力，提升服务性能：</p>","y":"a","t":"Redis进阶 - JVM进程缓存","O":17},[":md"]],
  ["v-23873776","/database/redis/redis-advance-key-value-design.html",{"e":"<h1> Redis进阶 - 键值设计</h1>\n","y":"a","t":"Redis进阶 - 键值设计","O":21},[":md"]],
  ["v-8846cbc0","/database/redis/redis-advance-lua-language.html",{"e":"<h1> Redis进阶 - Lua语法</h1>\n<h2> 初识 Lua</h2>\n<p>Lua 是一种轻量小巧的脚本语言，用标准的 C 语言编写并以源代码形式开放，其设计的目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>\n<p>官网：<a href=\"https://www.lua.org/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.lua.org/</a></p>\n<figure><figcaption></figcaption></figure>\n<h2> 快速入门</h2>\n<ol>\n<li>在 Linux 虚拟机的任意目录下，新建一个 hello.lua 文件</li>\n</ol>","y":"a","t":"Redis进阶 - Lua语法","O":18},[":md"]],
  ["v-2e845f3e","/database/redis/redis-advance-master-slave.html",{"e":"<h1> Redis进阶 - Redis主从</h1>\n<h2> 搭建主从架构</h2>\n<p>单节点 Redis 的并发能力是有上限的，要进一步提高 Redis 的并发能力，就需要搭建主从集群，实现读写分离。</p>\n<blockquote>\n<p>在 Redis 5.0 以前，从节点都叫做 slave，在 5.0 版本以后被称为 replica，本质上是一个东西。</p>\n</blockquote>\n<h3> 1.集群结构</h3>\n<p>我们搭建的主从集群结构如图：</p>\n<figure><figcaption></figcaption></figure>\n<p>共包含三个节点，一个主节点，两个从节点。</p>","y":"a","t":"Redis进阶 - Redis主从","O":14},[":md"]],
  ["v-6a3d1060","/database/redis/redis-advance-multi-level-cache.html",{"e":"<h1> Redis进阶 - 多级缓存</h1>\n<h2> 安装OpenResty</h2>\n<p>在正式安装 OpenResty 之前，我们需要了解它是干什么的。</p>\n<p>OpenResty® 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</p>\n<p>OpenResty® 通过汇聚各种设计精良的 Nginx 模块（主要由 OpenResty 团队自主开发），从而将 Nginx 有效地变成一个强大的通用 Web 应用平台。这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。</p>","y":"a","t":"Redis进阶 - 多级缓存","O":19},[":md"]],
  ["v-b6a85f34","/database/redis/redis-advance-persistence.html",{"e":"<h1> Redis进阶 - Redis持久化</h1>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">单点Redis的问题</p>\n<ul>\n<li>数据丢失问题：Redis 是内存存储，服务重启可能会丢失数据。通过<strong>实现 Redis 数据持久化解决。</strong></li>\n<li>并发能力问题：单节点 Redis 并发能力虽然不错，但是也无法满足如 618 这样的高并发场景。<strong>搭建主从集群，实现读写分离解决。</strong></li>\n<li>故障恢复问题：如果 Redis 宕机，则服务不可用，需要一种自动的故障恢复手段。<strong>利用 Redis 哨兵，实现健康检测和自动恢复。</strong></li>\n<li>存储能力问题：Redis 基于内存，单点能存储的数据量难以满足海量数据需求。<strong>搭建分片集群，利用插槽机制实现动态扩容。</strong></li>\n</ul>\n</div>","y":"a","t":"Redis进阶 - Redis持久化","O":13},[":md"]],
  ["v-9507482e","/database/redis/redis-advance-sentinel.html",{"e":"<h1> Redis进阶 - Redis哨兵</h1>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">思考</p>\n<p>slave 节点宕机恢复以后可以找 master 节点同步数据，那么 master 节点宕机怎么办？</p>\n</div>\n<h2> 哨兵的作用和工作原理</h2>\n<h3> 哨兵的作用</h3>\n<p>Redis 提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下：</p>\n<figure><figcaption></figcaption></figure>","y":"a","t":"Redis进阶 - Redis哨兵","O":15},[":md"]],
  ["v-8e986b64","/database/redis/redis-advance-server-optimization.html",{"e":"<h1> Redis进阶 - 服务端优化</h1>\n","y":"a","t":"Redis进阶 - 服务端优化","O":23},[":md"]],
  ["v-3c43b28a","/database/redis/redis-advance-sharded-cluster.html",{"e":"<h1> Redis进阶 - Redis分片集群</h1>\n<h2> 搭建分片集群</h2>\n<p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p>\n<ul>\n<li>海量数据存储问题</li>\n<li>高并发写的问题</li>\n</ul>\n<p>使用分片集群可以解决上述问题，分片集群特征：</p>\n<ul>\n<li>集群中有多个 master，每个 master 保存不同数据</li>\n<li>每个 master 都可以有多个 slave 节点</li>\n<li>master 之间通过 ping 监测彼此健康状态</li>\n<li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</li>\n</ul>","y":"a","t":"Redis进阶 - Redis分片集群","O":16},[":md"]],
  ["v-573ec1a9","/database/redis/redis-client-jedis-connection-pool.html",{"e":"<h1> Redis客户端 - Jedis连接池</h1>\n<p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们使用Jedis连接池代替Jedis的直接连接方式。</p>\n<ul>\n<li>配置Jedis连接池</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">JedisConnectionFactory</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">JedisPool</span> jedisPool<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">JedisPoolConfig</span> jedisPollConfig <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JedisPoolConfig</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 最大连接，这里设置为 8</span>\n        jedisPollConfig<span class=\"token punctuation\">.</span><span class=\"token function\">setMaxTotal</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 最大空闲连接，这里设置为 8</span>\n        jedisPollConfig<span class=\"token punctuation\">.</span><span class=\"token function\">setMaxIdle</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 最小空闲连接，这里设置为 0 </span>\n        jedisPollConfig<span class=\"token punctuation\">.</span><span class=\"token function\">setMaxIdle</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 设置最长等待时间，单位 ms</span>\n        jedisPollConfig<span class=\"token punctuation\">.</span><span class=\"token function\">setMaxWaitMillis</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        jedisPool <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JedisPool</span><span class=\"token punctuation\">(</span>jedisPoolConfig<span class=\"token punctuation\">,</span><span class=\"token string\">\"192.168.100.100\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">6379</span><span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"codermast\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 获取Jedis对象</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Jedis</span> <span class=\"token function\">getJedis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> jedisPool<span class=\"token punctuation\">.</span><span class=\"token function\">getResource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"Redis客户端 - Jedis连接池","O":10},[":md"]],
  ["v-53e49a9c","/database/redis/redis-client-jedis-quick-start.html",{"e":"<h1> Redis客户端 - Jdies快速入门</h1>\n<h2> 简介</h2>\n<p>Jedis is a Java client for Redis designed for performance and ease of use.</p>\n<p>Jedis是Redis 的 Java 客户端，专为性能和易用性而设计。</p>\n<h2> 官方地址</h2>\n<p>Jedis的官方地址：<a href=\"https://github.com/redis/jedis\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/redis/jedis</a></p>","y":"a","t":"Redis客户端 - Jdies快速入门","O":9},[":md"]],
  ["v-fcc65208","/database/redis/redis-client-redistemplate-redis-serializer.html",{"e":"<h1> Redis客户端 - RedisSerializer</h1>\n<div class=\"hint-container note\">\n<p class=\"hint-container-title\">前景回顾</p>\n<p>在上一篇中，我们实现了一个简单的案例，操作一个 String 类型的数据，插入了一个 name = codermast 的数据到Redis。</p>\n</div>\n<p>使用redis-cli客户端连接对应的Redis服务器后，按道理来讲<code>get name</code>这个指令的返回结果应该是 <code>codermast</code></p>\n<figure><figcaption>redis-cli客户端查看</figcaption></figure>","y":"a","t":"Redis客户端 - RedisSerializer","O":12},[":md"]],
  ["v-f84282fc","/database/redis/redis-client-spring-data-redis.html",{"e":"<h1> Redis客户端 - SpringDataRedis</h1>\n<h2> 介绍</h2>\n<p>SpringData 是 Spring 中操作数据的模块，包含对各种数据库的集成，其中对 Redis 的集成模块就叫做 SpringDataRedis，官网地址：<a href=\"https://spring.io/prohects/spring-data-redis\" target=\"_blank\" rel=\"noopener noreferrer\">https://spring.io/prohects/spring-data-redis</a></p>\n<ul>\n<li>提供了对不同 Redis 客户端的整合 （Lettuce 和 Jedis）</li>\n<li>提供了 RedisTemplate 统一 API 来操作Redis</li>\n<li>支持 Redis 的发布订阅模型</li>\n<li>支持 Redis 哨兵和 Redis 集群</li>\n<li>支持基于 Lettuce 的响应式编程</li>\n<li>支持基于 JDK、JSON、字符串、Spring对象的数据序列化和反序列化</li>\n<li>支持基于 Redis 的 JDKCollection 实现</li>\n</ul>","y":"a","t":"Redis客户端 - SpringDataRedis","O":11},[":md"]],
  ["v-54dbf3e0","/database/redis/redis-introduction-base-commind.html",{"e":"<h1> Redis入门 - 基础通用指令</h1>\n<p>在正式介绍Redis数据结构及其操作指令之前，我们需要先掌握一些最基础的通用指令。</p>\n<p>这些都是Redis操作过程中的一些常见指令</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">指令</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">keys</td>\n<td style=\"text-align:center\">查看符合模板的所有key，不建议在⽣产环境设备上使⽤</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">del</td>\n<td style=\"text-align:center\">删除⼀个指定的key</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">esists</td>\n<td style=\"text-align:center\">判断key是否存在</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">expire</td>\n<td style=\"text-align:center\">给⼀个key设置有效期，有效期到期时该key会被⾃动删除</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ttl</td>\n<td style=\"text-align:center\">查看⼀个KEY的剩余有效期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">quit</td>\n<td style=\"text-align:center\">退出</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">shutdown</td>\n<td style=\"text-align:center\">关闭服务器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">select [0-15]</td>\n<td style=\"text-align:center\">选择指定的数据库</td>\n</tr>\n</tbody>\n</table>","y":"a","t":"Redis入门 - 基础通用指令","O":2},[":md"]],
  ["v-71e056ea","/database/redis/redis-introduction-concept-fundamental.html",{"e":"<h1> Redis入门 - Redis概念和基础</h1>\n<h2> 什么是NoSQL</h2>\n<ul>\n<li>NoSQL，泛指非关系型的数据库。</li>\n<li>NoSQL最常见的解释是 \"non-relational\"， 很多人也说它是\"Not Only SQL\"</li>\n<li>NoSQL仅仅是一个概念，泛指<strong>非关系型的数据库</strong></li>\n<li>区别于关系数据库，它们不保证关系数据的ACID特性</li>\n<li>NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入</li>\n<li>常见的NoSQL数据库有：<code>Redis</code>、<code>MemCache</code>、<code>MongoDB</code>等</li>\n</ul>","y":"a","t":"Redis入门 - Redis概念和基础","O":1},[":md"]],
  ["v-74de4522","/database/redis/redis-introduction-five-base-datatype.html",{"e":"<h1> Redis入门 - 5种基本数据类型</h1>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">说明</p>\n<p>在我们平常的业务中基本只会使用到Redis的基本数据类型（String、List、Hash、Set、Sorted Set），特殊类型（Geo、Bitmap、Hyperloglog）类型只有在特殊的业务场景下会使用到，通常只需要掌握基本数据类型即可，特殊类型作为了解即可。</p>\n</div>\n<h2> String 字符串</h2>\n<p>String类型，也就是字符串类型，是Redis中最简单的存储类型。String 类型是二进制安全的。意思是 redis 的 String 可以包含任何数据。比如jpg图片或者序列化的对象。</p>","y":"a","t":"Redis入门 - 5种基本数据类型","O":3},[":md"]],
  ["v-1366557b","/database/redis/redis-introduction-pub-sub.html",{"e":"<h1> Redis入门 - 发布订阅</h1>\n<p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>\n<p>此种模式下，消息发布者和订阅者不进行直接通信，发布者客户端向指定的频道（channel） 发布消息，订阅该频道的每个客户端都可以收到该消息，</p>\n<p>Redis 客户端可以订阅任意数量的频道。</p>\n<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：<br>\n</p>\n<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>","y":"a","t":"Redis入门 - 发布订阅","O":5},[":md"]],
  ["v-21c9d5a4","/database/redis/redis-introduction-scription.html",{"e":"<h1> Redis入门 - Lua脚本</h1>\n<p>Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。</p>\n<h2> 语法</h2>\n<p>Eval 命令的基本语法如下：<code>EVAL script numkeys key [key ...] arg [arg ...]</code></p>\n<h2> 脚本命令</h2>\n<ul>\n<li>执行Lua脚本：<code>EVAL script numkeys key [key ...] arg [arg ...]</code></li>\n<li>将脚本添加到脚本缓存，但不执行：<code>SCRIPT LOAD script</code></li>\n<li>从脚本缓存中移除所有脚本：<code>SCRIPT FLUSH</code></li>\n<li>杀死当前正在运行的 Lua 脚本：<code>SCRIPT KILL</code></li>\n<li>查看指定的脚本是否已经被保存在缓存当中：<code>SCRIPT EXISTS script [script ...]</code></li>\n<li>根据给定的 sha1 校验码，执行缓存在服务器中的脚本：<code>EVALSHA sha1 numkeys key [key ...] arg [arg ...] </code></li>\n</ul>","y":"a","t":"Redis入门 - Lua脚本","O":7},[":md"]],
  ["v-e750edf2","/database/redis/redis-introduction-stream.html",{"e":"<h1> Redis入门 - Redis Stream</h1>\n<p>Redis Stream 是 Redis 5.0 版本新增加的数据结构。</p>\n<p>Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</p>\n<p>简单来说发布订阅 (pub/sub) 可以分发消息，但无法记录历史消息。</p>\n<p>而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p>","y":"a","t":"Redis入门 - Redis Stream","O":8},[":md"]],
  ["v-08e2c420","/database/redis/redis-introduction-three-special-datatype.html",{"e":"<h1> Redis入门 - 3种特殊数据类型</h1>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">说明</p>\n<p>在我们平常的业务中基本只会使用到Redis的基本数据类型（String、List、Hash、Set、Sorted Set），特殊类型（Geo、Bitmap、Hyperloglog）类型只有在特殊的业务场景下会使用到，通常只需要掌握基本数据类型即可，特殊类型作为了解即可。</p>\n</div>\n<h2> GEO类型</h2>\n<p>GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常⻅操作。</p>","y":"a","t":"Redis入门 - 3种特殊数据类型","O":4},[":md"]],
  ["v-06153dcd","/database/redis/redis-introduction-transaction.html",{"e":"<h1> Redis入门 - 事务</h1>\n<p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p>\n<ul>\n<li>批量操作在发送 EXEC 命令前被放入队列缓存。</li>\n<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li>\n<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>\n</ul>\n<p>一个事务从开始到执行会经历以下三个阶段：</p>\n<ul>\n<li>开始事务。</li>\n<li>命令入队。</li>\n<li>执行事务。</li>\n</ul>\n<p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>","y":"a","t":"Redis入门 - 事务","O":6},[":md"]],
  ["v-7ffb8e61","/database/redis/redis-principle-IO.html",{"e":"<h1> Redis原理 - IO详解</h1>\n<h2> 用户空间与内核空间</h2>\n<p>任何Linux 系统的发行版，其系统内核都是 Linux 。我们的应用都需要通过 Linux 内核与硬件交互。</p>\n<figure><figcaption></figcaption></figure>\n<p>为了避免用户应用导致冲突甚至内核崩溃，用户应用与内核是分离的：</p>\n<ul>\n<li>内存的寻址空间划分为两部分：内核空间、用户空间</li>\n</ul>\n<blockquote>\n<p>32 位的操作系统，寻址地址就为 0 ~ <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding=\"application/x-tex\">2 ^ {32}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">32</span></span></span></span></span></span></span></span></span></span></span></span></p>\n</blockquote>","y":"a","t":"Redis原理 - IO详解","O":28},[":md"]],
  ["v-4202f375","/database/redis/redis-principle-base-datatype-implement.html",{"e":"<h1> Redis原理 - 五种数据类型的底层结构关系</h1>\n<figure><figcaption></figcaption></figure>\n<h2> 字符串对象String</h2>\n<p>String 是 Redis 中最常见的数据存储类型。</p>\n<ul>\n<li>其基本编码方式是 RAW ，基于简单动态字符串（SDS）实现，存储上限为 512 MB。</li>\n</ul>\n<figure><figcaption></figcaption></figure>\n<ul>\n<li>如果存储的 SDS 长度小于 44 字节，则会采用 <strong>EMBSTR</strong> 编码，此时 object head 与 SDS 是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高。</li>\n</ul>","y":"a","t":"Redis原理 - 五种数据类型的底层结构关系","O":27},[":md"]],
  ["v-6dc1af78","/database/redis/redis-principle-communication-protocol.html",{"e":"<h1> Redis原理 - 通信协议RESP</h1>\n<h2> RESP协议</h2>\n<p>Redis 是一个 CS 架构的软件，通信一般分两步（不包括pipeline 和 PubSub）：</p>\n<ol>\n<li>客户端（client）向服务端（server）发送一条命令</li>\n<li>服务端解析并执行命令，返回响应结果给客户端</li>\n</ol>\n<p>因此客户端发送命令的格式、服务端响应结果的格式必须有一个规范，这个规范就是通信协议。</p>\n<div class=\"hint-container note\">\n<p class=\"hint-container-title\">CS架构</p>\n<p>CS架构一般指服务器-客户机。 服务器-客户机，即Client-Server(C/S)结构。C/S结构通常采取两层结构。服务器负责数据的管理，客户机负责完成与用户的交互任务。</p>\n<p><a href=\"https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%AE%A2%E6%88%B7%E6%9C%BA?fromtitle=CS%E6%9E%B6%E6%9E%84&amp;fromid=7859292&amp;fromModule=lemma_search-box\" target=\"_blank\" rel=\"noopener noreferrer\">百度百科-CS架构</a></p>\n</div>","y":"a","t":"Redis原理 - 通信协议RESP","O":30},[":md"]],
  ["v-3420ecf3","/database/redis/redis-principle-datastruct-underlying-implementation.html",{"e":"<h1> Redis原理 - 数据结构的底层实现</h1>\n<h2> 动态字符串SDS</h2>\n<h3> 基本概念</h3>\n<p>Redis 中保存的 Key 是字符串，Value 往往是字符串或者字符串的集合。可见字符串是 Redis 中最常见的一种数据结构。</p>\n<p>Redis 是使用 C 语言来编写的，C 语言中也有字符串，但是 Redis 中并没有直接使用 C 语言的字符串，这是因为 C 语言中字符串存在着很多的问题：</p>\n<ul>\n<li>获取字符串长度需要进行运算</li>\n<li>非二进制安全，不能包含特殊字符</li>\n</ul>\n<blockquote>\n<p>因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p>\n</blockquote>","y":"a","t":"Redis原理 - 数据结构的底层实现","O":26},[":md"]],
  ["v-79599d42","/database/redis/redis-principle-memery-strategy.html",{"e":"<h1> Redis原理 - 内存策略</h1>\n<p>Redis 本身是一个典型的 key-value 内存存储数据库，因此所有的 key、value 都保存在之前学习过的 Dict 结构中。不过在其 database 结构体中，有两个 Dict ：一个用来记录 key-value；另外一个用来记录 key-TTL</p>\n<figure><figcaption></figcaption></figure>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><pre class=\"language-c\"><code><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">redisDb</span> <span class=\"token punctuation\">{</span>\n    dict <span class=\"token operator\">*</span>dict<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 存放所有 key 和 value 的地方</span>\n    dict <span class=\"token operator\">*</span>expires<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 存放每一个 key 及其对应的 TTL 存活时间，只包含设置了 TTL 的 key</span>\n    dict <span class=\"token operator\">*</span>blocking_keys<span class=\"token punctuation\">;</span>   \n    dict <span class=\"token operator\">*</span>ready_keys<span class=\"token punctuation\">;</span>\n    dict <span class=\"token operator\">*</span>watched_keys<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> id<span class=\"token punctuation\">;</span>         <span class=\"token comment\">// Database ID ：0 ~ 15</span>\n    <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> avg_ttl<span class=\"token punctuation\">;</span>  \n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> expires_cursor<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// expire 检查时在 dict 中抽样的索引位置</span>\n    list <span class=\"token operator\">*</span>defrag_later<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 等待碎片整理的 key 列表</span>\n<span class=\"token punctuation\">}</span> redisDb<span class=\"token punctuation\">;</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"Redis原理 - 内存策略","O":31},[":md"]],
  ["v-a98569f0","/database/redis/redis-principle-netword-model.html",{"e":"<h1> Redis原理 - Redis网络模型</h1>\n<h2> 思考</h2>\n<p><strong>Redis 到底是单线程还是多线程？</strong></p>\n<ul>\n<li>如果仅仅针对 Redis 的核心业务部分（命令处理部分），则是单线程</li>\n<li>如果针对 Redis 整体，那么就是多线程</li>\n</ul>\n<p><strong>在 Redis 的版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</strong></p>\n<ul>\n<li>Redis v4.0：引入多线程异步处理一些耗时较长的任务，例如异步删除命令 unlike</li>\n<li>Redis v6.0：在核心网络模型中引入多线程，进一步提高对多核 CPU 的利用率</li>\n</ul>","y":"a","t":"Redis原理 - Redis网络模型","O":29},[":md"]],
  ["v-38959971","/database/redis/redis-principle-redisobject.html",{"e":"<h1> Redis原理 - RedisObject对象机制</h1>\n<h2> 为什么会设计RedisObject</h2>\n<p>在 Redis 中，我们的操作都是使用指令进行，而这些的命令中，用于对键处理的命令占据一大部分。有些指令只能针对某些特定的类型，而有些指令却能够针对所有的类型。但是要正确实现这些命令，必须为不同类型的键设置不同的处理方式。比如删除一个列表键和删除一个字符串键的操作过程是不一样的，在底层就需要调用不同的视线方式。</p>\n<p>集合类型有字典和整数集合两种不同的底层实现方式，而用户在对集合进行操作时，并不想关心具体的底层实现是什么样的，只要 Redis 能根据自己的指令，完成对应的功能即可，比如对元素进行添加、删除等操作，具体的实现底层对用户来说是透明的，不可见的。</p>","y":"a","t":"Redis原理 - RedisObject对象机制","O":25},[":md"]],
  ["v-0fac0cf6","/computer/ds/complexity.html",{"e":"<h1> 2.算法复杂度问题</h1>\n<h2> 时间复杂度</h2>\n<p>这里主要总结数据结构中时间复杂度的计算方法，在学习过程中，参考了B站的<a href=\"https://www.bilibili.com/video/BV13d4y1K74p/\" target=\"_blank\" rel=\"noopener noreferrer\">数据结构——时间复杂度计算</a>这个视频，可以在看完视频后，再阅读本文，效果更佳。</p>\n<p>根据循环的层次不同，分为三个类别：</p>\n<ol>\n<li>单层循环</li>\n<li>两层循环</li>\n<li>多层循环</li>\n</ol>\n<p>这里一一进行说明。</p>","y":"a","t":"2.算法复杂度问题","O":2},[":md"]],
  ["v-01ac142e","/computer/ds/data-structure-concept.html",{"e":"<h1> 1.数据结构的基本概念</h1>\n<h2> 基本概念</h2>\n<ul>\n<li>\n<p><strong>数据</strong>：数据是信息的载体，是描述客观事物属性的数、字符及所能输入到计算机中并能被计算机程序识别和处理的符号的集合。</p>\n</li>\n<li>\n<p><strong>数据元素</strong>：是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。如类实例化的一个对象就是数据元素，不可分割。</p>\n</li>\n<li>\n<p><strong>数据对象</strong>：数据对象是具有相同性质的数据元素的集合，是数据的一个子集。即同属于一个类的对象实例。</p>\n</li>\n<li>\n<p><strong>数据类型</strong>：数据类型是一个值的集合和定义在此集合上的一组操作的总称。</p>\n<ol>\n<li>原子类型：其值不可再分的数据类型。————基本数据类型。</li>\n<li>结构类型：其值可以在分解为若干变量的数据类型。————对象实例内的各个属性值。</li>\n<li>抽象数据类型：抽象数据组织及与之相关的操作。————仅仅定义，没有实现。如栈、队列的定义。</li>\n</ol>\n</li>\n<li>\n<p><strong>数据结构</strong>：是相互之间存在的一种或多种特定关系的数据元素的集合。在任何时候，数据都不是独立存在的，他们存在着某种关系。</p>\n</li>\n</ul>","y":"a","t":"1.数据结构的基本概念","O":1},[":md"]],
  ["v-fd067b50","/computer/ds/linear-list.html",{"e":"<h1> 3.线性表</h1>\n<h2> 线性表定义和操作</h2>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">线性表</p>\n<p>线性表是具有相同数据类型的n个数据元素的有限集序列，其中n为表长，当n=0时线性表是一个空表。若用L命名线性表，其一般表示为：L = ( a<sub>1</sub> ,a<sub>2</sub> ,...,a<sub>i</sub> ,a<sub>i+1</sub> ,...,a<sub>n</sub> )</p>\n</div>\n<p><strong>线性表的基本操作：</strong></p>","y":"a","t":"3.线性表","O":3},[":md"]],
  ["v-9a72bbf6","/computer/ds/",{"e":"<h1> 数据结构</h1>\n","y":"a","t":"数据结构","O":1},["/computer/ds/readme.md"]],
  ["v-9a726960","/computer/os/",{"e":"<h1> 计算机操作系统</h1>\n","y":"a","t":"计算机操作系统","O":3},["/computer/os/readme.md"]],
  ["v-2ea65610","/spring-series/spring/annotations-beans.html",{"e":"<h1> Spring - 基于注解管理Bean</h1>\n<p>从 Java 5 开始，Java 增加了对注解（Annotation）的支持，它是代码中的一种特殊标记，可以在编译、类加载和运行时被读取，执行相应的处理。开发人员可以通过注解在不改变原有代码和逻辑的情况下，在源代码中嵌入补充信息。</p>\n<p>Spring 从 2.5 版本开始提供了对注解技术的全面支持，我们可以使用注解来实现自动装配，简化 Spring 的 XML 配置。</p>\n<p>Spring 通过注解实现自动装配的步骤如下：</p>\n<ol>\n<li>引入依赖</li>\n<li>开启组件扫描</li>\n<li>使用注解定义 Bean</li>\n<li>依赖注入</li>\n</ol>","y":"a","t":"Spring - 基于注解管理Bean","O":5},[":md"]],
  ["v-1e38e0b7","/spring-series/spring/implement-ioc.html",{"e":"<h1> Spring - 原理手写IoC</h1>\n<p>Spring 框架的 IOC 是基于 Java 反射机制实现的，在学习手写 IoC 之前，你需要具备一定的 Java 反射相关的知识，参考本站内的 Java 教程。</p>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">Java教程</p>\n<p>//TODO: 待更新</p>\n</div>\n<p>IoC（控制反转）和DI（依赖注入）是Spring里面核心的东西，本章节我们就来自己实现 Spring 框架中的 IoC 和 DI。</p>\n<h2> 创建子模块</h2>","y":"a","t":"Spring - 原理手写IoC","O":6},[":md"]],
  ["v-7fc2ecf2","/spring-series/spring/introduction-case.html",{"e":"<h1> Spring - 入门案例</h1>\n<ol>\n<li>\n<p>创建 Maven 工程</p>\n</li>\n<li>\n<p>引入 Spring 相关的依赖</p>\n</li>\n</ol>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><pre class=\"language-xml\"><code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependencies</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token comment\">&lt;!--spring context依赖--&gt;</span>\n    <span class=\"token comment\">&lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>org.springframework<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>spring-context<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">&gt;</span></span>6.0.9<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n\n    <span class=\"token comment\">&lt;!--junit5测试--&gt;</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>org.junit.jupiter<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>junit-jupiter-api<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">&gt;</span></span>5.3.1<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependencies</span><span class=\"token punctuation\">&gt;</span></span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"Spring - 入门案例","O":2},[":md"]],
  ["v-4d4cd2de","/spring-series/spring/",{"e":"<h1> Spring</h1>\n<figure><figcaption>Spring</figcaption></figure>\n<h2> 参考资料</h2>\n<ul>\n<li>代码仓库：</li>\n</ul>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">Github</p>\n<p><a href=\"https://github.com/CoderMast/Spring6\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/CoderMast/Spring6</a></p>\n</div>","y":"a","t":"Spring"},["/spring-series/spring/readme.md"]],
  ["v-53cb8d26","/spring-series/spring/spring-aop.html",{"e":"<h1> Spring - 面向切面AOP</h1>\n<h2> 场景模拟</h2>\n<p>还是老规矩，为了避免和之前的项目冲突，我们这里创建一个新的子模块 <code>spring6-aop</code></p>\n<ul>\n<li>声明计算器接口 Calculator</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Calculator</span> <span class=\"token punctuation\">{</span>\n    \n    <span class=\"token keyword\">int</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">int</span> <span class=\"token function\">sub</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">int</span> <span class=\"token function\">mul</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">int</span> <span class=\"token function\">div</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n<span class=\"token punctuation\">}</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"Spring - 面向切面AOP","O":7},[":md"]],
  ["v-5a9eefa2","/spring-series/spring/spring-aot.html",{"e":"<h1> Spring - AOT提前编译</h1>\n<h2> AOT概述</h2>\n<h3> JIT与AOT的区别</h3>\n<p>JIT和AOT 这个名词是指两种不同的编译方式，这两种编译方式的主要区别在于是否在“运行时”进行编译</p>\n<p><strong>（1）JIT， Just-in-time,动态(即时)编译，边运行边编译；</strong></p>\n<p>在程序运行时，根据算法计算出热点代码，然后进行 JIT 实时编译，这种方式吞吐量高，有运行时性能加成，可以跑得更快，并可以做到动态生成代码等，但是相对启动速度较慢，并需要一定时间和调用频率才能触发 JIT 的分层机制。JIT 缺点就是编译需要占用运行时资源，会导致进程卡顿。</p>","y":"a","t":"Spring - AOT提前编译","O":13},[":md"]],
  ["v-b9412328","/spring-series/spring/spring-data-validation.html",{"e":"<h1> Spring - 数据校验</h1>\n<p>在开发中，我们经常遇到参数校验的需求，比如用户注册的时候，要校验用户名不能为空、用户名长度不超过20个字符、手机号是合法的手机号格式等等。如果使用普通方式，我们会把校验的代码和真正的业务处理逻辑耦合在一起，而且如果未来要新增一种校验逻辑也需要在修改多个地方。而spring validation允许通过注解的方式来定义对象校验规则，把校验和业务逻辑分离开，让代码编写更加方便。Spring Validation其实就是对Hibernate Validator进一步的封装，方便在Spring中使用。</p>\n<p>在Spring中有多种校验的方式</p>","y":"a","t":"Spring - 数据校验","O":12},[":md"]],
  ["v-76e3364c","/spring-series/spring/spring-i18n.html",{"e":"<h1> Spring - 国际化i18n</h1>\n<h2> i18n概述</h2>\n<p>国际化也称作i18n，其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数。由于软件发行可能面向多个国家，对于不同国家的用户，软件显示不同语言的过程就是国际化。通常来讲，软件中的国际化是通过配置文件来实现的，假设要支撑两种语言，那么就需要两个版本的配置文件。</p>\n<h2> Java国际化</h2>\n<p>（1）Java自身是支持国际化的，java.util.Locale用于指定当前用户所属的语言环境等信息，java.util.ResourceBundle用于查找绑定对应的资源文件。Locale包含了language信息和country信息，Locale创建默认locale对象时使用的静态方法：</p>","y":"a","t":"Spring - 国际化i18n","O":11},[":md"]],
  ["v-7ca5f40b","/spring-series/spring/spring-ioc.html",{"e":"<h1> Spring - IOC容器</h1>\n<p>IoC 是 Inversion of Control 的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。</p>\n<p>Spring 通过 IoC 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系。</p>\n<p>我们将由 IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别。</p>\n<p>IoC 容器是 Spring 框架中最重要的核心组件之一，它贯穿了 Spring 从诞生到成长的整个过程。</p>","y":"a","t":"Spring - IOC容器","O":3},[":md"]],
  ["v-11375dfa","/spring-series/spring/spring-junit.html",{"e":"<h1> Spring - 单元测试JUnit</h1>\n<p>在之前的测试方法中，几乎都能看到以下的两行代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><pre class=\"language-java\"><code><span class=\"token class-name\">ApplicationContext</span> context <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassPathXmlApplicationContext</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"xxx.xml\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Xxxx</span> xxx <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Xxxx</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"Spring - 单元测试JUnit","O":8},[":md"]],
  ["v-5da3c0ba","/spring-series/spring/spring-resources.html",{"e":"<h1> Spring - 资源操作</h1>\n<h2> Resources概述</h2>\n<p>Java的标准java.net.URL类和各种URL前缀的标准处理程序无法满足所有对low-level资源的访问，比如：没有标准化的 URL 实现可用于访问需要从类路径或相对于 ServletContext 获取的资源。并且缺少某些Spring所需要的功能，例如检测某资源是否存在等。<strong>而Spring的Resource声明了访问low-level资源的能力。</strong></p>\n<h2> Resource接口</h2>\n<p>Spring 的 Resource 接口位于 <a href=\"http://org.springframework.core.io\" target=\"_blank\" rel=\"noopener noreferrer\">org.springframework.core.io</a> 中。 旨在成为一个更强大的接口，用于抽象对低级资源的访问。以下显示了Resource接口定义的方法</p>","y":"a","t":"Spring - 资源操作","O":10},[":md"]],
  ["v-485b73f2","/spring-series/spring/spring-summarize.html",{"e":"<h1> Spring - Spring概述</h1>\n<figure><figcaption></figcaption></figure>\n<h2> Spring 是什么？</h2>\n<p>Spring 是一款主流的 Java EE 轻量级开源框架 ，Spring 由“Spring 之父”Rod Johnson 提出并创立，其目的是用于简化 Java 企业级应用的开发难度和开发周期。Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring 框架除了自己提供功能外，还提供整合其他技术和框架的能力。</p>\n<p>Spring 自诞生以来备受青睐，一直被广大开发人员作为 Java 企业级应用程序开发的首选。时至今日，Spring 俨然成为了 Java EE 代名词，成为了构建 Java EE 应用的事实标准。</p>","y":"a","t":"Spring - Spring概述","O":1},[":md"]],
  ["v-366a426c","/spring-series/spring/spring-transaction.html",{"e":"<h1> Spring - 事务</h1>\n<h2> JdbcTemplate</h2>\n<p>Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作</p>\n<h3> 准备工作</h3>\n<p><strong>①搭建子模块</strong></p>\n<p>搭建子模块：spring6-transaction</p>\n<p><strong>②加入依赖</strong></p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><pre class=\"language-xml\"><code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependencies</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token comment\">&lt;!--spring jdbc  Spring 持久化层支持jar包--&gt;</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>org.springframework<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>spring-jdbc<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">&gt;</span></span>6.0.2<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token comment\">&lt;!-- MySQL驱动 --&gt;</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>mysql<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>mysql-connector-java<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">&gt;</span></span>8.0.33<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token comment\">&lt;!-- 数据源 --&gt;</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>com.alibaba<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>druid<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">&gt;</span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">&gt;</span></span>1.2.15<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">&gt;</span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">&gt;</span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependencies</span><span class=\"token punctuation\">&gt;</span></span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"Spring - 事务","O":9},[":md"]],
  ["v-395adc3d","/spring-series/spring/xml-beans.html",{"e":"<h1> Spring - 基于XML管理Bean</h1>\n<h2> 创建子模块</h2>\n<p>在使用 XML 管理 Bean 之前，为了防止和之前的项目冲突，我们重新创建一个子模块，叫做 spring6-ioc-xml ，并且引入 beans.xml 文件即可。</p>\n<h2> 获取bean</h2>\n<p>在通过 xml 方式获取 bean 之前，我们需要先导入对应的配置文件，这里我们是 beans.xml。构建 ApplicationContext 容器。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><pre class=\"language-java\"><code><span class=\"token comment\">// 导入 bean 的 xml 配置文件</span>\n<span class=\"token class-name\">ApplicationContext</span> context <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassPathXmlApplicationContext</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"beans.xml\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"Spring - 基于XML管理Bean","O":4},[":md"]],
  ["v-5cc68e42","/spring-series/springboot/",{"e":"<h1> SpringBoot</h1>\n<h2> 章节分布</h2>\n<ol>\n<li>\n<p>SpringBoot3 核心特性</p>\n</li>\n<li>\n<p>SpringBoot3 场景实战</p>\n</li>\n<li>\n<p>响应式编程全套</p>\n</li>\n</ol>\n<h2> 参考资料</h2>\n<ul>\n<li>视频资料 : <a href=\"https://www.bilibili.com/video/BV1Es4y1q7Bf/\" target=\"_blank\" rel=\"noopener noreferrer\">尚硅谷SpringBoot3零基础教程，springboot入门到实战</a></li>\n<li>笔记资料 : <a href=\"https://www.yuque.com/leifengyang/springboot3/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.yuque.com/leifengyang/springboot3/</a></li>\n<li>代码仓库 : <a href=\"https://gitee.com/leifengyang/spring-boot-3/\" target=\"_blank\" rel=\"noopener noreferrer\">https://gitee.com/leifengyang/spring-boot-3/</a></li>\n</ul>","y":"a","t":"SpringBoot"},["/spring-series/springboot/readme.md"]],
  ["v-594b2522","/tools/stata/",{"e":"<h1> Stata 分析工具</h1>\n","y":"a","t":"Stata 分析工具"},["/tools/stata/readme.md"]],
  ["v-5e01a32b","/tools/stata/stata-commom-instruct.html",{"e":"<h1> Stata 常见指令</h1>\n<h2> 1.输入数据</h2>\n<div class=\"language-stata line-numbers-mode\" data-ext=\"stata\"><pre class=\"language-stata\"><code><span class=\"token command keyword\">input</span> x y\n...\n...\n...\n<span class=\"token command keyword\">end</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"Stata 常见指令","I":0},[":md"]],
  ["v-4bbcf4f8","/computer/cn/application-layer/",{"e":"<h1> 第六章 应用层</h1>\n","y":"a","t":"第六章 应用层","O":6},["/computer/cn/application-layer/Readme.md"]],
  ["v-6f3dd303","/computer/cn/cn-architecture/",{"e":"<h1> 第一章 计算机网络体系结构</h1>\n","y":"a","t":"第一章 计算机网络体系结构","O":1},["/computer/cn/cn-architecture/Readme.md"]],
  ["v-77d179d8","/computer/cn/cn-architecture/cn-classification.html",{"e":"<h1> 2 计算机网络的分类</h1>\n<h2> 2.1 按分布范围分类</h2>\n<ol>\n<li>广域网（WAN）<br>\n广域网的任务时容果</li>\n<li>城域网（MAN）</li>\n<li>局域网（LAN）</li>\n<li>个人区域网（PAN）</li>\n</ol>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意</p>\n<p>若中央处理器之间的距离非常近（如仅1m的数量级或甚至更小），则一般称为多处理器系统，而不称为计算机网络。</p>\n</div>\n<h2> 2.2 按传输技术分类</h2>","y":"a","t":"2 计算机网络的分类","O":2},[":md"]],
  ["v-33201e36","/computer/cn/cn-architecture/cn-notion-composition-function.html",{"e":"<h1> 1 计算机网络的概念、组成和功能</h1>\n<h2> 1.1 计算机网络的概念</h2>\n<p>一般认为，计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。</p>\n<h3> 1.1.1 广义观点</h3>\n<p>只要是能实现远程信息处理的系统或者能进一步达到资源共享的系统，都是计算机网络。</p>\n<h3> 1.1.2 资源共享观点</h3>\n<p>计算机网络是“以能够相互共享资源的方式互联起来的自治计算机系统的集合”。</p>\n<pre><code>1. 目的——资源共享\n2. 组成单元——分布在不同地理位置的多台独立的“自治计算机”\n3. 网络中的计算机必须遵循的统一规则——网络协议\n</code></pre>","y":"a","t":"1 计算机网络的概念、组成和功能","O":1},[":md"]],
  ["v-3d008037","/computer/cn/data-link-layer/",{"e":"<h1> 第三章 数据链路层</h1>\n","y":"a","t":"第三章 数据链路层","O":3},["/computer/cn/data-link-layer/Readme.md"]],
  ["v-27d387b4","/computer/cn/netwark-layer/",{"e":"<h1> 第四章 网络层</h1>\n","y":"a","t":"第四章 网络层","O":4},["/computer/cn/netwark-layer/Readme.md"]],
  ["v-41c16c2a","/computer/cn/physical-layer/",{"e":"<h1> 第二章 物理层</h1>\n","y":"a","t":"第二章 物理层","O":2},["/computer/cn/physical-layer/Readme.md"]],
  ["v-d90a0794","/computer/cn/transaction-layer/",{"e":"<h1> 第五章 传输层</h1>\n","y":"a","t":"第五章 传输层","O":5},["/computer/cn/transaction-layer/Readme.md"]],
  ["v-3706649a","/404.html",{"y":"p","t":""},[]],
  ["v-a94a8cca","/computer/",{"y":"p","t":"Computer"},[]],
  ["v-5bc93818","/category/",{"y":"p","t":"分类","I":0},[]],
  ["v-744d024e","/tag/",{"y":"p","t":"标签","I":0},[]],
  ["v-e52c881c","/article/",{"y":"p","t":"文章","I":0},[]],
  ["v-154dc4c4","/star/",{"y":"p","t":"收藏","I":0},[]],
  ["v-01560935","/timeline/",{"y":"p","t":"时间轴","I":0},[]],
]
