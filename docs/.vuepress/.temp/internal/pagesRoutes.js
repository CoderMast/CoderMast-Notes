export const pagesRoutes = [
  ["v-8daa1a0e","/",{"y":"h","t":"首页","i":"home"},["/index.html","/readme.md"]],
  ["v-70bc2959","/algorithm/",{"e":"<h1> 算法题解</h1>\n","y":"a","t":"算法题解","I":0},["/algorithm/index.html","/algorithm/Readme.md"]],
  ["v-2e25198a","/database/",{"e":"<h1> 数据库</h1>\n","y":"a","t":"数据库","I":0},["/database/index.html","/database/readme.md"]],
  ["v-368130d4","/java/java-base-basic-grammar.html",{"e":"<h1> Java基础 - 基本语法</h1>\n","y":"a","t":"Java基础 - 基本语法"},["/java/java-base-basic-grammar","/java/java-base-basic-grammar.md"]],
  ["v-f0d53e30","/java/java-base-final.html",{"e":"<h1> Final关键字的用法及加载时机</h1>\n<h2> 修饰变量</h2>\n<p>final关键字修饰变量表示该变量一经初始化，则无法被修改。</p>\n<ul>\n<li>基本类型和String类型：这类一般都是通过字面量进行赋值，一经初始化无法改变。</li>\n<li>其他引用类型：这种类型我们无法改变常量指向的引用，但是仍然可以改变引用指向的对象，即引用指向的地址。</li>\n</ul>\n<h3> 静态常量和对象常量</h3>\n<p>这里根据是否被static修饰可以将常量分为两类：</p>\n<ol>\n<li><strong>被final和static关键字同时修饰的变量</strong></li>\n</ol>","y":"a","t":"Final关键字的用法及加载时机"},["/java/java-base-final","/java/java-base-final.md"]],
  ["v-2b1dc14e","/java/java-base-oop.html",{"e":"<h1> Java基础 - 面向对象</h1>\n","y":"a","t":"Java基础 - 面向对象"},["/java/java-base-oop","/java/java-base-oop.md"]],
  ["v-609fd806","/java/java-base-static.html",{"e":"<h1> Static关键字的五种用法详解</h1>\n<p>Static的五种用法大致如下：</p>\n<ul>\n<li>修饰成员变量，使其成为类变量，也叫静态变量</li>\n<li>修饰成员方法，使其成为类方法</li>\n<li>修饰内部类，使其成为静态内部类</li>\n<li>静态代码块</li>\n<li>静态导包</li>\n</ul>\n<blockquote>\n<p>直接一点将，static关键字就是把属性和方法变为类相关，而不是实例相关。</p>\n</blockquote>\n<h2> 修饰成员变量</h2>\n<p>被static关键字修饰的属性叫做静态属性，也叫类属性。顾名思义现在该属性为该类所有，而非该类实例化的对象所有，在类的加载阶段进行初始化。虽然使用类实例化的对象也能够调用该属性，但是该属性是属于类所有，所有该类的实例化对象和该类共享一个值，即操作的是同一个值。</p>","y":"a","t":"Static关键字的五种用法详解"},["/java/java-base-static","/java/java-base-static.md"]],
  ["v-14c69af4","/java/",{"e":"<h1> Java</h1>\n","y":"a","t":"Java","I":0},["/java/index.html","/java/readme.md"]],
  ["v-884a0bbc","/problems/",{"e":"<h1> 题解</h1>\n","y":"a","t":"题解","I":0},["/problems/index.html","/problems/Readme.md"]],
  ["v-d440f426","/tools/",{"e":"<h1> 工具使用</h1>\n","y":"a","t":"工具使用","I":0},["/tools/index.html","/tools/readme.md"]],
  ["v-9a72c4ae","/computer/cn/",{"e":"<h1> 计算机网络</h1>\n","y":"a","t":"计算机网络","O":4},["/computer/cn/index.html","/computer/cn/Readme.md"]],
  ["v-1be8c5c4","/computer/cn/cn-tcp-3-4.html",{"e":"<h1> TCP三次握手和四次挥手图文详解</h1>\n<figure><figcaption>tcp连接</figcaption></figure>\n<h2> 什么是TCP连接？</h2>\n<p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议是同一层内另一个重要的传输协议。在因特网协议族中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。</p>\n<h2> 三次握手</h2>\n<p>三次握手是发生在TCP的连接过程中的，具体的步骤如下：</p>","y":"a","t":"TCP三次握手和四次挥手图文详解"},["/computer/cn/cn-tcp-3-4","/computer/cn/cn-tcp-3-4.md"]],
  ["v-9a72c470","/computer/co/",{"e":"<h1> 计算机组成原理</h1>\n","y":"a","t":"计算机组成原理","O":2},["/computer/co/index.html","/computer/co/readme.md"]],
  ["v-9a72bbf6","/computer/ds/",{"e":"<h1> 数据结构</h1>\n","y":"a","t":"数据结构","O":1},["/computer/ds/index.html","/computer/ds/readme.md"]],
  ["v-9a726960","/computer/os/",{"e":"<h1> 计算机操作系统</h1>\n","y":"a","t":"计算机操作系统","O":3},["/computer/os/index.html","/computer/os/readme.md"]],
  ["v-dfa09558","/database/mysql/constraint.html",{"e":"<h1> MySQL基础 - 约束</h1>\n<h2> 概念</h2>\n<p>约束是作用于表中字段上的规则，用于限制存储在表中的数据。</p>\n<h2> 目的</h2>\n<p>为了保证数据库中数据的正确、有效性和完整性。</p>\n<h2> 分类</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">约束</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">关键字</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">非空约束</td>\n<td style=\"text-align:center\">限制该字段的数据不能为null</td>\n<td style=\"text-align:center\">NOT NULL</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">唯一约束</td>\n<td style=\"text-align:center\">保证该字段的所有数据都是唯一，不重复的</td>\n<td style=\"text-align:center\">UNIQUE</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">主键约束</td>\n<td style=\"text-align:center\">主键是一行数据的唯一标识，要求非空且唯一</td>\n<td style=\"text-align:center\">PRIMARY KEY</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">默认约束</td>\n<td style=\"text-align:center\">保存数据时，如果未指定该字段的值，则赋予该默认值</td>\n<td style=\"text-align:center\">DEFULT</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">条件约束</td>\n<td style=\"text-align:center\">保证字段值满足指定的条件</td>\n<td style=\"text-align:center\">CHECK</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">外键约束</td>\n<td style=\"text-align:center\">用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td>\n<td style=\"text-align:center\">FOREIGN KEY</td>\n</tr>\n</tbody>\n</table>","y":"a","t":"MySQL基础 - 约束","O":4},["/database/mysql/constraint","/database/mysql/constraint.md"]],
  ["v-6c2bb6d0","/database/mysql/dividing-databases-tables.html",{"e":"<h1> MySQL运维 - 分库分表</h1>\n","y":"a","t":"MySQL运维 - 分库分表","O":35},["/database/mysql/dividing-databases-tables","/database/mysql/dividing-databases-tables.md"]],
  ["v-0ca649bb","/database/mysql/function-base.html",{"e":"<h1> MySQL基础 - 函数</h1>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">函数</p>\n<p>函数是一段可以直接被另一段程序调用的程序或者代码。</p>\n</div>\n<h2> 字符串函数</h2>\n<p>MySQL中内置了很多的字符串函数，常用的几个如下所示:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">CONCAT(S1,S2,...,Sn)</td>\n<td style=\"text-align:center\">字符串拼接，将S1、S2、...、Sn按照顺序拼接成一个字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LOWER(str)</td>\n<td style=\"text-align:center\">将字符串str全部转成小写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">UPPER(str)</td>\n<td style=\"text-align:center\">将字符串str全部转成大写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LPAD(str,n,pad)</td>\n<td style=\"text-align:center\">左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RPAD(str,n,pad)</td>\n<td style=\"text-align:center\">右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">TRIM(str)</td>\n<td style=\"text-align:center\">去掉字符串头部和尾部的空格</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SUBSTRING(str,start,len)</td>\n<td style=\"text-align:center\">返回字符串str从start位置开始的len个长度的字符串</td>\n</tr>\n</tbody>\n</table>","y":"a","t":"MySQL基础 - 函数","O":3},["/database/mysql/function-base","/database/mysql/function-base.md"]],
  ["v-b9856e14","/database/mysql/innodb-engine.html",{"e":"<h1> MySQL进阶 - InnoDB存储引擎</h1>\n<h2> 逻辑存储结构</h2>\n<p>\nInnoDB引擎的存储结构主要包含5个部分：</p>\n<ol>\n<li>表空间Tablespace</li>\n</ol>\n<p>主要是MySQL中的ibd文件，一个MySQL实例可以对应多个表空间，用于存储记录、索引等数据。表空间用来管理多个Segment段。</p>\n<ol start=\"2\">\n<li>段Segment</li>\n</ol>\n<p>段分为数据段(Leaf node segment)、索引段(Non-leaf node segment)、回滚段(Rollback segment)，InnoDB是索引组织表，数据段就是B+树的叶子结点，索引段即为B+树的非叶子结点。段用来管理多个Extent区。</p>","y":"a","t":"MySQL进阶 - InnoDB存储引擎","O":19},["/database/mysql/innodb-engine","/database/mysql/innodb-engine.md"]],
  ["v-b1f4f0e2","/database/mysql/innodb-mvcc.html",{"e":"<h1> MySQL进阶 - MVCC多版本并发控制</h1>\n<h2> 概念介绍</h2>\n<h3> MVCC</h3>\n<p>MVCC全称为Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐藏字段、undo log 日志、readView。</p>\n<h3> 当前读</h3>\n<p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：\nselect ... lock in share mode （共享锁），select ... for update 、insert、delete（排他锁）都是一种当前读。</p>","y":"a","t":"MySQL进阶 - MVCC多版本并发控制","O":20},["/database/mysql/innodb-mvcc","/database/mysql/innodb-mvcc.md"]],
  ["v-8965f874","/database/mysql/master-slave-replication.html",{"e":"<h1> MySQL运维 - 主从复制</h1>\n","y":"a","t":"MySQL运维 - 主从复制","O":38},["/database/mysql/master-slave-replication","/database/mysql/master-slave-replication.md"]],
  ["v-49034968","/database/mysql/multi-table-query.html",{"e":"<h1> MySQL基础 - 多表查询</h1>\n<h2> 多表关系</h2>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<p>在正式学习数据库的多表查询之前，我们需要了解到需要多表查询的场景，以及有哪些多表查询的情况，也就是数据表之间的关系。</p>\n</div>\n<h3> 一对一</h3>\n<p>一对一关系是我们比较常见的关系，比如数据表A中的一条值对应数据表B中的一条值，这种情况经常用于多表的拆分。例如将最常用的字段抽取出来，使得提高查询的效率。</p>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">实现</p>\n<p>在任意一方加入外键，关联另外一方的主键，并且设置唯一约束(UNIQUE)。</p>\n</div>","y":"a","t":"MySQL基础 - 多表查询","O":5},["/database/mysql/multi-table-query","/database/mysql/multi-table-query.md"]],
  ["v-43c7fd75","/database/mysql/mysql-base.html",{"e":"<h1> MySQL基础 - 基础概念</h1>\n<h2> 基本概念</h2>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">区别</p>\n<p>在学习MySQL之前，我们需要明确一些基本概念，以便于后续的理解和学习。</p>\n</div>\n<ul>\n<li>数据库</li>\n</ul>\n<p>数据库是存储数据的仓库，数据是有组织的进行存储。简写为DataBase （DB）</p>\n<ul>\n<li>数据库管理系统</li>\n</ul>\n<p>操纵和管理数据库的大型软件系统。简写为DataBase Management System （DBMS）</p>","y":"a","t":"MySQL基础 - 基础概念","O":1},["/database/mysql/mysql-base","/database/mysql/mysql-base.md"]],
  ["v-60dc87cc","/database/mysql/mysql-index.html",{"e":"<h1> MySQL进阶 - 索引</h1>\n<h2> 索引概述</h2>\n<h3> 概念</h3>\n<p>索引是帮助MySQL的<code>数据结构</code>（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式饮用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p>\n<h3> 优缺点</h3>\n<ul>\n<li>优点</li>\n</ul>\n<ol>\n<li>提高数据检索的效率，降低数据库的IO成本</li>\n<li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li>\n</ol>\n<ul>\n<li>缺点</li>\n</ul>","y":"a","t":"MySQL进阶 - 索引","O":13},["/database/mysql/mysql-index","/database/mysql/mysql-index.md"]],
  ["v-789e275b","/database/mysql/mysql-lock.html",{"e":"<h1> MySQL进阶 - 锁</h1>\n<h2> 介绍</h2>\n<p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除了传统的计算机资源(CPU、RAM、I/O)的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>\n<h2> 全局锁</h2>\n<h3> 介绍</h3>\n<p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p>","y":"a","t":"MySQL进阶 - 锁","O":19},["/database/mysql/mysql-lock","/database/mysql/mysql-lock.md"]],
  ["v-43a7dcb0","/database/mysql/mysql-log.html",{"e":"<h1> MySQL运维 - 日志</h1>\n","y":"a","t":"MySQL运维 - 日志","O":36},["/database/mysql/mysql-log","/database/mysql/mysql-log.md"]],
  ["v-10ff6421","/database/mysql/mysql-manage.html",{"e":"<h1> MySQL进阶 - MySQL管理</h1>\n","y":"a","t":"MySQL进阶 - MySQL管理","O":23},["/database/mysql/mysql-manage","/database/mysql/mysql-manage.md"]],
  ["v-4cf6c634","/database/mysql/mysql-trigger.html",{"e":"<h1> MySQL进阶 - 触发器</h1>\n<h2> 介绍</h2>\n<p>触发器是于表有关的数据库对象，指在insert、update、delete之前或者之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以与协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</p>\n<p>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p>\n<div class=\"hint-container note\">\n<p class=\"hint-container-title\">举例</p>\n<p>语句级触发：执行一次SQL，触发器会触发一次，无论影响多少行。\n行级触发：如一个SQL语句更新了3行数据，则触发器会触发三次。</p>\n</div>","y":"a","t":"MySQL进阶 - 触发器","O":18},["/database/mysql/mysql-trigger","/database/mysql/mysql-trigger.md"]],
  ["v-524a0e21","/database/mysql/mysql-view.html",{"e":"<h1> MySQL进阶 - 视图</h1>\n<h2> 介绍和基本语法</h2>\n<h3> 介绍</h3>\n<p>视图View是一种虚拟存在的表，视图中的数据并不在数据库中实际存在，行和列数据来自定义视图中使用的表，并且是在使用视图时动态生成的。</p>\n<p>简单的来说，视图不保存数据，只是保存了查询的SQL逻辑，不保存查询的结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">简单理解</p>\n<p>可以理解为给SQL语句设置别名，我们在使用的时候可以直接使用别名进行子查询、联合查询等操作。</p>\n</div>","y":"a","t":"MySQL进阶 - 视图","O":16},["/database/mysql/mysql-view","/database/mysql/mysql-view.md"]],
  ["v-78afab36","/database/mysql/read-write-separation.html",{"e":"<h1> MySQL运维 - 读写分离</h1>\n","y":"a","t":"MySQL运维 - 读写分离","O":37},["/database/mysql/read-write-separation","/database/mysql/read-write-separation.md"]],
  ["v-21ba2ec8","/database/mysql/",{"e":"<h1> MySQL 数据库</h1>\n<h2> 学习目录</h2>\n<ul>\n<li>基础篇\n<ol>\n<li>MySQL基础</li>\n<li>SQL基础语法</li>\n<li>函数</li>\n<li>约束</li>\n<li>多表查询</li>\n<li>事务</li>\n</ol>\n</li>\n<li>进阶篇\n<ol>\n<li>存储引擎</li>\n<li>索引</li>\n<li>SQL优化</li>\n<li>视图</li>\n<li>存储过程</li>\n<li>触发器</li>\n<li>锁</li>\n<li>InnoDB引擎</li>\n<li>MySQL管理</li>\n</ol>\n</li>\n<li>运维篇\n<ol>\n<li>日志</li>\n<li>主从复制</li>\n<li>分库分表</li>\n<li>读写分离</li>\n</ol>\n</li>\n</ul>","y":"a","t":"MySQL 数据库","I":0},["/database/mysql/index.html","/database/mysql/readme.md"]],
  ["v-149399ac","/database/mysql/sql-general-syntax.html",{"e":"<h1> MySQL基础 - SQL基础语法</h1>\n<h2> 通用语法</h2>\n<ol>\n<li>SQL语句可以单行或者多行书写，以分号结尾。</li>\n<li>SQL语句可以使用空格/缩进符来增强语句的可读性。</li>\n<li>MySQL数据库的SQL语言不区分大小写，关键字建议使用大写。</li>\n<li>注释</li>\n</ol>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">注释</p>\n<ul>\n<li>单行注释：-- 注释内容 或者 # 注释内容(MySQL特有的语法)</li>\n<li>多行注释：使用/* 注释内容 */</li>\n</ul>\n</div>","y":"a","t":"MySQL基础 - SQL基础语法","O":2},["/database/mysql/sql-general-syntax","/database/mysql/sql-general-syntax.md"]],
  ["v-e01d4ed6","/database/mysql/sql-optimize.html",{"e":"<h1> MySQL进阶 - SQL优化</h1>\n<h2> insert优化</h2>\n<h3> 批量插入</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> table_name <span class=\"token keyword\">values</span> <span class=\"token punctuation\">(</span>values_list<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>","y":"a","t":"MySQL进阶 - SQL优化","O":15},["/database/mysql/sql-optimize","/database/mysql/sql-optimize.md"]],
  ["v-21422c2d","/database/mysql/sql-perfomance-analysis.html",{"e":"<h1> MySQL进阶 - SQL性能分析</h1>\n<h2> SQL执行频率</h2>\n<p>MySQL客户端连接成功后，通过 SHOW [session | global] status 命令可以查看服务器状态信息。</p>\n<p>通过如下指令，可以查看当前数据库的INSERT、SELECT、UPDATE、DELETE操作的访问频次：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">GLOBAL</span> <span class=\"token keyword\">STATUS</span> <span class=\"token operator\">LIKE</span> <span class=\"token string\">\"Com_______\"</span><span class=\"token punctuation\">;</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>","y":"a","t":"MySQL进阶 - SQL性能分析","O":14},["/database/mysql/sql-perfomance-analysis","/database/mysql/sql-perfomance-analysis.md"]],
  ["v-9f994086","/database/mysql/storage-engine.html",{"e":"<h1> MySQL进阶 - 存储引擎</h1>\n<h2> MySQL的体系结构</h2>\n<figure><figcaption>MySQL的体系结构示意图</figcaption></figure>\n<ul>\n<li>\n<p>连接层\n连接层处于MySQL体系结构中的最上层，是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、以及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>\n</li>\n<li>\n<p>服务层\n服务层处于MySQL体系结构中的第二层，主要完成大多书的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有存储引擎的功能也在这一层实现，如 过程、函数等。</p>\n</li>\n<li>\n<p>引擎层</p>\n</li>\n</ul>","y":"a","t":"MySQL进阶 - 存储引擎","O":22},["/database/mysql/storage-engine","/database/mysql/storage-engine.md"]],
  ["v-79533b1a","/database/mysql/store-procedure.html",{"e":"<h1> MySQL进阶 - 存储过程</h1>\n<h2> 介绍</h2>\n<p>存储过程是事先经过编译并且存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p>\n<p>存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。</p>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">个人理解</p>\n<p>这里我个人理解的是 类似于 编程语言中的函数，将一些语句封装起来，直接进行函数的调用即可。</p>\n</div>","y":"a","t":"MySQL进阶 - 存储过程","O":17},["/database/mysql/store-procedure","/database/mysql/store-procedure.md"]],
  ["v-13f32783","/database/mysql/transaction.html",{"e":"<h1> MySQL基础 - 事务</h1>\n<p>事务是一组操作的集合，他是一个不可分隔的工作单位，事务会把所有的操作作为一个整体一起向系统提交或者撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>\n<h2> 事务操作</h2>\n<ul>\n<li>查看/设置事务提交方式</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><pre class=\"language-sql\"><code><span class=\"token keyword\">SELECT</span> @<span class=\"token variable\">@autocommit</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SET</span> @<span class=\"token variable\">@autocommit</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"MySQL基础 - 事务","O":6},["/database/mysql/transaction","/database/mysql/transaction.md"]],
  ["v-199a53b3","/database/redis/base-commind.html",{"e":"<h1> Redis入门 - 基础通用指令</h1>\n<p>在正式介绍Redis数据结构及其操作指令之前，我们需要先掌握一些最基础的通用指令。</p>\n<p>这些都是Redis操作过程中的一些常见指令</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">指令</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">keys</td>\n<td style=\"text-align:center\">查看符合模板的所有key，不建议在⽣产环境设备上使⽤</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">del</td>\n<td style=\"text-align:center\">删除⼀个指定的key</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">esists</td>\n<td style=\"text-align:center\">判断key是否存在</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">expire</td>\n<td style=\"text-align:center\">给⼀个key设置有效期，有效期到期时该key会被⾃动删除</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ttl</td>\n<td style=\"text-align:center\">查看⼀个KEY的剩余有效期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">quit</td>\n<td style=\"text-align:center\">退出</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">shutdown</td>\n<td style=\"text-align:center\">关闭服务器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">select [0-15]</td>\n<td style=\"text-align:center\">选择指定的数据库</td>\n</tr>\n</tbody>\n</table>","y":"a","t":"Redis入门 - 基础通用指令","O":2},["/database/redis/base-commind","/database/redis/base-commind.md"]],
  ["v-350dca32","/database/redis/base-datatype-implement.html",{"e":"<h1> Redis原理 - 五种数据类型的底层结构关系</h1>\n<figure><figcaption></figcaption></figure>\n<h2> 字符串对象String</h2>\n<p>String 是 Redis 中最常见的数据存储类型。</p>\n<ul>\n<li>其基本编码方式是 RAW ，基于简单动态字符串（SDS）实现，存储上限为 512 MB。</li>\n</ul>\n<figure><figcaption></figcaption></figure>\n<ul>\n<li>如果存储的 SDS 长度小于 44 字节，则会采用 <strong>EMBSTR</strong> 编码，此时 object head 与 SDS 是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高。</li>\n</ul>","y":"a","t":"Redis原理 - 五种数据类型的底层结构关系","O":17},["/database/redis/base-datatype-implement","/database/redis/base-datatype-implement.md"]],
  ["v-5d458936","/database/redis/cache-issues.html",{"e":"<h1> Redis进阶 - 缓存问题</h1>\n<h2> 缓存</h2>\n<p>缓存就是数据交换的缓冲区（Cache），是存储数据的临时地方，一般读写性能比较高。</p>\n<ul>\n<li>例如</li>\n</ul>\n<ol>\n<li>内存是硬盘的缓存</li>\n<li>cache 是内存的缓存</li>\n</ol>\n<ul>\n<li>作用</li>\n</ul>\n<ol>\n<li>降低后端负载</li>\n<li>提高读写效率，降低响应时间</li>\n</ol>\n<ul>\n<li>成本</li>\n</ul>\n<ol>\n<li>数据一致性成本</li>\n<li>代码维护成本</li>\n</ol>","y":"a","t":"Redis进阶 - 缓存问题","O":13},["/database/redis/cache-issues","/database/redis/cache-issues.md"]],
  ["v-fd5ee6f6","/database/redis/five-base-datatype.html",{"e":"<h1> Redis入门 - 5种基本数据类型</h1>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">说明</p>\n<p>在我们平常的业务中基本只会使用到Redis的基本数据类型（String、List、Hash、Set、Sorted Set），特殊类型（Geo、Bitmap、Hyperloglog）类型只有在特殊的业务场景下会使用到，通常只需要掌握基本数据类型即可，特殊类型作为了解即可。</p>\n</div>\n<h2> String 字符串</h2>\n<p>String类型，也就是字符串类型，是Redis中最简单的存储类型。String 类型是二进制安全的。意思是 redis 的 String 可以包含任何数据。比如jpg图片或者序列化的对象。</p>","y":"a","t":"Redis入门 - 5种基本数据类型","O":3},["/database/redis/five-base-datatype","/database/redis/five-base-datatype.md"]],
  ["v-2d013d8a","/database/redis/introduce-redis.html",{"e":"<h1> Redis入门 - Redis概念和基础</h1>\n<h2> 什么是NoSQL</h2>\n<ul>\n<li>NoSQL，泛指非关系型的数据库。</li>\n<li>NoSQL最常见的解释是 \"non-relational\"， 很多人也说它是\"Not Only SQL\"</li>\n<li>NoSQL仅仅是一个概念，泛指<strong>非关系型的数据库</strong></li>\n<li>区别于关系数据库，它们不保证关系数据的ACID特性</li>\n<li>NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入</li>\n<li>常见的NoSQL数据库有：<code>Redis</code>、<code>MemCache</code>、<code>MongoDB</code>等</li>\n</ul>","y":"a","t":"Redis入门 - Redis概念和基础","O":1},["/database/redis/introduce-redis","/database/redis/introduce-redis.md"]],
  ["v-886fdb12","/database/redis/jedis-connection-pool.html",{"e":"<h1> Redis客户端 - Jedis连接池</h1>\n<p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们使用Jedis连接池代替Jedis的直接连接方式。</p>\n<ul>\n<li>配置Jedis连接池</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><pre class=\"language-java\"><code><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">JedisConnectionFactory</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">JedisPool</span> jedisPool<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">JedisPoolConfig</span> jedisPollConfig <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JedisPoolConfig</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 最大连接，这里设置为 8</span>\n        jedisPollConfig<span class=\"token punctuation\">.</span><span class=\"token function\">setMaxTotal</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 最大空闲连接，这里设置为 8</span>\n        jedisPollConfig<span class=\"token punctuation\">.</span><span class=\"token function\">setMaxIdle</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 最小空闲连接，这里设置为 0 </span>\n        jedisPollConfig<span class=\"token punctuation\">.</span><span class=\"token function\">setMaxIdle</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 设置最长等待时间，单位 ms</span>\n        jedisPollConfig<span class=\"token punctuation\">.</span><span class=\"token function\">setMaxWaitMillis</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        jedisPool <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JedisPool</span><span class=\"token punctuation\">(</span>jedisPoolConfig<span class=\"token punctuation\">,</span><span class=\"token string\">\"192.168.100.100\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">6379</span><span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"codermast\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 获取Jedis对象</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Jedis</span> <span class=\"token function\">getJedis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> jedisPool<span class=\"token punctuation\">.</span><span class=\"token function\">getResource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"Redis客户端 - Jedis连接池","O":10},["/database/redis/jedis-connection-pool","/database/redis/jedis-connection-pool.md"]],
  ["v-02e8cb00","/database/redis/jedis-quick-start.html",{"e":"<h1> Redis客户端 - Jdies快速入门</h1>\n<h2> 简介</h2>\n<p>Jedis is a Java client for Redis designed for performance and ease of use.</p>\n<p>Jedis是Redis 的 Java 客户端，专为性能和易用性而设计。</p>\n<h2> 官方地址</h2>\n<p>Jedis的官方地址：<a href=\"https://github.com/redis/jedis\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/redis/jedis</a></p>","y":"a","t":"Redis客户端 - Jdies快速入门","O":9},["/database/redis/jedis-quick-start","/database/redis/jedis-quick-start.md"]],
  ["v-2921a50f","/database/redis/",{"e":"<h1> Redis 数据库</h1>\n<figure><figcaption>Redis</figcaption></figure>\n<h2> 参考资料</h2>\n<ul>\n<li>菜鸟教程</li>\n</ul>\n<p>博主在使用Redis数据库时，经常查阅菜鸟教程编写的《Redis教程》系列文档，这里表示感谢。</p>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">文档地址</p>\n<p><a href=\"https://www.runoob.com/redis/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.runoob.com/redis/</a></p>\n</div>","y":"a","t":"Redis 数据库","I":0},["/database/redis/index.html","/database/redis/readme.md"]],
  ["v-8a512f1c","/database/redis/redis-IO.html",{"e":"<h1> Redis原理 - IO详解</h1>\n<h2> 用户空间与内核空间</h2>\n<p>任何Linux 系统的发行版，其系统内核都是 Linux 。我们的应用都需要通过 Linux 内核与硬件交互。</p>\n<figure><figcaption></figcaption></figure>\n<p>为了避免用户应用导致冲突甚至内核崩溃，用户应用与内核是分离的：</p>\n<ul>\n<li>内存的寻址空间划分为两部分：内核空间、用户空间</li>\n</ul>\n<blockquote>\n<p>32 位的操作系统，寻址地址就为 0 ~ <span class=\"katex\"><span class=\"katex-mathml\"></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">32</span></span></span></span></span></span></span></span></span></span></span></span></p>\n</blockquote>","y":"a","t":"Redis原理 - IO详解","O":18},["/database/redis/redis-IO","/database/redis/redis-IO.md"]],
  ["v-5feb02c4","/database/redis/redis-datastruct-underlying-implementation.html",{"e":"<h1> Redis原理 - 数据结构的底层实现</h1>\n<h2> 动态字符串SDS</h2>\n<h3> 基本概念</h3>\n<p>Redis 中保存的 Key 是字符串，Value 往往是字符串或者字符串的集合。可见字符串是 Redis 中最常见的一种数据结构。</p>\n<p>Redis 是使用 C 语言来编写的，C 语言中也有字符串，但是 Redis 中并没有直接使用 C 语言的字符串，这是因为 C 语言中字符串存在着很多的问题：</p>\n<ul>\n<li>获取字符串长度需要进行运算</li>\n<li>非二进制安全，不能包含特殊字符</li>\n</ul>\n<blockquote>\n<p>因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p>\n</blockquote>","y":"a","t":"Redis原理 - 数据结构的底层实现","O":15},["/database/redis/redis-datastruct-underlying-implementation","/database/redis/redis-datastruct-underlying-implementation.md"]],
  ["v-73212c57","/database/redis/redis-netword-model.html",{"e":"<h1> Redis原理 - Redis网络模型</h1>\n<h2> 思考</h2>\n<p><strong>Redis 到底是单线程还是多线程？</strong></p>\n<ul>\n<li>如果仅仅针对 Redis 的核心业务部分（命令处理部分），则是单线程</li>\n<li>如果针对 Redis 整体，那么就是多线程</li>\n</ul>\n<p><strong>在 Redis 的版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</strong></p>\n<ul>\n<li>Redis v4.0：引入多线程异步处理一些耗时较长的任务，例如异步删除命令 unlike</li>\n<li>Redis v6.0：在核心网络模型中引入多线程，进一步提高对多核 CPU 的利用率</li>\n</ul>","y":"a","t":"Redis原理 - Redis网络模型","O":20},["/database/redis/redis-netword-model","/database/redis/redis-netword-model.md"]],
  ["v-ff34c30e","/database/redis/redis-object.html",{"e":"<h1> Redis原理 - RedisObject对象机制</h1>\n<h2> 为什么会设计RedisObject</h2>\n<p>在 Redis 中，我们的操作都是使用指令进行，而这些的命令中，用于对键处理的命令占据一大部分。有些指令只能针对某些特定的类型，而有些指令却能够针对所有的类型。但是要正确实现这些命令，必须为不同类型的键设置不同的处理方式。比如删除一个列表键和删除一个字符串键的操作过程是不一样的，在底层就需要调用不同的视线方式。</p>\n<p>集合类型有字典和整数集合两种不同的底层实现方式，而用户在对集合进行操作时，并不想关心具体的底层实现是什么样的，只要 Redis 能根据自己的指令，完成对应的功能即可，比如对元素进行添加、删除等操作，具体的实现底层对用户来说是透明的，不可见的。</p>","y":"a","t":"Redis原理 - RedisObject对象机制","O":14},["/database/redis/redis-object","/database/redis/redis-object.md"]],
  ["v-cf98b46c","/database/redis/redis-pub-sub.html",{"e":"<h1> Redis入门 - 发布订阅</h1>\n<p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>\n<p>此种模式下，消息发布者和订阅者不进行直接通信，发布者客户端向指定的频道（channel） 发布消息，订阅该频道的每个客户端都可以收到该消息，</p>\n<p>Redis 客户端可以订阅任意数量的频道。</p>\n<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：\n</p>\n<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>","y":"a","t":"Redis入门 - 发布订阅","O":5},["/database/redis/redis-pub-sub","/database/redis/redis-pub-sub.md"]],
  ["v-75d58dbd","/database/redis/redis-scription.html",{"e":"<h1> Redis入门 - Lua脚本</h1>\n<p>Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。</p>\n<h2> 语法</h2>\n<p>Eval 命令的基本语法如下：<code>EVAL script numkeys key [key ...] arg [arg ...]</code></p>\n<h2> 脚本命令</h2>\n<ul>\n<li>执行Lua脚本：<code>EVAL script numkeys key [key ...] arg [arg ...]</code></li>\n<li>将脚本添加到脚本缓存，但不执行：<code>SCRIPT LOAD script</code></li>\n<li>从脚本缓存中移除所有脚本：<code>SCRIPT FLUSH</code></li>\n<li>杀死当前正在运行的 Lua 脚本：<code>SCRIPT KILL</code></li>\n<li>查看指定的脚本是否已经被保存在缓存当中：<code>SCRIPT EXISTS script [script ...]</code></li>\n<li>根据给定的 sha1 校验码，执行缓存在服务器中的脚本：<code>EVALSHA sha1 numkeys key [key ...] arg [arg ...] </code></li>\n</ul>","y":"a","t":"Redis入门 - Lua脚本","O":7},["/database/redis/redis-scription","/database/redis/redis-scription.md"]],
  ["v-2d8772d8","/database/redis/redis-stream.html",{"e":"<h1> Redis入门 - Redis Stream</h1>\n<p>Redis Stream 是 Redis 5.0 版本新增加的数据结构。</p>\n<p>Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</p>\n<p>简单来说发布订阅 (pub/sub) 可以分发消息，但无法记录历史消息。</p>\n<p>而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p>","y":"a","t":"Redis入门 - Redis Stream","O":8},["/database/redis/redis-stream","/database/redis/redis-stream.md"]],
  ["v-6fd862c8","/database/redis/redis-transaction.html",{"e":"<h1> Redis入门 - 事务</h1>\n<p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p>\n<ul>\n<li>批量操作在发送 EXEC 命令前被放入队列缓存。</li>\n<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li>\n<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>\n</ul>\n<p>一个事务从开始到执行会经历以下三个阶段：</p>\n<ul>\n<li>开始事务。</li>\n<li>命令入队。</li>\n<li>执行事务。</li>\n</ul>\n<p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>","y":"a","t":"Redis入门 - 事务","O":6},["/database/redis/redis-transaction","/database/redis/redis-transaction.md"]],
  ["v-a4b2e424","/database/redis/redistemplate-redis-serializer.html",{"e":"<h1> Redis客户端 - RedisSerializer</h1>\n<div class=\"hint-container note\">\n<p class=\"hint-container-title\">前景回顾</p>\n<p>在上一篇中，我们实现了一个简单的案例，操作一个 String 类型的数据，插入了一个 name = codermast 的数据到Redis。</p>\n</div>\n<p>使用redis-cli客户端连接对应的Redis服务器后，按道理来讲<code>get name</code>这个指令的返回结果应该是 <code>codermast</code></p>\n<figure><figcaption>redis-cli客户端查看</figcaption></figure>","y":"a","t":"Redis客户端 - RedisSerializer","O":12},["/database/redis/redistemplate-redis-serializer","/database/redis/redistemplate-redis-serializer.md"]],
  ["v-a746b360","/database/redis/spring-data-redis.html",{"e":"<h1> Redis客户端 - SpringDataRedis</h1>\n<h2> 介绍</h2>\n<p>SpringData 是 Spring 中操作数据的模块，包含对各种数据库的集成，其中对 Redis 的集成模块就叫做 SpringDataRedis，官网地址：<a href=\"https://spring.io/prohects/spring-data-redis\" target=\"_blank\" rel=\"noopener noreferrer\">https://spring.io/prohects/spring-data-redis</a></p>\n<ul>\n<li>提供了对不同 Redis 客户端的整合 （Lettuce 和 Jedis）</li>\n<li>提供了 RedisTemplate 统一 API 来操作Redis</li>\n<li>支持 Redis 的发布订阅模型</li>\n<li>支持 Redis 哨兵和 Redis 集群</li>\n<li>支持基于 Lettuce 的响应式编程</li>\n<li>支持基于 JDK、JSON、字符串、Spring对象的数据序列化和反序列化</li>\n<li>支持基于 Redis 的 JDKCollection 实现</li>\n</ul>","y":"a","t":"Redis客户端 - SpringDataRedis","O":11},["/database/redis/spring-data-redis","/database/redis/spring-data-redis.md"]],
  ["v-7a4ca203","/database/redis/three-special-datatype.html",{"e":"<h1> Redis入门 - 3种特殊数据类型</h1>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">说明</p>\n<p>在我们平常的业务中基本只会使用到Redis的基本数据类型（String、List、Hash、Set、Sorted Set），特殊类型（Geo、Bitmap、Hyperloglog）类型只有在特殊的业务场景下会使用到，通常只需要掌握基本数据类型即可，特殊类型作为了解即可。</p>\n</div>\n<h2> GEO类型</h2>\n<p>GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常⻅操作。</p>","y":"a","t":"Redis入门 - 3种特殊数据类型","O":4},["/database/redis/three-special-datatype","/database/redis/three-special-datatype.md"]],
  ["v-a94b64b0","/problems/leetcode/leetcode15.html",{"e":"<h1> 15.三数之和</h1>\n<h2> 题目描述</h2>\n<p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</p>\n<p>你返回所有和为 0 且不重复的三元组。</p>\n<p>注意：答案中不可以包含重复的三元组。</p>\n<p>示例 1：</p>\n<p>输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]</p>\n<p>解释：\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n示例 2：</p>","y":"a","t":"15.三数之和","O":15},["/problems/leetcode/leetcode15","/problems/leetcode/leetcode15.md"]],
  ["v-ebd584f6","/problems/leetcode/leetcode1646.html",{"e":"<h1> 1646. 获取生成数组中的最大值</h1>\n<h2> 题目介绍</h2>\n<p>给你一个整数 n 。按下述规则生成一个长度为 n + 1 的数组 nums ：</p>\n<p>nums[0] = 0\nnums[1] = 1\n当 2 &lt;= 2 * i &lt;= n 时，nums[2 * i] = nums[i]\n当 2 &lt;= 2 * i + 1 &lt;= n 时，nums[2 * i + 1] = nums[i] + nums[i + 1]\n返回生成数组 nums 中的 最大 值。</p>\n<h2> 题目地址</h2>\n<p><a href=\"https://leetcode-cn.com/problems/get-maximum-in-generated-array/\" target=\"_blank\" rel=\"noopener noreferrer\">1646. 获取生成数组中的最大值</a></p>","y":"a","t":"1646. 获取生成数组中的最大值","O":1646},["/problems/leetcode/leetcode1646","/problems/leetcode/leetcode1646.md"]],
  ["v-004e2d72","/problems/leetcode/leetcode455.html",{"e":"<h1> 455.分发饼干</h1>\n<h2> 题目描述</h2>\n<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>\n<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>\n<p>示例 1:</p>\n<p>输入: g = [1,2,3], s = [1,1]\n输出: 1\n解释:\n你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。\n虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。\n所以你应该输出1。\n示例 2:</p>","y":"a","t":"455.分发饼干","O":455},["/problems/leetcode/leetcode455","/problems/leetcode/leetcode455.md"]],
  ["v-66839488","/problems/leetcode/leetcode509.html",{"e":"<h1> 509. 斐波那契数</h1>\n<h2> 题目描述</h2>\n<p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>\n<p>F(0) = 0，F(1) = 1\nF(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1\n给定 n ，请计算 F(n) 。</p>\n<p>示例 1：</p>\n<p>输入：n = 2\n输出：1\n解释：F(2) = F(1) + F(0) = 1 + 0 = 1</p>\n<p>示例 2：\n输入：n = 3\n输出：2\n解释：F(3) = F(2) + F(1) = 1 + 1 = 2</p>","y":"a","t":"509. 斐波那契数","O":509},["/problems/leetcode/leetcode509","/problems/leetcode/leetcode509.md"]],
  ["v-a28a27e0","/problems/leetcode/leetcode62.html",{"e":"<h1> 62.不同路径</h1>\n<h2> 题目描述</h2>\n<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>\n<p>问总共有多少条不同的路径？</p>\n<p>示例 1：</p>\n<p>输入：m = 3, n = 7\n输出：28\n示例 2：</p>\n<p>输入：m = 3, n = 2\n输出：3\n解释：\n从左上角开始，总共有 3 条路径可以到达右下角。</p>\n<ol>\n<li>向右 -&gt; 向下 -&gt; 向下</li>\n<li>向下 -&gt; 向下 -&gt; 向右</li>\n<li>向下 -&gt; 向右 -&gt; 向下\n示例 3：</li>\n</ol>","y":"a","t":"62.不同路径","O":62},["/problems/leetcode/leetcode62","/problems/leetcode/leetcode62.md"]],
  ["v-71afee22","/problems/leetcode/leetcode6322.html",{"e":"<h1> 6322.检查骑士巡视方案</h1>\n<h2> 题目描述</h2>\n<p>骑士在一张 n x n 的棋盘上巡视。在有效的巡视方案中，骑士会从棋盘的 左上角 出发，并且访问棋盘上的每个格子 恰好一次 。</p>\n<p>给你一个 n x n 的整数矩阵 grid ，由范围 [0, n * n - 1] 内的不同整数组成，其中 grid[row][col] 表示单元格 (row, col) 是骑士访问的第 grid[row][col] 个单元格。骑士的行动是从下标 0 开始的。</p>\n<p>如果 grid 表示了骑士的有效巡视方案，返回 true；否则返回 false。</p>\n<p>注意，骑士行动时可以垂直移动两个格子且水平移动一个格子，或水平移动两个格子且垂直移动一个格子。下图展示了骑士从某个格子出发可能的八种行动路线。</p>","y":"a","t":"6322.检查骑士巡视方案","O":6322},["/problems/leetcode/leetcode6322","/problems/leetcode/leetcode6322.md"]],
  ["v-3f9113da","/problems/leetcode/leetcode70.html",{"e":"<h1> 70. 爬楼梯</h1>\n<h2> 题目描述</h2>\n<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n<p>示例 1：</p>\n<p>输入：n = 2\n输出：2\n解释：有两种方法可以爬到楼顶。</p>\n<ol>\n<li>1 阶 + 1 阶</li>\n<li>2 阶\n示例 2：</li>\n</ol>\n<p>输入：n = 3\n输出：3\n解释：有三种方法可以爬到楼顶。</p>\n<ol>\n<li>1 阶 + 1 阶 + 1 阶</li>\n<li>1 阶 + 2 阶</li>\n<li>2 阶 + 1 阶</li>\n</ol>","y":"a","t":"70. 爬楼梯","O":70},["/problems/leetcode/leetcode70","/problems/leetcode/leetcode70.md"]],
  ["v-04c0516d","/problems/leetcode/leetcode746.html",{"e":"<h1> 746. 使用最小花费爬楼梯</h1>\n<h2> 题目描述</h2>\n<p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>\n<p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p>\n<p>请你计算并返回达到楼梯顶部的最低花费。</p>\n<p>示例 1：</p>\n<p>输入：cost = [10,15,20]\n输出：15\n解释：你将从下标为 1 的台阶开始。</p>\n<ul>\n<li>支付 15 ，向上爬两个台阶，到达楼梯顶部。\n总花费为 15 。\n示例 2：</li>\n</ul>","y":"a","t":"746. 使用最小花费爬楼梯","O":746},["/problems/leetcode/leetcode746","/problems/leetcode/leetcode746.md"]],
  ["v-22c4764c","/problems/leetcode/leetcode88.html",{"e":"<h1> 88.合并两个有序数组</h1>\n<h2> 题目介绍</h2>\n<p>给你两个按 非递减顺序 排列的整数数组&nbsp;nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>\n<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>\n<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>\n<p>示例 1：</p>","y":"a","t":"88.合并两个有序数组","O":88},["/problems/leetcode/leetcode88","/problems/leetcode/leetcode88.md"]],
  ["v-56c36d18","/problems/leetcode/",{"e":"<h1> Leetcode 题解</h1>\n","y":"a","t":"Leetcode 题解","I":0},["/problems/leetcode/index.html","/problems/leetcode/readme.md"]],
  ["v-594b2522","/tools/stata/",{"e":"<h1> Stata 分析工具</h1>\n","y":"a","t":"Stata 分析工具","I":0},["/tools/stata/index.html","/tools/stata/readme.md"]],
  ["v-5e01a32b","/tools/stata/stata-commom-instruct.html",{"e":"<h1> Stata 常见指令</h1>\n<h2> 1.输入数据</h2>\n<div class=\"language-stata line-numbers-mode\" data-ext=\"stata\"><pre class=\"language-stata\"><code><span class=\"token command keyword\">input</span> x y\n...\n...\n...\n<span class=\"token command keyword\">end</span>\n</code></pre><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>","y":"a","t":"Stata 常见指令","I":0},["/tools/stata/stata-commom-instruct","/tools/stata/stata-commom-instruct.md"]],
  ["v-4bbcf4f8","/computer/cn/application-layer/",{"e":"<h1> 第六章 应用层</h1>\n","y":"a","t":"第六章 应用层","O":6},["/computer/cn/application-layer/index.html","/computer/cn/application-layer/Readme.md"]],
  ["v-6f3dd303","/computer/cn/cn-architecture/",{"e":"<h1> 第一章 计算机网络体系结构</h1>\n","y":"a","t":"第一章 计算机网络体系结构","O":1},["/computer/cn/cn-architecture/index.html","/computer/cn/cn-architecture/Readme.md"]],
  ["v-77d179d8","/computer/cn/cn-architecture/cn-classification.html",{"e":"<h1> 2 计算机网络的分类</h1>\n<h2> 2.1 按分布范围分类</h2>\n<ol>\n<li>广域网（WAN）\n广域网的任务时容果</li>\n<li>城域网（MAN）</li>\n<li>局域网（LAN）</li>\n<li>个人区域网（PAN）</li>\n</ol>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意</p>\n<p>若中央处理器之间的距离非常近（如仅1m的数量级或甚至更小），则一般称为多处理器系统，而不称为计算机网络。</p>\n</div>\n<h2> 2.2 按传输技术分类</h2>","y":"a","t":"2 计算机网络的分类","O":2},["/computer/cn/cn-architecture/cn-classification","/computer/cn/cn-architecture/cn-classification.md"]],
  ["v-33201e36","/computer/cn/cn-architecture/cn-notion-composition-function.html",{"e":"<h1> 1 计算机网络的概念、组成和功能</h1>\n<h2> 1.1 计算机网络的概念</h2>\n<p>一般认为，计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。</p>\n<h3> 1.1.1 广义观点</h3>\n<p>只要是能实现远程信息处理的系统或者能进一步达到资源共享的系统，都是计算机网络。</p>\n<h3> 1.1.2 资源共享观点</h3>\n<p>计算机网络是“以能够相互共享资源的方式互联起来的自治计算机系统的集合”。</p>\n<pre><code>1. 目的——资源共享\n2. 组成单元——分布在不同地理位置的多台独立的“自治计算机”\n3. 网络中的计算机必须遵循的统一规则——网络协议\n</code></pre>","y":"a","t":"1 计算机网络的概念、组成和功能","O":1},["/computer/cn/cn-architecture/cn-notion-composition-function","/computer/cn/cn-architecture/cn-notion-composition-function.md"]],
  ["v-3d008037","/computer/cn/data-link-layer/",{"e":"<h1> 第三章 数据链路层</h1>\n","y":"a","t":"第三章 数据链路层","O":3},["/computer/cn/data-link-layer/index.html","/computer/cn/data-link-layer/Readme.md"]],
  ["v-27d387b4","/computer/cn/netwark-layer/",{"e":"<h1> 第四章 网络层</h1>\n","y":"a","t":"第四章 网络层","O":4},["/computer/cn/netwark-layer/index.html","/computer/cn/netwark-layer/Readme.md"]],
  ["v-41c16c2a","/computer/cn/physical-layer/",{"e":"<h1> 第二章 物理层</h1>\n","y":"a","t":"第二章 物理层","O":2},["/computer/cn/physical-layer/index.html","/computer/cn/physical-layer/Readme.md"]],
  ["v-d90a0794","/computer/cn/transaction-layer/",{"e":"<h1> 第五章 传输层</h1>\n","y":"a","t":"第五章 传输层","O":5},["/computer/cn/transaction-layer/index.html","/computer/cn/transaction-layer/Readme.md"]],
  ["v-27c0ebb1","/computer/ds/graph/graph.html",{"e":"<h1> 第六章 图</h1>\n","y":"a","t":"第六章 图","O":6},["/computer/ds/graph/graph","/computer/ds/graph/graph.md"]],
  ["v-767bb2e6","/computer/ds/graph/",{"e":"<h1> 第六章 图</h1>\n","y":"a","t":"第六章 图","O":6},["/computer/ds/graph/index.html","/computer/ds/graph/readme.md"]],
  ["v-62055baa","/computer/ds/introduction/complexity.html",{"e":"<h1> 1.复杂度问题</h1>\n<h2> 时间复杂度</h2>\n<p>这里主要总结数据结构中时间复杂度的计算方法，在学习过程中，参考了B站的<a href=\"https://www.bilibili.com/video/BV13d4y1K74p/\" target=\"_blank\" rel=\"noopener noreferrer\">数据结构——时间复杂度计算</a>这个视频，可以在看完视频后，再阅读本文，效果更佳。</p>\n<p>根据循环的层次不同，分为三个类别：</p>\n<ol>\n<li>单层循环</li>\n<li>两层循环</li>\n<li>多层循环</li>\n</ol>\n<p>这里一一进行说明。</p>","y":"a","t":"1.复杂度问题","O":1},["/computer/ds/introduction/complexity","/computer/ds/introduction/complexity.md"]],
  ["v-5eac3970","/computer/ds/introduction/",{"e":"<h1> 第一章 绪论</h1>\n","y":"a","t":"第一章 绪论","O":1},["/computer/ds/introduction/index.html","/computer/ds/introduction/readme.md"]],
  ["v-b8ba70fe","/computer/ds/linear-list/linear-list.html",{"e":"<h1> 第二章 线性表</h1>\n<h2> 2.1线性表的定义和基本操作</h2>\n<h3> 2.1.1定义</h3>\n<p>线性表是具有相同数据类型的n个数据元素的有限集序列，其中n为表长，当n=0时线性表是一个空表。若用L命名线性表，其一般表示为：L = ( a<sub>1</sub> ,a<sub>2</sub> ,...,a<sub>i</sub> ,a<sub>i+1</sub> ,...,a<sub>n</sub> )</p>\n<h3> 2.1.2基本操作</h3>\n<ul>\n<li><code>InitList(&amp;L)</code>:初始化表，构造一个空的线性表。</li>\n<li><code>Length(L)</code>:求表长，返回线性表L的长度，即L中元素的个数。</li>\n<li><code>LocateElem(L,e)</code>:按值查找操作，在表L中查找具有给定关键字值的元素。</li>\n<li><code>GetElem(L,i)</code>:按位查找操作。获取表L中第i个位置的数据元素的值。</li>\n<li><code>ListInsert(&amp;L,i,e)</code>:插入操作，在表L中的第i个位置上插入指定的元素e.</li>\n<li><code>ListDelete(&amp;L,i,&amp;e)</code>:删除操作，删除表L中的第i个位置的元素，并用e返回删除元素的值。</li>\n<li><code>PrintList(L)</code>:输出操作，按前后顺序输出线性表L的所有元素值。</li>\n<li><code>Empty(L)</code>:判空操作，若L表为空，则返回True，否则返回false。</li>\n<li><code>DestroyList(&amp;L)</code>:销毁操作，销毁线性表，并释放线性表L所占用的内存空间。</li>\n</ul>","y":"a","t":"第二章 线性表","O":2},["/computer/ds/linear-list/linear-list","/computer/ds/linear-list/linear-list.md"]],
  ["v-5186192e","/computer/ds/linear-list/",{"e":"<h1> 第二章 线性表</h1>\n<h2> 2.1线性表的定义和基本操作</h2>\n","y":"a","t":"第二章 线性表","O":2},["/computer/ds/linear-list/index.html","/computer/ds/linear-list/readme.md"]],
  ["v-84d1643c","/computer/ds/search/",{"e":"<h1> 第七章 查找</h1>\n","y":"a","t":"第七章 查找","O":7},["/computer/ds/search/index.html","/computer/ds/search/readme.md"]],
  ["v-768295e2","/computer/ds/search/search.html",{"e":"<h1> 第七章 查找</h1>\n","y":"a","t":"第七章 查找","O":7},["/computer/ds/search/search","/computer/ds/search/search.md"]],
  ["v-cdc0d128","/computer/ds/sort/",{"e":"<h1> 第八章 排序</h1>\n<h2> 8.1排序的基本概念</h2>\n<h2> 8.2插入排序</h2>\n<h2> 8.3交换排序</h2>\n<h2> 8.4选择排序</h2>\n<h2> 8.5归并排序和基数排序</h2>\n<h2> 8.6内部排序的算法比较和应用</h2>\n<h2> 8.7外部排序</h2>\n","y":"a","t":"第八章 排序","O":8},["/computer/ds/sort/index.html","/computer/ds/sort/readme.md"]],
  ["v-d1efbfe2","/computer/ds/sort/sort.html",{"e":"<h1> 第八章 排序</h1>\n<h2> 8.1排序的基本概念</h2>\n<h2> 8.2插入排序</h2>\n<h2> 8.3交换排序</h2>\n<h2> 8.4选择排序</h2>\n<h2> 8.5归并排序和基数排序</h2>\n<h2> 8.6内部排序的算法比较和应用</h2>\n<h2> 8.7外部排序</h2>\n","y":"a","t":"第八章 排序","O":8},["/computer/ds/sort/sort","/computer/ds/sort/sort.md"]],
  ["v-d55a61c8","/computer/ds/stack-queue-array/",{"e":"<h1> 第三章 栈、队列、数组</h1>\n","y":"a","t":"第三章 栈、队列、数组","O":3},["/computer/ds/stack-queue-array/index.html","/computer/ds/stack-queue-array/readme.md"]],
  ["v-d21bf9c6","/computer/ds/stack-queue-array/stack-queue-array.html",{"e":"<h1> 第三章 栈、队列、数组</h1>\n","y":"a","t":"第三章 栈、队列、数组","O":3},["/computer/ds/stack-queue-array/stack-queue-array","/computer/ds/stack-queue-array/stack-queue-array.md"]],
  ["v-4fc8bece","/computer/ds/string/",{"e":"<h1> 第四章 串</h1>\n","y":"a","t":"第四章 串","O":4},["/computer/ds/string/index.html","/computer/ds/string/readme.md"]],
  ["v-46630da2","/computer/ds/string/string.html",{"e":"<h1> 第四章 串</h1>\n","y":"a","t":"第四章 串","O":4},["/computer/ds/string/string","/computer/ds/string/string.md"]],
  ["v-cda24d28","/computer/ds/tree/",{"e":"<h1> 第五章 树</h1>\n","y":"a","t":"第五章 树","O":5},["/computer/ds/tree/index.html","/computer/ds/tree/readme.md"]],
  ["v-21f246fe","/computer/ds/tree/tree-bree-tree.html",{"e":"<h1> 第五章 树与二叉树</h1>\n","y":"a","t":"第五章 树与二叉树","O":5},["/computer/ds/tree/tree-bree-tree","/computer/ds/tree/tree-bree-tree.md"]],
  ["v-3706649a","/404.html",{"y":"p","t":""},["/404"]],
  ["v-a94a8cca","/computer/",{"y":"p","t":"Computer"},["/computer/index.html"]],
  ["v-5bc93818","/category/",{"y":"p","t":"分类","I":0},["/category/index.html"]],
  ["v-744d024e","/tag/",{"y":"p","t":"标签","I":0},["/tag/index.html"]],
  ["v-e52c881c","/article/",{"y":"p","t":"文章","I":0},["/article/index.html"]],
  ["v-154dc4c4","/star/",{"y":"p","t":"收藏","I":0},["/star/index.html"]],
  ["v-01560935","/timeline/",{"y":"p","t":"时间轴","I":0},["/timeline/index.html"]],
]
