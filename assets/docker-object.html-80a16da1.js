import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as r,c as d,b as a,d as e,e as t,a as i}from"./app-a65daed7.js";const c="/assets/2024-01-11-12-36-40-17425df0.png",o="/assets/2024-01-11-12-46-05-eb10555b.png",u="/assets/2024-01-11-12-50-27-54f3eb28.png",p="/assets/2024-01-11-12-51-01-efef7183.png",g="/assets/2024-01-11-12-53-30-35c6a7f3.png",h="/assets/2024-01-11-12-58-09-c1adf561.png",b="/assets/2024-01-11-13-05-39-dd2188d4.png",m="/assets/2024-01-11-13-07-55-f9545e4a.png",f="/assets/2024-01-11-21-37-45-18d9b159.png",v="/assets/2024-01-11-21-40-04-27bdc6e9.png",k="/assets/2024-01-11-21-41-56-8cdcbf4f.png",x="/assets/2024-01-11-21-43-29-255c04f5.png",_="/assets/2024-01-11-21-44-36-e233daa4.png",D="/assets/2024-01-11-22-00-32-c04353ad.png",y="/assets/2024-01-11-22-05-03-bdef52dc.png",z="/assets/2024-01-11-22-08-00-b34c4a09.png",I="/assets/2024-01-11-22-11-50-8ed49329.png",q="/assets/2024-01-11-22-12-38-86e808fe.png",T="/assets/2024-01-11-22-13-37-d071919b.png",E="/assets/2024-01-11-22-21-04-c49d2cbf.png",R="/assets/2024-01-11-22-28-13-33a983d3.png",A="/assets/2024-01-11-22-36-56-fd9063fb.png",H="/assets/2024-01-11-22-41-48-c886da07.png",S="/assets/2024-01-11-22-46-01-7ab008c6.png",N="/assets/2024-01-11-22-48-13-a9a2592b.png",G="/assets/2024-01-11-22-50-38-f0b3d8cd.png",O="/assets/2024-01-11-23-10-50-a12474aa.png",w="/assets/2024-01-11-23-14-38-5bd5c5bf.png",C="/assets/2024-01-14-21-23-52-629bc806.png",M="/assets/2024-01-14-21-26-24-baedc32d.png",V="/assets/2024-01-14-21-30-15-0e72ee20.png",B="/assets/2024-01-14-21-34-21-0251b271.png",L="/assets/2024-01-14-21-38-12-0d6af9e0.png",j="/assets/2024-01-14-21-42-30-3a32e025.png",F={},P=i('<h1 id="docker-镜像、容器、仓库" tabindex="-1"><a class="header-anchor" href="#docker-镜像、容器、仓库" aria-hidden="true">#</a> Docker - 镜像、容器、仓库</h1><div class="hint-container tip"><p class="hint-container-title">提示</p><p>这个章节涉及到 Docker 最核心的知识，也是在使用过程中最常使用到的，需要重点学习。</p></div><h2 id="什么是docker镜像、容器、仓库" tabindex="-1"><a class="header-anchor" href="#什么是docker镜像、容器、仓库" aria-hidden="true">#</a> 什么是Docker镜像、容器、仓库？</h2><ul><li><p>Docker镜像：镜像是一个只读的模板，其中包含了创建 Docker 容器的说明，可以用来创建 Docker 容器。镜像可以包含操作系统、应用程序、依赖库、配置文件等。</p></li><li><p>Docker容器：容器是代码的隔离环境。这意味着容器并不直接在操作系统上运行。容器是 Docker 镜像的一个运行实例，可以理解为一个轻量级的虚拟机，用面向对象的思想来看，其就是一个镜像的运行对象。容器包含了运行应用程序所需的所有组件，包括操作系统、应用程序、依赖库等。</p></li><li><p>Docker仓库：仓库是用来存储和管理 Docker 镜像的地方，类似于代码仓库。Docker 官方提供了 Docker Hub 仓库，可以在其中存储和分享 Docker 镜像。用户也可以自建私有仓库来存储和管理自己的 Docker 镜像。</p></li></ul><h2 id="镜像、容器、仓库之间的关系" tabindex="-1"><a class="header-anchor" href="#镜像、容器、仓库之间的关系" aria-hidden="true">#</a> 镜像、容器、仓库之间的关系</h2><figure><img src="'+c+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Docker 镜像可以看做是一个静态模板，Docker 容器是对镜像的一个实例化，一个镜像可以实例化多个容器，这几个容器相互独立，互不影响。</p><p>Docker 仓库就是存放 Docker 镜像的地方，严格意义上来说可以分为本地仓库和远程仓库，远程仓库由 Docker 官方维护，包含了几乎所有的 Docker 镜像，Docker 本地仓库只有你拉取的镜像。</p><p>在使用 Docker 镜像创建对象之前，需要先拉取 Docker 镜像，这里的拉取通常是指从 Docker 官方仓库拉取。</p><p>故使用 Docker 的基本步骤可以清晰的总结为：</p><ol><li><p>从仓库拉取 Docker 镜像</p></li><li><p>使用 Docker 镜像实例化一个 Docker 容器</p></li><li><p>运行 Docker 容器</p></li></ol><h2 id="docker镜像" tabindex="-1"><a class="header-anchor" href="#docker镜像" aria-hidden="true">#</a> Docker镜像</h2><p>当运行容器时，使用的 Docker 镜像不在本地仓库中，Docker 就会从默认的 Docker 仓库中下载该镜像。一般是从 Docker 官方提供的 Docker Hub 仓库中下载。</p><p>下面来学习关于 Docker 镜像的相关操作。</p><h3 id="镜像列表" tabindex="-1"><a class="header-anchor" href="#镜像列表" aria-hidden="true">#</a> 镜像列表</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> images
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>REPOSITORY：表示镜像的仓库源</li><li>TAG：镜像的标签, 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本</li><li>IMAGE ID：镜像ID</li><li>CREATED：镜像创建时间</li><li>SIZE：镜像大小</li></ul><h3 id="查找镜像" tabindex="-1"><a class="header-anchor" href="#查找镜像" aria-hidden="true">#</a> 查找镜像</h3><div class="hint-container warning"><p class="hint-container-title">注意</p><p>本小节以查找 Redis 镜像为例做演示说明，其他镜像的操作同理。</p></div><ol><li><strong>在 Docker Hub查找</strong></li></ol>',21),U={href:"https://hub.docker.com/search?q=redis&type=image",target:"_blank",rel:"noopener noreferrer"},W=i('<p>这里就已经找到了 Redis 的镜像信息</p><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以查看 Redis 镜像的各种版本信息。</p><figure><img src="'+p+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li><strong>使用 Docker Search查找</strong></li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> search redis
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>NAME: 镜像仓库源的名称</li><li>DESCRIPTION: 镜像的描述</li><li>OFFICIAL: 是否 docker 官方发布</li><li>STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li><li>AUTOMATED: 自动构建。</li></ul><ol start="3"><li><strong>使用 Docker Desktop 查找</strong></li></ol><figure><img src="'+h+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>直接在 Docker Desktop 中搜索即可。</p><h3 id="拉取镜像" tabindex="-1"><a class="header-anchor" href="#拉取镜像" aria-hidden="true">#</a> 拉取镜像</h3><p>拉取镜像即从 Docker 仓库中拉取 Docker 镜像，本质上就是从远程的仓库中下载镜像到本地。</p><blockquote><p>这里仍以 Redis 为样例进行编写，其他镜像的拉取同理。</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> pull redis
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+b+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这里默认拉取的是 Redis 的最新版本，如果要是想拉取指定版本时可以进行如下执行，如拉取 redis7.0</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> pull redis:7.0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+m+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="删除镜像" tabindex="-1"><a class="header-anchor" href="#删除镜像" aria-hidden="true">#</a> 删除镜像</h3><p>这里我们演示删除之前下载的那个 Hello-World 镜像</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> rmi hello-world
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这里如果使用了该镜像创建了容器，那么就会报错。</p><figure><img src="'+v+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果出现这种情况，就说明我们使用了该镜像创建了容器，那么就必须先删除使用该镜像的所有容器，才能够删除该镜像。</p><ul><li>先查看 Docker 容器</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+k+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>然后删除 Docker 容器</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">rm</span> 8c0dde3e3fb4
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+x+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>使用的是 Docker 容器的 ID 删除。</p><ul><li>删除 Docker 镜像</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> rmi hello-world
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+_+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container tip"><p class="hint-container-title">提示</p><p>如果一个镜像创建了多个容器，那么在删除该镜像之前，必须删除所有使用该镜像的容器，才能够删除该镜像。</p></div><h3 id="更新镜像" tabindex="-1"><a class="header-anchor" href="#更新镜像" aria-hidden="true">#</a> 更新镜像</h3><p>Dokcer 镜像的更新就是在目前运行的 Docker 容器上进行修改，然后将更新后的 Docker 容器的所有内容，导出为一个 Docker 镜像，随后就可以使用该镜像创建 Docker 容器。</p><ol><li>先下载一个 Ubuntu20.04 镜像</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> pull ubuntu:20.04
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+D+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>创建一个该镜像的容器</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-t</span> <span class="token parameter variable">-i</span> ubuntu:20.04
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+y+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="3"><li>在该容器内运行 <code>apt-get update</code> 指令，更新 ubuntu 系统，更新后 <code>exit</code> 退出这个容器到我们本地的命令控制端。</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">apt-get</span> update
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+z+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="4"><li>提交容器副本</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> commit <span class="token parameter variable">-m</span><span class="token operator">=</span><span class="token string">&quot;update ubuntu20.04&quot;</span> <span class="token parameter variable">-a</span><span class="token operator">=</span><span class="token string">&quot;CoderMast&quot;</span> 13999fa6f4f6 codermast/ubuntu:latest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+I+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>各个参数说明：</p><ul><li><p>-m: 提交的描述信息</p></li><li><p>-a: 指定镜像作者</p></li><li><p>13999fa6f4f6：容器 ID</p></li><li><p>codermast/ubuntu:latest: 指定要创建的目标镜像名</p></li></ul><ol start="5"><li>查看镜像列表</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> images
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+q+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这里可以看到已经创建成功了，并且大小和之前的不一样了。</p><ol start="6"><li>使用该镜像创建一个容器</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-t</span> <span class="token parameter variable">-i</span> codermast/ubuntu:latest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+T+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="生成镜像" tabindex="-1"><a class="header-anchor" href="#生成镜像" aria-hidden="true">#</a> 生成镜像</h3><h3 id="镜像标签" tabindex="-1"><a class="header-anchor" href="#镜像标签" aria-hidden="true">#</a> 镜像标签</h3><p>我们可以使用 <code>docker tag</code> 命令为镜像添加一个新的标签。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> tag e650c5f208da codermast/ubuntu:v1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>e650c5f208da：为镜像的 ID</li><li>codermast/ubuntu:v1：Tag 名</li></ul><figure><img src="`+E+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>此时我们在创建 Docker 容器时，既可以使用 <code>codermast/ubuntu:latest</code> 也可以使用 <code>codermast/ubuntu:v1</code>。</p><p>Tag 可以看做是给镜像起别名，其本质的镜像 ID 不变，具体底层就是同一个镜像的不同引用而已。</p><h3 id="镜像导入和导出" tabindex="-1"><a class="header-anchor" href="#镜像导入和导出" aria-hidden="true">#</a> 镜像导入和导出</h3><ol><li>镜像导出</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> save <span class="token operator">&gt;</span> codermast-ubuntu-latest.tar e650c5f208da
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>codermast-ubuntu-latest.tar：要导出的文件名</li><li>e650c5f208da：要导出的镜像 ID</li></ul><figure><img src="`+R+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>镜像导入</li></ol><p>在镜像导入之前，为了方便观察，先删除掉该镜像。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> load <span class="token operator">&lt;</span> codermast-ubuntu-latest.tar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>codermast-ubuntu-latest.tar：为要导入的文件名。</li></ul><figure><img src="`+A+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container warning"><p class="hint-container-title">注意</p><ul><li>若是只想备份images，使用save、load即可</li><li>若是在启动容器后，容器内容有变化，需要备份，则使用export、import</li></ul></div><h2 id="docker容器" tabindex="-1"><a class="header-anchor" href="#docker容器" aria-hidden="true">#</a> Docker容器</h2><p>在上面的 Docker 镜像的相关操作中，我们或多或少的了解和学习了一些 Docker 容器的相关操作。</p><h3 id="容器启动" tabindex="-1"><a class="header-anchor" href="#容器启动" aria-hidden="true">#</a> 容器启动</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> codermast/ubuntu:latest /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>-it 可以连写的，表示 -i -t</li><li>-t: 在新容器内指定一个伪终端或终端。</li><li>-i: 允许你对容器内的标准输入 (STDIN) 进行交互</li><li>codermast/ubuntu:latest：镜像名称</li></ul><figure><img src="`+H+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="容器查看" tabindex="-1"><a class="header-anchor" href="#容器查看" aria-hidden="true">#</a> 容器查看</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>-a 表示 all，即查看所有容器</li></ul><figure><img src="`+S+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="容器再启动" tabindex="-1"><a class="header-anchor" href="#容器再启动" aria-hidden="true">#</a> 容器再启动</h3><p>我们看到，刚才 <code>codermast/ubuntu:latest</code> 的实例<code>d3a11e669e88</code> 已经停止了<code>Exited (0) 4 seconds ago</code>，我们重启这个实例</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> start d3a11e669e88
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+N+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="容器停止和重启" tabindex="-1"><a class="header-anchor" href="#容器停止和重启" aria-hidden="true">#</a> 容器停止和重启</h3><ul><li>容器停止</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> stop d3a11e669e88
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>容器重启</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> restart d3a11e669e88
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+G+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="后台模式与进入" tabindex="-1"><a class="header-anchor" href="#后台模式与进入" aria-hidden="true">#</a> 后台模式与进入</h3><p>在使用 -d 参数创建容器时，容器启动后会进入后台，那么此时我们怎么进入容器呢？</p><ul><li>使用 `docker attach [容器ID]</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> attach d3a11e669e88\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="'+O+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><code>docker exec -i -t [容器ID] /bin/bash</code></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-t</span> d3a11e669e88 /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+w+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container warning"><p class="hint-container-title">注意</p><ul><li><p><code>docker attach</code> 在退出容器终端后，容器会停止运行。</p></li><li><p><code>docker exec</code> 在退出容器终端后，不会导致容器的停止。</p></li></ul><p>✅ 推荐大家使用 <code>docker exec</code></p></div><h3 id="容器导出和导入" tabindex="-1"><a class="header-anchor" href="#容器导出和导入" aria-hidden="true">#</a> 容器导出和导入</h3><ol><li>容器的导出</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">export</span> 246b23d5d5a5 <span class="token operator">&gt;</span> redis-latest-codermast.tar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>246b23d5d5a5：容器 ID</li><li>redis-latest-codermast.tar：导出文件名</li></ul><figure><img src="`+C+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>容器的导入</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">import</span> redis-latest-codermast.tar codermast/redis:latest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>redis-latest-codermast.tar：配置文件名</li><li>codermast/redis:latest：导入的镜像名称</li></ul><figure><img src="`+M+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>要注意的是，这里是对 Docker 容器进行导出，但是导出的结果是镜像的配置文件，通过该配置文件导入的也是 Docker 镜像。</p><figure><img src="'+V+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></blockquote><h3 id="强制删除容器" tabindex="-1"><a class="header-anchor" href="#强制删除容器" aria-hidden="true">#</a> 强制删除容器</h3><p>我们知道，当容器在运行的时候是无法直接删除的，需要先将容器先停止运行，随后才能删除该容器，那么能不能直接删除正在运行中的容器呢？</p><p>答案是可以的，我们只需要在其中加上 <code>-f</code> 的选项即可，代表 <code>force</code> 强制的意思。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> b234f112186d

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>b234f112186d：为 正在运行 Docker 容器的 ID</li></ul><figure><img src="`+B+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="清理停止的容器" tabindex="-1"><a class="header-anchor" href="#清理停止的容器" aria-hidden="true">#</a> 清理停止的容器</h3><p>在容器停止运行后，并不会自动被删除，需要手动清除。该指令一次性清除所有的停止状态的容器。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> container prune
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+L+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="容器别名及操作" tabindex="-1"><a class="header-anchor" href="#容器别名及操作" aria-hidden="true">#</a> 容器别名及操作</h3><p>上述对容器的操作都是针对容器 ID，这个 ID 是随机的，为了方便起见，我们可以设置一个自定义的 name 来进行操作。仅需在指令中设置 <code>name</code> 选项即可。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> codermast-redis-001 redis:latest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>codermast-redis-001：自定义的名称</li><li>redis:latest：镜像名称</li></ul><figure><img src="`+j+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="容器错误日志" tabindex="-1"><a class="header-anchor" href="#容器错误日志" aria-hidden="true">#</a> 容器错误日志</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> logs <span class="token punctuation">..</span>.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>实时查看docker容器名为user-uat的最后10行日志</li></ul><p><code>docker logs -f -t --tail 10 user-uat</code></p><ul><li>查看指定时间后的日志，只显示最后100行：</li></ul><p><code>docker logs -f -t --since=&quot;2024-01-14&quot; --tail=100 user-uat</code></p><ul><li>查看最近30分钟的日志:</li></ul><p><code>docker logs --since 30m user-uat</code></p><ul><li>查看某时间之后的日志：</li></ul><p><code>docker logs -t --since=&quot;2024-01-14T21:00:00&quot; user-uat</code></p><ul><li>查看某时间段日志：</li></ul><p><code>docker logs -t --since=&quot;2024-01-14T21:00:00&quot; --until &quot;2018-02-09T12:23:37&quot; user-uat</code></p><ul><li>将错误日志写入文件：</li></ul><p><code>docker logs -f -t --since=&quot;2024-01-14&quot; user-uat | grep error &gt;&gt; logs_error.txt</code></p><h2 id="docker仓库" tabindex="-1"><a class="header-anchor" href="#docker仓库" aria-hidden="true">#</a> Docker仓库</h2><p>Docker 仓库是集中存放 Docker 镜像的地方。默认使用的仓库为 Docker Hub，也可以更改为自己的想使用的仓库。类似于 Github 的仓库，只不过 Github 管理的是代码，Docker Hub 管理的是 Docker 镜像。</p><p>这里以 Docker Hub 为例进行说明。</p><ol><li>登录仓库</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> login
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li>将准备好的镜像推送至仓库</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> push codermast/redis:latest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>codermast/redis:latest：Docker 镜像名</li></ul>`,155);function Y(Z,J){const s=l("ExternalLinkIcon");return r(),d("div",null,[P,a("p",null,[e("使用 Docker Hub 中提供的查找功能："),a("a",U,[e("https://hub.docker.com/search?q=redis&type=image"),t(s)])]),W])}const X=n(F,[["render",Y],["__file","docker-object.html.vue"]]);export{X as default};
