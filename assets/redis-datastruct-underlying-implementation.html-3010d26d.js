import{_ as p,W as l,X as c,Z as n,a0 as t,$ as s,Y as e,C as i}from"./framework-a0cce298.js";const o="/assets/2023-06-16-13-30-51-0d24d5a1.png",u="/assets/2023-06-16-13-35-41-d79ce9b9.png",r="/assets/2023-06-16-13-38-27-9a6526df.png",d="/assets/2023-06-16-13-40-37-e6bd5b51.png",k="/assets/2023-06-16-16-33-35-f67e1690.png",m={},v=e(`<h1 id="redis原理-数据结构的底层实现" tabindex="-1"><a class="header-anchor" href="#redis原理-数据结构的底层实现" aria-hidden="true">#</a> Redis原理 - 数据结构的底层实现</h1><h2 id="动态字符串sds" tabindex="-1"><a class="header-anchor" href="#动态字符串sds" aria-hidden="true">#</a> 动态字符串SDS</h2><h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h3><p>Redis 中保存的 Key 是字符串，Value 往往是字符串或者字符串的集合。可见字符串是 Redis 中最常见的一种数据结构。</p><p>Redis 是使用 C 语言来编写的，C 语言中也有字符串，但是 Redis 中并没有直接使用 C 语言的字符串，这是因为 C 语言中字符串存在着很多的问题：</p><ul><li>获取字符串长度需要进行运算</li><li>非二进制安全，不能包含特殊字符</li></ul><blockquote><p>因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p></blockquote><ul><li>不可修改，C 语言的字符串实质为字符数组，以<code>\\0</code>结尾。</li></ul><p>为了解决以上问题，Redis 自己构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称为SDS</p><h3 id="底层实现" tabindex="-1"><a class="header-anchor" href="#底层实现" aria-hidden="true">#</a> 底层实现</h3><p>SDS 在 Redis 中的实现在 <code>/src/sds.h</code>、<code>/src/sds.c</code> 文件中，具体的核心实现如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.
 * However is here to document the layout of type 5 SDS strings. */</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr5</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, and 5 msb of string length */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint8_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>
    <span class="token class-name">uint8_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr16</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint16_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>
    <span class="token class-name">uint16_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr32</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint32_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>
    <span class="token class-name">uint32_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr64</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint64_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>
    <span class="token class-name">uint64_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,12),h=e('<p><strong>标识符对应信息</strong></p><table><thead><tr><th style="text-align:center;">标识信息</th><th style="text-align:center;">对应值</th></tr></thead><tbody><tr><td style="text-align:center;">SDS_TYPE_5</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">SDS_TYPE_8</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:center;">SDS_TYPE_16</td><td style="text-align:center;">2</td></tr><tr><td style="text-align:center;">SDS_TYPE_32</td><td style="text-align:center;">3</td></tr><tr><td style="text-align:center;">SDS_TYPE_64</td><td style="text-align:center;">4</td></tr></tbody></table><p>例如，一个包含字符串<code>name</code>的sds结构如下：</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="内存预分配" tabindex="-1"><a class="header-anchor" href="#内存预分配" aria-hidden="true">#</a> 内存预分配</h3><p>SDS 之所以叫做动态字符串，是因为其具备动态扩容的能力，例如一个内容为 “hi” 的 SDS</p><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>假如我们要给 SDS 追加一段字符串 “,Amy” ，这里因为空间不够，需要申请新的内存空间：</p><ul><li>如果新字符串小于 1M ，则新空间扩展后字符串长度的两倍 + 1</li><li>如果新字符串大于 1M ，则新空间为扩展后字符串长度 + 1M + 1。称为内存预分配</li></ul><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container tip"><p class="hint-container-title">优点</p><ol><li>获取字符串长度的时间复杂度为 O(1)</li><li>支持动态扩容</li><li>减少内存分配次数</li><li>二进制安全，字符串可存储特殊字符</li></ol></div><h3 id="sds小结" tabindex="-1"><a class="header-anchor" href="#sds小结" aria-hidden="true">#</a> SDS小结</h3><p>Redis的字符串表示为 SDS ，而不是 C 字符串（以\\0结尾的char*）， 它是 Redis 底层所使用的字符串表示，它被用在几乎所有的 Redis 模块中。可以看如下对比：</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）：包括 AOF 模块中的AOF缓冲区以及客户端状态中的输入缓冲区。</p><h2 id="整数集intset" tabindex="-1"><a class="header-anchor" href="#整数集intset" aria-hidden="true">#</a> 整数集IntSet</h2><h3 id="基本概念-1" tabindex="-1"><a class="header-anchor" href="#基本概念-1" aria-hidden="true">#</a> 基本概念</h3><p>IntSet 是 Redis 中 Set 集合类型的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。</p><p>当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。</p><p>为了方便查找，Redis 会将 IntSet 中所有的整数按照升序依次保存在 contents 数组中，结构图如下</p><figure><img src="'+k+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>现在数组中每个数字都保存在 int16_t 的范围内，因此采用的编码方式为 INTSET_ENC_INT16，每部分占用的字节大小为：</p><ul><li>encoding：4 字节</li><li>length：4 字节</li><li>contents：2 字节 * 3 = 6 字节</li><li>共计 4 + 4 + 6 = 16 字节</li></ul><h3 id="底层实现-1" tabindex="-1"><a class="header-anchor" href="#底层实现-1" aria-hidden="true">#</a> 底层实现</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">intset</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint32_t</span> encoding<span class="token punctuation">;</span>
    <span class="token class-name">uint32_t</span> length<span class="token punctuation">;</span>
    <span class="token class-name">int8_t</span> contents<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> intset<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,25),b=e(`<p><strong>其中的 encoding 包含三种模式，表示存储的整数大小不同：</strong></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/* Note that these encodings are ordered, so:
* INTSET_ENC_INT16 &lt; INTSET_ENC_INT32 &lt; INTSET_ENC_INT64. */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INTSET_ENC_INT16</span> <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">int16_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INTSET_ENC_INT32</span> <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INTSET_ENC_INT64</span> <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">int64_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>int16_t：2 字节整数，范围类似 Java 的 short</li><li>int32_t：4 字节整数，范围类似 Java 的 int</li><li>int64_t：8 字节整数，范围类似 Java 的 lang</li></ul>`,3),g=e(`<h3 id="数组扩容" tabindex="-1"><a class="header-anchor" href="#数组扩容" aria-hidden="true">#</a> 数组扩容</h3><p>当在一个 int8 类型的整数集合中添加一个 int16 类型的数据元素，那么整个整数集合中的元素都会升级为 int16 类型，内存不够时还会进行扩容。具体的步骤如下：</p><ol><li>根据新元素的数据类型，改变编码方式。按照新的编码方式及元素的个数进行数组扩容</li><li>倒序依次将数组中的元素拷贝到扩容后的正确位置。倒序是为了防止正序拷贝时的数据覆盖，不会产生数据丢失。</li><li>把待添加的元素放入数组末尾</li><li>修改 encoding 信息，并将length + 1，维护好各项属性</li></ol><p><strong>底层实现</strong></p><ul><li>插入元素</li></ul><details class="hint-container details"><summary>代码详情</summary><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/* Insert an integer in the intset */</span>
intset <span class="token operator">*</span><span class="token function">intsetAdd</span><span class="token punctuation">(</span>intset <span class="token operator">*</span>is<span class="token punctuation">,</span> <span class="token class-name">int64_t</span> value<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取当前值编码</span>
    <span class="token class-name">uint8_t</span> valenc <span class="token operator">=</span> <span class="token function">_intsetValueEncoding</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 要插入的位置</span>
    <span class="token class-name">uint32_t</span> pos<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>success<span class="token punctuation">)</span> <span class="token operator">*</span>success <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token comment">// 判断编码是不是超过了当前 intset 的编码</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>valenc <span class="token operator">&gt;</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-&gt;</span>encoding<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 超出编码，需要升级</span>
        <span class="token keyword">return</span> <span class="token function">intsetUpgradeAndAdd</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在当前 intset 中查找值与 value 一样的元素的角标 pos</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">intsetSearch</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>value<span class="token punctuation">,</span><span class="token operator">&amp;</span>pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果找到了，则无需插入，直接结束并返回失败</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>success<span class="token punctuation">)</span> <span class="token operator">*</span>success <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> is<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 数组扩容</span>
        is <span class="token operator">=</span> <span class="token function">intsetResize</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span><span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 移动数组中 pos 之后的元素到 pos + 1，给新元素腾出空间</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">intsetMoveTail</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>pos<span class="token punctuation">,</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 插入新元素</span>
    <span class="token function">_intsetSet</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>pos<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    is<span class="token operator">-&gt;</span>length <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span><span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> is<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><ul><li>数组扩容</li></ul><details class="hint-container details"><summary>代码详情</summary><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/* Upgrades the intset to a larger encoding and inserts the given integer. */</span>
<span class="token keyword">static</span> intset <span class="token operator">*</span><span class="token function">intsetUpgradeAndAdd</span><span class="token punctuation">(</span>intset <span class="token operator">*</span>is<span class="token punctuation">,</span> <span class="token class-name">int64_t</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当前 intset 编码</span>
    <span class="token class-name">uint8_t</span> curenc <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-&gt;</span>encoding<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 新编码</span>
    <span class="token class-name">uint8_t</span> newenc <span class="token operator">=</span> <span class="token function">_intsetValueEncoding</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 元素个数</span>
    <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 判断元素是大于 0 还是，小于 0。小于 0 插入队首，大于 0 插入队尾。</span>
    <span class="token keyword">int</span> prepend <span class="token operator">=</span> value <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// 重置编码为新编码</span>
    is<span class="token operator">-&gt;</span>encoding <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>newenc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 重置数组大小</span>
    is <span class="token operator">=</span> <span class="token function">intsetResize</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span><span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 倒序遍历，逐个搬运元素到新的位置，_intsetGetEncoding按照旧编码方式查找旧元素</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>length<span class="token operator">--</span><span class="token punctuation">)</span>
        <span class="token comment">// _intsetSet按照新编码方式插入新元素</span>
        <span class="token function">_intsetSet</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>length<span class="token operator">+</span>prepend<span class="token punctuation">,</span><span class="token function">_intsetGetEncoded</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>length<span class="token punctuation">,</span>curenc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 插入新元素，prepend 决定是插入队首，还是队尾</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prepend<span class="token punctuation">)</span>
        <span class="token function">_intsetSet</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">_intsetSet</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span><span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 修改数组长度</span>
    is<span class="token operator">-&gt;</span>length <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span><span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> is<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><ul><li>数组查询</li></ul><details class="hint-container details"><summary>代码详情</summary><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/* Search for the position of &quot;value&quot;. Return 1 when the value was found and
 * sets &quot;pos&quot; to the position of the value within the intset. Return 0 when
 * the value is not present in the intset and sets &quot;pos&quot; to the position
 * where &quot;value&quot; can be inserted. */</span>
<span class="token keyword">static</span> <span class="token class-name">uint8_t</span> <span class="token function">intsetSearch</span><span class="token punctuation">(</span>intset <span class="token operator">*</span>is<span class="token punctuation">,</span> <span class="token class-name">int64_t</span> value<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> <span class="token operator">*</span>pos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> mid <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token class-name">int64_t</span> cur <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token comment">/* The value can never be found when the set is empty */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token punctuation">)</span> <span class="token operator">*</span>pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">/* Check for the case where we know we cannot find the value,
         * but do know the insert position. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&gt;</span> <span class="token function">_intsetGet</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>max<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token punctuation">)</span> <span class="token operator">*</span>pos <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> <span class="token function">_intsetGet</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token punctuation">)</span> <span class="token operator">*</span>pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span>max <span class="token operator">&gt;=</span> min<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>min <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>max<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
        cur <span class="token operator">=</span> <span class="token function">_intsetGet</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&gt;</span> cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            min <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            max <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token punctuation">)</span> <span class="token operator">*</span>pos <span class="token operator">=</span> mid<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token punctuation">)</span> <span class="token operator">*</span>pos <span class="token operator">=</span> min<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><div class="hint-container warning"><p class="hint-container-title">思考</p><p><strong>在添加数据时会进行扩容操作，那么在删除数据时会进行缩容操作吗？那么如果删除掉刚加入的int16类型时，会不会做一个降级操作呢？</strong></p><p>答案：不会。主要还是减少开销的权衡。</p></div><h3 id="intset小结" tabindex="-1"><a class="header-anchor" href="#intset小结" aria-hidden="true">#</a> IntSet小结</h3><p>IntSet 可以看做是特殊的整数数组，具备一些特点：</p><ul><li>Redis 会确保 IntSet 中的元素唯一、有序</li><li>具备类型升级机制，可以节省内存空间</li><li>底层采用二分查找方式来查询</li></ul><h2 id="字典-哈希表dict" tabindex="-1"><a class="header-anchor" href="#字典-哈希表dict" aria-hidden="true">#</a> 字典/哈希表Dict</h2><h3 id="基本概念-2" tabindex="-1"><a class="header-anchor" href="#基本概念-2" aria-hidden="true">#</a> 基本概念</h3><p><strong>Dict</strong> Dict 由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p><p><strong>哈希算法</strong></p><p>Redis 计算哈希值和索引值方法如下：</p><ol><li><p>使用字典设置的哈希函数，计算键 key 的哈希值 <code>hash = dict-&gt;type-&gt;hashFunction(key);</code></p></li><li><p>使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值 <code>index = hash &amp; dict-&gt;ht[x].sizemask;</code></p></li></ol><p><strong>哈希冲突</strong></p><p>哈希冲突（Hash Collision）是指在使用哈希表存储数据时，两个或多个不同的键（Key）被哈希函数映射到同一个位置的情况。这种情况会导致数据的存储和查找变得复杂，因此需要采取一些措施来解决哈希冲突。</p><p>Dict 中解决哈希冲的方法是 <mark>链地址法</mark>。</p><div class="hint-container note"><p class="hint-container-title">其他办法</p><p>除了链地址法解决哈希冲突以外，还可以使用开放地址法、在哈希法、建立公共溢出区等方法解决。</p></div><h3 id="底层实现-2" tabindex="-1"><a class="header-anchor" href="#底层实现-2" aria-hidden="true">#</a> 底层实现</h3><ul><li>哈希表</li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictht</span><span class="token punctuation">{</span>
    <span class="token comment">// entry 数组</span>
    <span class="token comment">// 数组中保存的是指向 entry 的指针</span>
    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>
    <span class="token comment">// 哈希大小</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>
    <span class="token comment">// 哈希表大小的掩码，总等于 size - 1</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span>
    <span class="token comment">// entry 个数</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span>
<span class="token punctuation">}</span> dictht<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>哈希节点</li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>  <span class="token comment">// 键</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>
        <span class="token class-name">uint64_t</span> u64<span class="token punctuation">;</span>
        <span class="token class-name">int64_t</span> s64<span class="token punctuation">;</span>
        <span class="token keyword">double</span> d<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> v<span class="token punctuation">;</span>   <span class="token comment">// 值</span>
    <span class="token comment">// 下一个 Entry 的指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> dictEntry<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们向 Dict 添加键值对时，Redis 首先根据 key 计算出 hash 值（h），然后利用 h &amp; sizemask 来计算元素应该存储到数组中的哪个索引位置。</p><ul><li>字典</li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dict</span><span class="token punctuation">{</span>
    <span class="token comment">// dict 类型，内置不同的 hash 函数</span>
    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>
    <span class="token comment">// 私有数组，在做特殊 hash 运算时使用</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>
    <span class="token comment">// 一个Dict包含两个哈希表，其中一个是当前数据，另一个一般是空，rehash时使用</span>
    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// rehash 的进度，-1 表示未进行</span>
    <span class="token keyword">long</span> rehashidx<span class="token punctuation">;</span>
    <span class="token comment">// rehash是否暂停，1则暂停，0则继续]</span>
    <span class="token class-name">int16_t</span> pauserehash<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>dict<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="扩容收缩" tabindex="-1"><a class="header-anchor" href="#扩容收缩" aria-hidden="true">#</a> 扩容收缩</h3><p>当哈希表保存的键值对太多或者太少时，就要通过 rehash(重新散列）来对哈希表进行相应的扩展或者收缩。</p><p><strong>扩容</strong></p><p>Dict 中的 HashTable 就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。</p><p>Dict在每次新增键值对时都会检查负载因子，满足以下两种情况时会触发哈希表扩容：</p><ul><li>哈希表的 LocalFactor &gt;= 1，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程。</li><li>哈希表的 LocalFactor &gt; 5，无论是否在执行BGSAVE 命令或者 BGREWRITEAOF 命令。</li></ul><div class="hint-container info"><p class="hint-container-title">负载因子</p><p>负载因子 = 哈希表已保存节点数量 / 哈希表大小。</p></div><p><strong>收缩</strong></p><p>Dict 除了扩容以外，每次删除元素时，也会对负载因子做检查，当 LocalFactor &lt; 0.1 时，会做哈希收缩。</p><p><strong>扩容收缩的具体步骤如下：</strong></p><ol><li><p>如果执行扩展操作，会基于原哈希表创建一个大小等于 <code>ht[0].used*2n</code> 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。</p></li><li><p>重新利用哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。</p></li><li><p>所有键值对都迁徙完毕后，释放原哈希表的内存空间。</p></li></ol><h3 id="rehash" tabindex="-1"><a class="header-anchor" href="#rehash" aria-hidden="true">#</a> ReHash</h3><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的 size 和 sizemask 变化，而 key 的查询与 sizemask 有关。因此必须对哈希表中的每一个 key 重新计算索引，插入新的哈希表，这个过程称为 rehash。具体的步骤如下。</p>`,45),y=n("ol",null,[n("li",null,[s("计算新hash表的realesize，值取决于当前要做的是扩容还是收缩： "),n("ul",null,[n("li",null,[s("如果是扩容，则新size为第一个大于等于"),n("code",null,"dict.ht[O].used + 1"),s("的 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msup",null,[n("mn",null,"2"),n("mi",null,"n")])]),n("annotation",{encoding:"application/x-tex"},"2 ^ n")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6644em"}}),n("span",{class:"mord"},[n("span",{class:"mord"},"2"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.6644em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mathnormal mtight"},"n")])])])])])])])])])])]),n("li",null,[s("如果是收缩，则新size为第一个大于等于"),n("code",null,"dict.ht[O].used"),s("的"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msup",null,[n("mn",null,"2"),n("mi",null,"n")])]),n("annotation",{encoding:"application/x-tex"},"2 ^ n")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6644em"}}),n("span",{class:"mord"},[n("span",{class:"mord"},"2"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.6644em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mathnormal mtight"},"n")])])])])])])])])])]),s(" (不得小于4)")])])]),n("li",null,[s("按照新的realeSize申请内存空间，创建"),n("code",null,"dictht"),s("，并赋值给"),n("code",null,"dict.ht[1]")]),n("li",null,[s("设置"),n("code",null,"dict.rehashidx=0"),s("，标示开始"),n("code",null,"rehash")]),n("li",null,[s("将 "),n("code",null,"dict.ht[O]"),s(" 中的每一个"),n("code",null,"dictEntry"),s("都"),n("code",null,"rehash"),s("到"),n("code",null,"dict.ht[1]")]),n("li",null,[s("将 "),n("code",null,"dict.ht[1]"),s(" 赋值给"),n("code",null,"dict.ht[O]"),s("，给 "),n("code",null,"dict.ht[1]"),s(" 初始化为空哈希表，释放原来的"),n("code",null,"dict.ht[O]"),s("的内存")])],-1),f=n("p",null,"Dict的 rehash 并不是一次性完成的，如果 Dict 中包含数百万的 entry ，要在一次 rehash 完成，极有可能导致主线程阻塞。因此 Dict 的 rehash 是分多次、渐进式的完成，因此称为渐进式 rehash。",-1),_=n("ol",null,[n("li",null,[n("p",null,"计算新hash表的realesize，值取决于当前要做的是扩容还是收缩："),n("ul",null,[n("li",null,[s("如果是扩容，则新size为第一个大于等于"),n("code",null,"dict.ht[O].used + 1"),s("的 "),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msup",null,[n("mn",null,"2"),n("mi",null,"n")])]),n("annotation",{encoding:"application/x-tex"},"2 ^ n")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6644em"}}),n("span",{class:"mord"},[n("span",{class:"mord"},"2"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.6644em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mathnormal mtight"},"n")])])])])])])])])])])]),n("li",null,[s("如果是收缩，则新size为第一个大于等于"),n("code",null,"dict.ht[O].used"),s("的"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msup",null,[n("mn",null,"2"),n("mi",null,"n")])]),n("annotation",{encoding:"application/x-tex"},"2 ^ n")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6644em"}}),n("span",{class:"mord"},[n("span",{class:"mord"},"2"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.6644em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mathnormal mtight"},"n")])])])])])])])])])]),s(" (不得小于4)")])])]),n("li",null,[n("p",null,[s("按照新的realeSize申请内存空间，创建"),n("code",null,"dictht"),s("，并赋值给"),n("code",null,"dict.ht[1]")])]),n("li",null,[n("p",null,[s("设置"),n("code",null,"dict.rehashidx=0"),s("，标示开始"),n("code",null,"rehash")])]),n("li",null,[n("p",null,[s("每次执行新增、查询、修改、删除操作时，都检查一下"),n("code",null,"dict.rehashidx"),s("是否大于-1，如果是则将"),n("code",null,"dict.ht[0].table[rehashid]"),s("的"),n("code",null,"entry"),s("链表rehash到"),n("code",null,"dictht[1]"),s("，并且将"),n("code",null,"rehashidx++"),s("。直至"),n("code",null,"dict.ht[0]"),s("的所有数据都rehash到"),n("code",null,"dict.ht[1]")])]),n("li",null,[n("p",null,[s("将 "),n("code",null,"dict.ht[1]"),s(" 赋值给"),n("code",null,"dict.ht[O]"),s("，给 "),n("code",null,"dict.ht[1]"),s(" 初始化为空哈希表，释放原来的"),n("code",null,"dict.ht[O]"),s("的内存")])]),n("li",null,[n("p",null,"将rehashidx赋值为-1，代表rehash结束")]),n("li",null,[n("p",null,[s("在rehash过程中，新增操作，则直接写入"),n("code",null,"ht[1]"),s("，查询、修改和删除则会在"),n("code",null,"dict,ht[0]"),s("和"),n("code",null,"dict.ht[1]"),s("依次查找并执行。这样可以确保"),n("code",null,"ht[0]"),s("的数据只减不增，随着rehash最终为空")])])],-1),w=e('<p><strong>什么叫渐进式 rehash？</strong></p><p>也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成 Redis 一段时间内不能进行别的操作。所以 Redis 采用渐进式 rehash，这样在进行渐进式 rehash 期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行增加操作，一定是在新的哈希表上进行的。</p><p>可以简单的理解为慢慢的将旧的哈希表，慢慢迁移到新的哈希表中。</p><h3 id="dict小结" tabindex="-1"><a class="header-anchor" href="#dict小结" aria-hidden="true">#</a> Dict小结</h3><p><strong>Dict的结构</strong></p><ul><li><p>类似java的HashTable，底层是数组加链表来解决哈希冲突</p></li><li><p>Dict包含两个哈希表，<code>ht[0]</code>平常用，<code>ht[1]</code>用来rehash</p></li></ul><p><strong>Dict的伸缩</strong></p>',7),x=n("ul",null,[n("li",null,"当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容"),n("li",null,"当LoadFactor小于0.1时，Dict收缩"),n("li",null,[s("扩容大小为第一个大于等于"),n("code",null,"used + 1"),s("的"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msup",null,[n("mn",null,"2"),n("mi",null,"n")])]),n("annotation",{encoding:"application/x-tex"},"2 ^ n")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6644em"}}),n("span",{class:"mord"},[n("span",{class:"mord"},"2"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.6644em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mathnormal mtight"},"n")])])])])])])])])])])]),n("li",null,[s("收缩大小为第一个大于等于"),n("code",null,"used"),s("的"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msup",null,[n("mn",null,"2"),n("mi",null,"n")])]),n("annotation",{encoding:"application/x-tex"},"2 ^ n")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6644em"}}),n("span",{class:"mord"},[n("span",{class:"mord"},"2"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.6644em"}},[n("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mathnormal mtight"},"n")])])])])])])])])])])]),n("li",null,"Dict采用渐进式rehash，每次访问Dict时执行一次rehash"),n("li",null,[s("rehash时"),n("code",null,"ht[0]"),s("只减不增，新增操作只在"),n("code",null,"ht[1]"),s("执行，其它操作在两个哈希表")])],-1),S=e('<h2 id="压缩列表ziplist" tabindex="-1"><a class="header-anchor" href="#压缩列表ziplist" aria-hidden="true">#</a> 压缩列表ZipList</h2><h2 id="快速列表quicklist" tabindex="-1"><a class="header-anchor" href="#快速列表quicklist" aria-hidden="true">#</a> 快速列表QuickList</h2><h2 id="跳表skiplist" tabindex="-1"><a class="header-anchor" href="#跳表skiplist" aria-hidden="true">#</a> 跳表SkipList</h2>',3);function z(D,E){const a=i("Badge");return l(),c("div",null,[v,n("ul",null,[n("li",null,[t(a,{text:"len",type:"tip",vertical:"middle"}),s("：buf已保存的字符串字节数，不包含结束标示")]),n("li",null,[t(a,{text:"alloc",type:"warning",vertical:"middle"}),s("：buf申请的总的字节数，不包含结束标志")]),n("li",null,[t(a,{text:"flags",type:"info",vertical:"middle"}),s("：不同SDS的头类型，用来控制SDS的头大小")]),n("li",null,[t(a,{text:"buf",type:"note",vertical:"middle"}),s("：实际存储的字符数组")])]),h,n("ul",null,[n("li",null,[t(a,{text:"encoding",type:"tip",vertical:"middle"}),s("：编码方式，支持存放 16 位、32 位、64 位整数"),b]),n("li",null,[t(a,{text:"length",type:"warning",vertical:"middle"}),s("：元素个数")]),n("li",null,[t(a,{text:"contents[]",type:"info",vertical:"middle"}),s("：整数数组，保存集合数据。指向实际存储数值的连续内存区域, 就是一个数组；整数集合的每个元素都是 contents 数组的一个数组项（item），各个项在数组中按值得大小从小到大有序排序，且数组中不包含任何重复项。（虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组，但实际上 contents 数组并不保存任何 int8_t 类型的值，contents 数组的真正类型取决于 encoding 属性的值）")])]),g,y,f,_,w,x,S])}const R=p(m,[["render",z],["__file","redis-datastruct-underlying-implementation.html.vue"]]);export{R as default};
