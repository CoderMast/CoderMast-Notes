import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as l,a as t}from"./app-B95FEo_2.js";const o="/assets/2024-04-05-04-45-51-CZEZjYs0.png",i="/assets/2024-04-05-04-46-00-CfHlMTrp.png",p={},s=t('<h1 id="map-hashmap-源码解析" tabindex="-1"><a class="header-anchor" href="#map-hashmap-源码解析"><span>Map - HashMap 源码解析</span></a></h1><h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h2><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射，实现了 Map 接口，能够根据键的哈希值(HashCode)存储数据，具有很高的访问效率，最多允许一条键为 null 的值，不支持线程同步，即线程不安全。也不保证元素顺序，即根据需要容器可能会对元素重新哈希，元素的顺序就会被打乱，和 TreeMap 有所区别。</p><p>HashMap 是 HashSet、HashTable、ConcurrentHashMap 这三种数据结构的基础。</p><h2 id="常用api" tabindex="-1"><a class="header-anchor" href="#常用api"><span>常用API</span></a></h2><ol><li>添加元素</li></ol><ul><li><code>put(K key, V value)</code>: 将指定的键值对存储到 HashMap 中。</li><li><code>putAll(Map&lt;? extends K, ? extends V&gt; m)</code>: 将另一个 Map 中的所有键值对添加到当前 HashMap 中。</li></ul><ol start="2"><li>获取元素</li></ol><ul><li><code>get(Object key)</code>: 获取指定键对应的值。</li><li><code>getOrDefault(key, defaultValue)</code>：获取指定键对应的值，如果指定键不存在则返回 defaultValue</li><li><code>keySet()</code>: 返回 HashMap 中所有键组成的 Set 集合。</li><li><code>values()</code>: 返回 HashMap 中所有值组成的 Collection 集合。</li><li><code>entrySet()</code>: 返回 HashMap 中所有键值对组成的 Set 集合，每个元素都是 Map.Entry 对象，包含键值对信息。</li></ul><ol start="3"><li>删除元素</li></ol><ul><li><code>remove(Object key)</code>: 删除指定键对应的键值对。</li><li><code>clear()</code>: 清空 HashMap 中的所有键值对。</li></ul><ol start="4"><li>修改元素</li></ol><ul><li><code>replace(K key, V oldValue, V newValue)</code>: 将指定键对应的值从 oldValue 替换为 newValue。</li><li><code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>: 使用给定的函数对每个键值对执行替换操作。</li></ul><ol start="5"><li>判断元素</li></ol><ul><li><code>containsKey(Object key)</code>: 判断 HashMap 是否包含指定的键。</li><li><code>containsValue(Object value)</code>: 判断 HashMap 是否包含指定的值。</li><li><code>isEmpty()</code>: 判断 HashMap 是否为空。</li></ul><ol start="6"><li>其他操作</li></ol><ul><li><code>size()</code>: 返回 HashMap 中键值对的数量。</li></ul><h2 id="实现方式" tabindex="-1"><a class="header-anchor" href="#实现方式"><span>实现方式</span></a></h2><h3 id="底层存储" tabindex="-1"><a class="header-anchor" href="#底层存储"><span>底层存储</span></a></h3><p>HashMap 在底层实际上是一个可以扩容的动态数组，数组中存储的是发生冲突的链表节点的头结点，或者是红黑树的根节点。</p><ol><li>在 JDK8 之前是直接将发生冲突的元素通过链表存储起来。</li></ol><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>在 JDK8 之后，考虑到了链表的效率不高，根据链表的结点数量将其动态的调整为红黑树。</li></ol><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从上面不难看出，只要选择合适的哈希算法，就能在 O(1) 的时间内找到想要的数据，即只要不发生哈希碰撞就一定能在 O(1) 的时间内找到想要的数据。</p><h2 id="get方法" tabindex="-1"><a class="header-anchor" href="#get方法"><span>Get方法</span></a></h2><h2 id="put方法" tabindex="-1"><a class="header-anchor" href="#put方法"><span>Put方法</span></a></h2><h2 id="remove方法" tabindex="-1"><a class="header-anchor" href="#remove方法"><span>Remove方法</span></a></h2>',28),n=[s];function c(r,h){return a(),l("div",null,n)}const m=e(p,[["render",c],["__file","map-hashmap.html.vue"]]),M=JSON.parse('{"path":"/java/collection/map-hashmap.html","title":"Map - HashMap 源码解析","lang":"zh-CN","frontmatter":{"order":4,"description":"Map - HashMap 源码解析 介绍 HashMap 是一个散列表，它存储的内容是键值对(key-value)映射，实现了 Map 接口，能够根据键的哈希值(HashCode)存储数据，具有很高的访问效率，最多允许一条键为 null 的值，不支持线程同步，即线程不安全。也不保证元素顺序，即根据需要容器可能会对元素重新哈希，元素的顺序就会被打乱，和...","head":[["meta",{"property":"og:url","content":"https://www.codermast.com/java/collection/map-hashmap.html"}],["meta",{"property":"og:site_name","content":"CoderMast编程桅杆"}],["meta",{"property":"og:title","content":"Map - HashMap 源码解析"}],["meta",{"property":"og:description","content":"Map - HashMap 源码解析 介绍 HashMap 是一个散列表，它存储的内容是键值对(key-value)映射，实现了 Map 接口，能够根据键的哈希值(HashCode)存储数据，具有很高的访问效率，最多允许一条键为 null 的值，不支持线程同步，即线程不安全。也不保证元素顺序，即根据需要容器可能会对元素重新哈希，元素的顺序就会被打乱，和..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-19T02:46:52.000Z"}],["meta",{"property":"article:author","content":"友人"}],["meta",{"property":"article:modified_time","content":"2024-04-19T02:46:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Map - HashMap 源码解析\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-19T02:46:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"友人\\",\\"url\\":\\"https://www.codermast.com\\",\\"email\\":\\"codermast@163.com\\"}]}"]]},"headers":[{"level":2,"title":"介绍","slug":"介绍","link":"#介绍","children":[]},{"level":2,"title":"常用API","slug":"常用api","link":"#常用api","children":[]},{"level":2,"title":"实现方式","slug":"实现方式","link":"#实现方式","children":[{"level":3,"title":"底层存储","slug":"底层存储","link":"#底层存储","children":[]}]},{"level":2,"title":"Get方法","slug":"get方法","link":"#get方法","children":[]},{"level":2,"title":"Put方法","slug":"put方法","link":"#put方法","children":[]},{"level":2,"title":"Remove方法","slug":"remove方法","link":"#remove方法","children":[]}],"git":{"createdTime":1712263409000,"updatedTime":1713494812000,"contributors":[{"name":"codermast","email":"codermast@qq.com","commits":4}]},"readingTime":{"minutes":2.12,"words":635},"filePathRelative":"java/collection/map-hashmap.md","localizedDate":"2024年4月4日","autoDesc":true,"excerpt":"\\n<h2>介绍</h2>\\n<p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射，实现了 Map 接口，能够根据键的哈希值(HashCode)存储数据，具有很高的访问效率，最多允许一条键为 null 的值，不支持线程同步，即线程不安全。也不保证元素顺序，即根据需要容器可能会对元素重新哈希，元素的顺序就会被打乱，和 TreeMap 有所区别。</p>\\n<p>HashMap 是 HashSet、HashTable、ConcurrentHashMap 这三种数据结构的基础。</p>\\n<h2>常用API</h2>\\n<ol>\\n<li>添加元素</li>\\n</ol>\\n<ul>\\n<li><code>put(K key, V value)</code>: 将指定的键值对存储到 HashMap 中。</li>\\n<li><code>putAll(Map&lt;? extends K, ? extends V&gt; m)</code>: 将另一个 Map 中的所有键值对添加到当前 HashMap 中。</li>\\n</ul>"}');export{m as comp,M as data};
