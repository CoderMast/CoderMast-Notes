import{_ as e,W as a,X as i,Y as s}from"./framework-a0cce298.js";const l="/assets/2023-06-26-23-47-32-22aecba2.png",t="/assets/2023-06-26-23-56-21-f1e3a84f.png",n="/assets/2023-06-27-00-11-32-ac3f80c8.png",r={},d=s('<h1 id="redis进阶-redis哨兵" tabindex="-1"><a class="header-anchor" href="#redis进阶-redis哨兵" aria-hidden="true">#</a> Redis进阶 - Redis哨兵</h1><div class="hint-container warning"><p class="hint-container-title">思考</p><p>slave 节点宕机恢复以后可以找 master 节点同步数据，那么 master 节点宕机怎么办？</p></div><h2 id="哨兵的作用和工作原理" tabindex="-1"><a class="header-anchor" href="#哨兵的作用和工作原理" aria-hidden="true">#</a> 哨兵的作用和工作原理</h2><h3 id="哨兵的作用" tabindex="-1"><a class="header-anchor" href="#哨兵的作用" aria-hidden="true">#</a> 哨兵的作用</h3><p>Redis 提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下：</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>监控</strong>：Sentinel 会不断检查您的 master 和 slave 是否按照预期工作</li><li><strong>自动故障恢复</strong>：如果 master 故障，Sentinel 会将一个 slave 提升为 master 。当故障实例恢复后也以新的 master 为主</li><li><strong>通知</strong>：Sentinel 充当 Redis 客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给 Redis 的客户端</li></ul><h3 id="服务状态监控" tabindex="-1"><a class="header-anchor" href="#服务状态监控" aria-hidden="true">#</a> 服务状态监控</h3><p>Sentinel 基于心跳机制监测服务状态，每隔 1 秒向集群的每个实例发送 ping 命令：</p><ul><li><p>主观下线：如果某 Sentinel 节点发现某实例未在规定时间响应，则认为该实例主观下线。</p></li><li><p>客观下线：若超过指定数量（quorum）的 sentinel 都认为该实例主观下线，则该实例客观下线。quorum 值最好超过 Sentinel 实例数量的一半。</p></li></ul><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="选举新的master" tabindex="-1"><a class="header-anchor" href="#选举新的master" aria-hidden="true">#</a> 选举新的master</h3><p>一旦发现master 故障，sentinel 需要在 slave 中选择一个作为新的 master ，选择依据是这样：</p><ul><li><p>首先会判断 slave 节点与 master 节点断开的时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该 slave 节点</p></li><li><p>然后判断 slave 节点的 slave-priority值，越小优先级越高，如果是 0 则永不参与选举</p></li><li><p>如果 slave-prority 一样，则判断 slave 节点的 offset 值，越大则说明数据越新，优先级越高</p></li><li><p>最后是判断 slave 节点的运行 id 大小，越小优先级越高</p></li></ul><h3 id="实现故障转移" tabindex="-1"><a class="header-anchor" href="#实现故障转移" aria-hidden="true">#</a> 实现故障转移</h3><p>当选中了其中一个 slave 为新的 master 后（例如slave1），故障转移的步骤如下：</p><ol><li><p>sentinel 给备选的 slave1 节点发送 slaveof no one 命令，让该节点成为 master</p></li><li><p>sentinel 给所有其他 slave 发送 slaveof 192.168.150.101 7002 命令，让这些 slave 成为新 master 的从节点，开始从新的 master 上同步数据。</p></li><li><p>最后 sentinel 将故障节点标记为 slave，当故障节点恢复后会自动成为新的 master 的 slave 节点</p></li></ol><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><p><strong>Sentinel 的三个作用是什么？</strong></p><ul><li>监控</li><li>故障转移</li><li>通知</li></ul><p><strong>Sentinel 如何判断一个 Redis 实例是否健康？</strong></p><ul><li><p>每隔 1 秒发送一次 ping 命令，如果超过一定时间没有相向则认为是主观下线</p></li><li><p>如果大多数 sentinel 都认为实例主观下线，则判定服务下线</p></li></ul><p><strong>故障转移步骤有哪些？</strong></p><ul><li>首先选定一个 slave 作为新的 master，执行 slaveof no one</li><li>然后让所有节点都执行 slaveof 新master</li><li>修改故障节点配置，添加 slaveof 新master</li></ul><h2 id="搭建哨兵集群" tabindex="-1"><a class="header-anchor" href="#搭建哨兵集群" aria-hidden="true">#</a> 搭建哨兵集群</h2><h2 id="redistemplate连接集群" tabindex="-1"><a class="header-anchor" href="#redistemplate连接集群" aria-hidden="true">#</a> RedisTemplate连接集群</h2>',27),o=[d];function p(h,c){return a(),i("div",null,o)}const m=e(r,[["render",p],["__file","redis-advance-sentinel.html.vue"]]);export{m as default};
