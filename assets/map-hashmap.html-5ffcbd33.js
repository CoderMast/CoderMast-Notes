import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as l,a as i}from"./app-d04446da.js";const o="/assets/2024-04-05-04-45-51-f23edad1.png",t="/assets/2024-04-05-04-46-00-06418e25.png",c={},d=i('<h1 id="map-hashmap-源码解析" tabindex="-1"><a class="header-anchor" href="#map-hashmap-源码解析" aria-hidden="true">#</a> Map - HashMap 源码解析</h1><h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h2><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射，实现了 Map 接口，能够根据键的哈希值(HashCode)存储数据，具有很高的访问效率，最多允许一条键位 null 的值，不支持线程同步，即线程不安全。也不保证元素顺序，即根据需要容器可能会对元素重新哈希，元素的顺序就会被打乱，和 TreeMap 有所区别。</p><p>HashMap 是 HashSet、HashTable、ConcurrentHashMap 这三种数据结构的基础。</p><h2 id="常用api" tabindex="-1"><a class="header-anchor" href="#常用api" aria-hidden="true">#</a> 常用API</h2><ol><li>添加元素</li></ol><ul><li><code>put(K key, V value)</code>: 将指定的键值对存储到 HashMap 中。</li><li><code>putAll(Map&lt;? extends K, ? extends V&gt; m)</code>: 将另一个 Map 中的所有键值对添加到当前 HashMap 中。</li></ul><ol start="2"><li>获取元素</li></ol><ul><li><code>get(Object key)</code>: 获取指定键对应的值。</li><li><code>getOrDefault(key, defaultValue)</code>：获取指定键对应的值，如果指定键不存在则返回 defaultValue</li><li><code>keySet()</code>: 返回 HashMap 中所有键组成的 Set 集合。</li><li><code>values()</code>: 返回 HashMap 中所有值组成的 Collection 集合。</li><li><code>entrySet()</code>: 返回 HashMap 中所有键值对组成的 Set 集合，每个元素都是 Map.Entry 对象，包含键值对信息。</li></ul><ol start="3"><li>删除元素</li></ol><ul><li><code>remove(Object key)</code>: 删除指定键对应的键值对。</li><li><code>clear()</code>: 清空 HashMap 中的所有键值对。</li></ul><ol start="4"><li>修改元素</li></ol><ul><li><code>replace(K key, V oldValue, V newValue)</code>: 将指定键对应的值从 oldValue 替换为 newValue。</li><li><code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>: 使用给定的函数对每个键值对执行替换操作。</li></ul><ol start="5"><li>判断元素</li></ol><ul><li><code>containsKey(Object key)</code>: 判断 HashMap 是否包含指定的键。</li><li><code>containsValue(Object value)</code>: 判断 HashMap 是否包含指定的值。</li><li><code>isEmpty()</code>: 判断 HashMap 是否为空。</li></ul><ol start="6"><li>其他操作</li></ol><ul><li><code>size()</code>: 返回 HashMap 中键值对的数量。</li></ul><h2 id="实现方式" tabindex="-1"><a class="header-anchor" href="#实现方式" aria-hidden="true">#</a> 实现方式</h2><h3 id="底层存储" tabindex="-1"><a class="header-anchor" href="#底层存储" aria-hidden="true">#</a> 底层存储</h3><p>HashMap 在底层实际上是一个可以扩容的动态数组，数组中存储的是发生冲突的链表节点的头结点，或者是红黑树的根节点。</p><ol><li>在 JDK8 之前是直接将发生冲突的元素通过链表存储起来。</li></ol><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>在 JDK8 之后，考虑到了链表的效率不高，根据链表的结点数量将其动态的调整为红黑树。</li></ol><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>::: important<br> [!caution]<br> 警告文字<br> :::</p>',25),s=[d];function r(n,h){return a(),l("div",null,s)}const f=e(c,[["render",r],["__file","map-hashmap.html.vue"]]);export{f as default};
