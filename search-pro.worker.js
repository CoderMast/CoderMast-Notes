const f=(e,s)=>{const n=e.toLowerCase(),o=s.toLowerCase(),a=[];let l=0,r=0;const u=(t,p=!1)=>{let c="";r===0?c=t.length>20?`… ${t.slice(-20)}`:t:p?c=t.length+r>100?`${t.slice(0,100-r)}… `:t:c=t.length>20?`${t.slice(0,20)} … ${t.slice(-20)}`:t,c&&a.push(c),r+=c.length,p||(a.push(["strong",s]),r+=s.length,r>=100&&a.push(" …"))};let i=n.indexOf(o,l);if(i===-1)return null;for(;i>=0;){const t=i+o.length;if(u(e.slice(l,i)),l=t,r>100)break;i=n.indexOf(o,l)}return r<100&&u(e.slice(l),!0),a};function $(e){return e}const h=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},d="__vueuse_ssr_handlers__";h[d]=h[d]||{};var g;(function(e){e.UP="UP",e.RIGHT="RIGHT",e.DOWN="DOWN",e.LEFT="LEFT",e.NONE="NONE"})(g||(g={}));var m=Object.defineProperty,y=Object.getOwnPropertySymbols,C=Object.prototype.hasOwnProperty,w=Object.prototype.propertyIsEnumerable,I=(e,s,n)=>s in e?m(e,s,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[s]=n,N=(e,s)=>{for(var n in s||(s={}))C.call(s,n)&&I(e,n,s[n]);if(y)for(var n of y(s))w.call(s,n)&&I(e,n,s[n]);return e};const Q={easeInSine:[.12,0,.39,0],easeOutSine:[.61,1,.88,1],easeInOutSine:[.37,0,.63,1],easeInQuad:[.11,0,.5,0],easeOutQuad:[.5,1,.89,1],easeInOutQuad:[.45,0,.55,1],easeInCubic:[.32,0,.67,0],easeOutCubic:[.33,1,.68,1],easeInOutCubic:[.65,0,.35,1],easeInQuart:[.5,0,.75,0],easeOutQuart:[.25,1,.5,1],easeInOutQuart:[.76,0,.24,1],easeInQuint:[.64,0,.78,0],easeOutQuint:[.22,1,.36,1],easeInOutQuint:[.83,0,.17,1],easeInExpo:[.7,0,.84,0],easeOutExpo:[.16,1,.3,1],easeInOutExpo:[.87,0,.13,1],easeInCirc:[.55,0,1,.45],easeOutCirc:[0,.55,.45,1],easeInOutCirc:[.85,0,.15,1],easeInBack:[.36,0,.66,-.56],easeOutBack:[.34,1.56,.64,1],easeInOutBack:[.68,-.6,.32,1.6]};N({linear:$},Q);const b=Object.entries,v=Object.keys,E=e=>e.reduce((s,{type:n})=>s+(n==="title"?50:n==="heading"?20:n==="custom"?10:1),0),_=(e,s)=>{var n;const o={};for(const[a,l]of b(s)){const r=((n=s[a.replace(/\/[^\\]*$/,"")])==null?void 0:n.title)||"",u=`${r?`${r} > `:""}${l.title}`,i=f(l.title,e);i&&(o[u]=[...o[u]||[],{type:"title",path:a,display:i}]),l.customFields&&b(l.customFields).forEach(([t,p])=>{p.forEach(c=>{const O=f(c,e);O&&(o[u]=[...o[u]||[],{type:"custom",path:a,index:t,display:O}])})});for(const t of l.contents){const p=f(t.header,e);p&&(o[u]=[...o[u]||[],{type:"heading",path:a+(t.slug?`#${t.slug}`:""),display:p}]);for(const c of t.contents){const O=f(c,e);O&&(o[u]=[...o[u]||[],{type:"content",header:t.header,path:a+(t.slug?`#${t.slug}`:""),display:O}])}}}return v(o).sort((a,l)=>E(o[a])-E(o[l])).map(a=>({title:a,contents:o[a]}))},P=JSON.parse("{\"/\":{\"/\":{\"title\":\"首页\",\"contents\":[{\"header\":\"是什么？\",\"slug\":\"是什么\",\"contents\":[\"该项目主要记录我这一路走来的Java学习笔记&工作总结，随着自己对某一项知识/技术的认知加深、也在不断的推翻完善中...\"]},{\"header\":\"为什么写？\",\"slug\":\"为什么写\",\"contents\":[\"学习笔记模块的内容很多是基于网上的内容转载/二创。那为什么还要写笔记？\",\"融入自己的想法\",\"笔记并不是全盘摘抄、更需要融入自己对这块知识点的看法。有些博客内容并不一定全对（存在错误、过时、好坏参半）、这些都需要自己重新整理与思考，才能更好的消化。\",\"更好的记忆与吸收知识\",\"把零散的、大篇幅的知识，逻辑梳理出来，重难点突出出来，从而更好的将知识记住。\",\"且知识需要不断复习、加深记忆。如果每次都从网上找，那每次都是新篇章\"]},{\"header\":\"参考与鸣谢\",\"slug\":\"参考与鸣谢\",\"contents\":[\"本项目的内容主要来自于自己的工作总结，读书笔记，以及对网上博客文章进行整理与总结。希望以最明了易懂的方式呈现出java技术架构，以便轻松应对面试\"]}]},\"/algorithm/\":{\"title\":\"算法题解\",\"contents\":[]},\"/408/cn/\":{\"title\":\"计算机网络\",\"contents\":[]},\"/408/cn/cn-tcp-3-4.html\":{\"title\":\"TCP三次握手和四次挥手图文详解\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"tcp连接\"]},{\"header\":\"什么是TCP连接？\",\"slug\":\"什么是tcp连接\",\"contents\":[\"TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议是同一层内另一个重要的传输协议。在因特网协议族中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。\"]},{\"header\":\"三次握手\",\"slug\":\"三次握手\",\"contents\":[\"三次握手是发生在TCP的连接过程中的，具体的步骤如下：\",\"客户端向服务端发起连接请求，发送请求报文段，将SYN同步位置为1，并且选择一个初始序列号seq=x，此时客户端由CLOSED(连接关闭)状态变为SYN-SENT(同步已发送状态)\",\"服务端接收到客户端发来的连接请求，此时同意进行连接时，向客户端发送确认报文段并且将SYN同步位和ACK都置为1，确认号ack=x+1，并且为自己也选一个初始序列号seq=y，确认报文段不携带数据，但是仍要占用一个序号，发送报文段的同时为该TCP连接分配对应的缓存和变量。此时服务端从LISTEN(监听)状态转变为SYN-RCVD(同步收到)状态。\",\"此时客户端接受到服务端发来的确认报文段，为了表示自己成功接受到报文段，还需要向服务端发送一个报文段，此时报文段的ACK位置为1，seq = x + 1，ack = y + 1，这里确认报文段也不携带数据，但是也要占用一个序号，此时发送报文段的同时为该TCP连接分配对应的缓存和变量。此时客户端从SYN-SENT(同步发送状态)转变为ESTABLISHED(已连接状态)。\",\"此时连接建立，TCP连接提供的是全双工信道，双方都可以进行数据的发送。此时服务端从SYN-RVCD(同步收到)状态转变为ESTABLISHED(已连接状态)。\",\"由于服务端的资源是在第二次握手时创建的，而客户端的资源是在第三次握手时创建的。这就使得服务器容易遭受SYN洪范攻击，即收到大量的连接请求而占用资源，导致正常的连接请求无法响应或者缓慢响应。 \"]},{\"header\":\"为什么需要三次握手而不是两次？或者四次？\",\"slug\":\"为什么需要三次握手而不是两次-或者四次\",\"contents\":[\"我们知道TCP连接是可靠的，但是网络信道并不可靠，即发送的数据有可能存在丢失或者延迟发送的可能，那么我们必须建立一套完整的机制保证数据能够可靠发送。\",\"假如是两次握手时，即客户端发送连接请求，服务端接受连接请求。这两次握手，那么就存在当客户端发送的连接请求报文段阻塞时，客户端久久未收到来自服务端的确认报文段，以为报文段丢失，则进行超时重传，再发一个连接请求报文段，如若第二次服务端接收到了请求，则做出响应，同意连接，发送确认报文段，并且建立连接。而此时网络信道恢复，第一次发送的报文段，成功传输到了服务端，服务端以为客户端建立了新的连接请求，则再次发送确认报文段，再次建立连接。而客户端收到重复的确认报文段以为是失效报文段，不以理睬。则现在客户端只有一个连接，服务端却有两个连接，让服务端的资源白白浪费。\",\"如果网络信道非常差，可能客户端发送很多请求以后，才能成功连接一次，但突然恢复以后，服务端又会收到大量的连接请求，会创建更多的连接，浪费更多的资源。\",\"如果是四次握手，那么对比于三次握手，肯定是更加的安全和可靠，但是三次握手已经足够保证连接可靠，四次握手将会导致连接时间变长，连接过程更加复杂，则浪费更多的资源。\",\"4次及4次以上，同理即可。\"]},{\"header\":\"四次挥手\",\"slug\":\"四次挥手\",\"contents\":[\"四次挥手是发生在TCP的连接释放过程中，具体的步骤如下：\",\"在客户端传送完数据以后，需要进行连接的释放，此时由客户端发送连接释放报文段，将FIN位置为1，表示请求连接断开，序号seq= u，u为此前传输数据包的报文段的序号 + 1，并且将客户端的TCP连接断开，则此时客户端就不能够再发送数据，但是服务端还可以向客户端发送数据，FIN报文段即使不携带任何数据，也要消耗掉一个序号。\",\"服务端收到来自客户端的连接释放报文段，表示同意断开连接，则立刻发送确认报文段，将ACK位置为1，表示同意断开连接，序号seq = v，v为服务端最后一次传输成功的报文段的序号 + 1，ack = u + 1，连接释放报文段也要消耗一个序号。此时仅仅只有客户端向服务端方向的连接断开，但是TCP连接是全双工的，服务端还可以向客户端发送数据，客户端也可以接受到数据。\",\"若服务端还有数据未完成传输，则可以继续进行传输数据，待数据传输完成以后，向客户端发送连接释放报文段，将FIN置为1，ACK置为1，seq = w，w为服务端成功传输最后一个数据包的序号 + 1，ack = u + 1，连接释放报文段也要占用一个序号。此时将服务端到客户端方向的连接断开。\",\"客户端收到来自服务端的连接释放报文段，需要做出回应，发送确认报文段，将其ACK位置为1，确认号ack = w + 1，seq = u + 1。此时TCP连接还未释放，需要经过时间等待计时器设置的时间后，客户端才进入连接关闭状态。 \",\"小结\",\"综上所述，TCP连接的3次握手和4次挥手归根结底是在保证连接可靠的情况下尽可能的减少资源的浪费。\"]}]},\"/408/co/\":{\"title\":\"计算机组成原理\",\"contents\":[]},\"/408/ds/\":{\"title\":\"数据结构\",\"contents\":[]},\"/database/mysql/\":{\"title\":\"MySQL 数据库\",\"contents\":[]},\"/database/redis/\":{\"title\":\"Redis 数据库\",\"contents\":[]},\"/java/base/java-base-final.html\":{\"title\":\"Final关键字的用法及加载时机\",\"contents\":[{\"header\":\"修饰变量\",\"slug\":\"修饰变量\",\"contents\":[\"final关键字修饰变量表示该变量一经初始化，则无法被修改。\",\"基本类型和String类型：这类一般都是通过字面量进行赋值，一经初始化无法改变。\",\"其他引用类型：这种类型我们无法改变常量指向的引用，但是仍然可以改变引用指向的对象，即引用指向的地址。\"]},{\"header\":\"静态常量和对象常量\",\"slug\":\"静态常量和对象常量\",\"contents\":[\"这里根据是否被static修饰可以将常量分为两类：\",\"被final和static关键字同时修饰的变量\",\"被final和static同时修饰的变量，我们称为静态常量，需要在类加载的时候进行初始化\",\"仅被final关键字修饰的变量\",\"仅被final修饰的变量，我们称为对象常量，需要在实例化的时候进行初始化\"]},{\"header\":\"常量的初始化方式\",\"slug\":\"常量的初始化方式\",\"contents\":[]},{\"header\":\"静态常量\",\"slug\":\"静态常量\",\"contents\":[\"声明时初始化\",\"构造方法初始化\"]},{\"header\":\"对象常量\",\"slug\":\"对象常量\",\"contents\":[\"声明时初始化\",\"构造方法初始化\",\"构造代码块初始化\"]},{\"header\":\"常量的初始化过程\",\"slug\":\"常量的初始化过程\",\"contents\":[\"final修饰的实例属性，在实例创建的时候才会赋值。\",\"static修饰的类属性，在类加载的准备阶段赋初值，初始化阶段赋值。\",\"static+final修饰的String类型或者基本类型常量，JVM规范是在初始化阶段赋值，但是HotSpot VM直接在准备阶段就赋值了，这里是通过字段的ConstantValue属性进行判断的。\",\"static+final修饰的其他引用类型常量，赋值步骤和第二点的流程是一样的。\",\"这里参考的是Archie_java这位大佬的文章进行总结的，你知道Java中final和static修饰的变量是在什么时候赋值的吗？_final修饰的变量什么时候赋值\"]},{\"header\":\"ConstantValue属性\",\"slug\":\"constantvalue属性\",\"contents\":[\"final static修饰的成员变量只有在其类型为ConstantValue时才会在准备阶段被赋予具体值。什么时候会将字段加上ConstantValue属性呢？\",\"ConstantValue需要满足2个条件：\",\"类型为基本类型或者String\",\"并且使用字面量的形式赋值\",\"必须是8种基本类型或者String类型，并且必须是通过字面量进行赋值，此时才会加上ConstantValue属性。\",\"我们对于这个类使用javap -verbose className指令查看字节码文件\",\"我们能够明显的看到只有\",\"这两个字段被加上了ConstrantValue属性，也就是只有这两个属性在初始化时直接进行赋值。\"]},{\"header\":\"修饰方法\",\"slug\":\"修饰方法\",\"contents\":[\"final关键字修饰方法，则表明该方法无法被子类重写，但是可以被子类继承子类也可以调用该方法。\"]},{\"header\":\"修饰类\",\"slug\":\"修饰类\",\"contents\":[\"final关键字修饰类，则表明该类无法被继承，如我们经常使用的java.lang.String类就是如此。\"]}]},\"/java/base/java-base-static.html\":{\"title\":\"Static关键字的五种用法详解\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Static的五种用法大致如下：\",\"修饰成员变量，使其成为类变量，也叫静态变量\",\"修饰成员方法，使其成为类方法\",\"修饰内部类，使其成为静态内部类\",\"静态代码块\",\"静态导包\",\"直接一点将，static关键字就是把属性和方法变为类相关，而不是实例相关。\"]},{\"header\":\"修饰成员变量\",\"slug\":\"修饰成员变量\",\"contents\":[\"被static关键字修饰的属性叫做静态属性，也叫类属性。顾名思义现在该属性为该类所有，而非该类实例化的对象所有，在类的加载阶段进行初始化。虽然使用类实例化的对象也能够调用该属性，但是该属性是属于类所有，所有该类的实例化对象和该类共享一个值，即操作的是同一个值。\",\"成员变量不给初始值的话，会进行默认初始化。\",\"被static修饰的属性，可以认为是属于类的，只要类进行加载以后，便可以使用类名.属性名进行调用。\"]},{\"header\":\"修饰成员方法\",\"slug\":\"修饰成员方法\",\"contents\":[\"被static关键字修饰的方法叫做类方法，修饰后的方法可以直接使类名.方法名调用，减少了实例化对象进行调用的资源消耗。\",\"简单的来说被static修饰的方法，可以认为是属于类的，只要类进行加载以后，则就可以进行使用。\",\"这里需要注意的是一个静态方法是不能够直接调用同类下的非静态方法，而同类下的非静态方法则可以调用同类下的静态方法。\"]},{\"header\":\"修饰内部类\",\"slug\":\"修饰内部类\",\"contents\":[\"被static修饰的内部类完全独立于其所在的外部类，不属于外部类的对象，可以认为两个类是完全没有关系的两个类。\",\"静态内部类可以包含静态成员，也可以包含非静态成员，但是在非静态内部类中不可以声明静态成员。\",\"静态类内部不可以访问外部类的实例成员，只能访问外部类的类成员，即使是静态内部类的实例方法也不能访问外部类的实例成员，只能访问外部类的静态成员\",\"外部类不可以定义为静态类，Java中静态类只有一种，那就是静态内部类，顶级类不能用static 修饰\",\"外部类如何调用静态内部类的属性和方法：\",\"外部类可以通过创建静态内部类实例的方法来调用静态内部类的非静态属性和方法\",\"外部类可以直接通过“ 外部类.内部类.属性（方法）” 的方式直接调用静态内部类中的静态属性和方法\",\"创建一个静态内部类实例：\",\"在外部类中：直接使用类名创建即可，内部类名 name = new 内部类构造器;\",\"在其他类中：使用外部类.内部类 name = new 外部类.内部构造器;\"]},{\"header\":\"静态代码块\",\"slug\":\"静态代码块\",\"contents\":[\"static修饰代码块的作用就是，在类加载以后进行执行这段代码。我们需要着重看一下具体的执行顺序。下面是一个简单的示例。\",\"该示例执行后的结果如下所示：\",\"则我们可以判断出执行的顺序为：\",\"静态代码块和静态属性的顺序执行\",\"非静态属性的执行\",\"方法的调用\",\"这里主要解释第一点，静态代码块和静态属性属于同一优先级，顺序执行。举个简单的例子即可理解，这里我们就无法调用到age属性\",\"非法向前引用\"]},{\"header\":\"静态导包\",\"slug\":\"静态导包\",\"contents\":[\"静态导包用法，将类的方法直接导入到当前类中，从而直接使用“方法名”即可调用类方法，更加方便。\",\"PrintMsg类\",\"Test类\",\"运行Test类中的main方法后，就能在控制台看到“hello codermast！”的一行输出。\",\"需要注意的是：导入的静态方法所处的类，不能和调用的类在同一个包下。\"]}]},\"/java/base/\":{\"title\":\"Java基础知识\",\"contents\":[]},\"/java/collection/\":{\"title\":\"Java集合框架\",\"contents\":[],\"customFields\":{\"0\":[\"Java\"]}},\"/java/jvm/\":{\"title\":\"JVM\",\"contents\":[]},\"/java/oop/java-base-basic-grammar.html\":{\"title\":\"Java基础 - 基本语法\",\"contents\":[]},\"/java/oop/java-base-oop.html\":{\"title\":\"Java基础 - 面向对象\",\"contents\":[]},\"/java/oop/\":{\"title\":\"Java面向对象\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"预览\",\"本章节主要总结了Java编程语言的基础知识，其中包含了：基础语法、面向对象、数据类型、关键字详解几个方面展开。\"]}],\"customFields\":{\"0\":[\"Java\"]}},\"/java/thread/\":{\"title\":\"Java多线程和并发\",\"contents\":[],\"customFields\":{\"0\":[\"Java\"]}},\"/408/\":{\"title\":\"408\",\"contents\":[]},\"/database/\":{\"title\":\"Database\",\"contents\":[]},\"/java/\":{\"title\":\"Java\",\"contents\":[]}}}");self.onmessage=({data:e})=>{self.postMessage(_(e.query,P[e.routeLocale]))};
//# sourceMappingURL=original.js.map
