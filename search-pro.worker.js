const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===F){const d=o[h-1];d<=s&&n.set(r,[e.get(c),d])}else{let d=u;for(let l=0;l<c.length;++l,++d){const p=c[l],f=i*d,g=f-i;let a=o[f];const m=Math.max(0,d-s-1),y=Math.min(i-1,d+s);for(let _=m;_<y;++_){const b=p!==t[_],z=o[g+_]+ +b,A=o[g+_+1]+1,w=o[f+_]+1,L=o[f+_+1]=Math.min(z,A,w);L<a&&(a=L)}if(a>s)continue t}W(e.get(c),t,s,n,o,d,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const d=u[c],l=e._fieldIds[c],p=o.get(l);if(p==null)continue;let f=p.size;const g=e._avgFieldLength[l];for(const a of p.keys()){if(!e._documentIds.has(a)){gt(e,l,a,s),f-=1;continue}const m=i?i(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!m)continue;const y=p.get(a),_=e._fieldLength.get(a)[l],b=at(y,f,e._documentCount,_,g,r),z=n*d*m*b,A=h.get(a);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(c):A.match[s]=[c]}else h.set(a,{score:z,terms:[t],match:{[s]:[c]}})}}return h},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((a,m)=>({...a,[m]:N(n.boost,m)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:d}={...J.weights,...i},l=e._index.get(t.term),p=B(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const a=t.fuzzy===!0?.2:t.fuzzy,m=a<1?Math.min(r,Math.round(t.term.length*a)):a;m&&(g=e._index.fuzzyGet(t.term,m))}if(f)for(const[a,m]of f){const y=a.length-t.term.length;if(!y)continue;g==null||g.delete(a);const _=d*a.length/(a.length+.3*y);B(e,t.term,a,_,m,o,u,h,p)}if(g)for(const a of g.keys()){const[m,y]=g.get(a);if(!y)continue;const _=c*a.length/(a.length+y);B(e,t.term,a,_,m,o,u,h,p)}return p},X=(e,t,s={})=>{if(typeof t!="string"){const d={...s,...t,queries:void 0},l=t.queries.map(p=>X(e,p,d));return Y(l,d.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(d=>h(d)).filter(d=>!!d).map(ft(i)).map(d=>At(e,d,i));return Y(c,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,d={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(d,e._storedFields.get(u)),(s.filter==null||s.filter(d))&&o.push(d)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},d)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new Et(d);l._documentCount=t,l._nextId=s,l._documentIds=k(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=k(u),l._avgFieldLength=i,l._storedFields=k(r),l._dirtCount=h||0,l._index=new C;for(const[p,f]of l._documentIds)l._idToShortId.set(f,p);for(const[p,f]of e){const g=new Map;for(const a of Object.keys(f)){let m=f[a];c===1&&(m=m.ds),g.set(parseInt(a,10),k(m))}l._index.set(p,g)}return l},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,d=!1)=>{let l="";i===0?l=c.length>20?`… ${c.slice(-20)}`:c:d?l=c.length+i>100?`${c.slice(0,100-i)}… `:c:l=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,l&&o.push(l),i+=l.length,d||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>100)break;h=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[d,l]=u.split(/[#@]/),{contents:p}=n[d]??={title:"",contents:[]};if(h)p.push([{type:"customField",key:d,index:l,display:i.map(f=>o.c.map(g=>j(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>j(o.h,g)).filter(g=>g!==null);if(f.length&&p.push([{type:c?"heading":"title",key:d,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const a=i.map(m=>j(g,m)).filter(m=>m!==null);a.length&&p.push([{type:"text",key:d,...c&&{anchor:l},display:a},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":584,\"nextId\":584,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-8daa1a0e#是什么\",\"2\":\"v-8daa1a0e#为什么\",\"3\":\"v-8daa1a0e#参考与鸣谢\",\"4\":\"v-8daa1a0e#联系我\",\"5\":\"v-70bc2959\",\"6\":\"v-2e25198a\",\"7\":\"v-7e25fb5f\",\"8\":\"v-14c69af4\",\"9\":\"v-884a0bbc\",\"10\":\"v-4165b7de\",\"11\":\"v-d440f426\",\"12\":\"v-9a72c4ae\",\"13\":\"v-1be8c5c4\",\"14\":\"v-1be8c5c4#什么是tcp连接\",\"15\":\"v-1be8c5c4#三次握手\",\"16\":\"v-1be8c5c4#为什么需要三次握手而不是两次-或者四次\",\"17\":\"v-1be8c5c4#四次挥手\",\"18\":\"v-9a72c470\",\"19\":\"v-0fac0cf6\",\"20\":\"v-0fac0cf6#时间复杂度\",\"21\":\"v-0fac0cf6#_1-单层循环\",\"22\":\"v-0fac0cf6#例子1-简单\",\"23\":\"v-0fac0cf6#例子2-中等难度\",\"24\":\"v-0fac0cf6#例子3-较难\",\"25\":\"v-0fac0cf6#_2-两层循环\",\"26\":\"v-0fac0cf6#例子1\",\"27\":\"v-0fac0cf6#例子2\",\"28\":\"v-0fac0cf6#_3-三层循环\",\"29\":\"v-0fac0cf6#例子\",\"30\":\"v-0fac0cf6#空间复杂度\",\"31\":\"v-01ac142e\",\"32\":\"v-01ac142e#基本概念\",\"33\":\"v-01ac142e#数据结构三要素\",\"34\":\"v-fd067b50\",\"35\":\"v-fd067b50#线性表定义和操作\",\"36\":\"v-fd067b50#顺序表\",\"37\":\"v-fd067b50#单链表\",\"38\":\"v-fd067b50#双链表\",\"39\":\"v-fd067b50#循环链表\",\"40\":\"v-fd067b50#静态链表\",\"41\":\"v-fd067b50#顺序表与链表的比较和选择\",\"42\":\"v-9a72bbf6\",\"43\":\"v-9a726960\",\"44\":\"v-dfa09558\",\"45\":\"v-dfa09558#概念\",\"46\":\"v-dfa09558#目的\",\"47\":\"v-dfa09558#分类\",\"48\":\"v-dfa09558#外键约束\",\"49\":\"v-dfa09558#语法\",\"50\":\"v-dfa09558#删除-更新行为\",\"51\":\"v-6c2bb6d0\",\"52\":\"v-0ca649bb\",\"53\":\"v-0ca649bb#字符串函数\",\"54\":\"v-0ca649bb#数值函数\",\"55\":\"v-0ca649bb#日期函数\",\"56\":\"v-0ca649bb#流程函数\",\"57\":\"v-b9856e14\",\"58\":\"v-b9856e14#逻辑存储结构\",\"59\":\"v-b9856e14#架构\",\"60\":\"v-b9856e14#内存结构\",\"61\":\"v-b9856e14#buffer-pool-缓冲池\",\"62\":\"v-b9856e14#change-buffer-更改缓冲区\",\"63\":\"v-b9856e14#log-buffer-日志缓冲区\",\"64\":\"v-b9856e14#adaptive-hash-index-自适应哈希索引\",\"65\":\"v-b9856e14#磁盘结构\",\"66\":\"v-b9856e14#system-tablespace-系统表空间\",\"67\":\"v-b9856e14#file-pre-table-tablespaces-独立表空间\",\"68\":\"v-b9856e14#general-tablespaces-通用表空间\",\"69\":\"v-b9856e14#undo-tablespaces-撤销表空间\",\"70\":\"v-b9856e14#temporary-tablespaces-临时表\",\"71\":\"v-b9856e14#double-write-buffer-files-双写缓冲区\",\"72\":\"v-b9856e14#redo-log-重做日志\",\"73\":\"v-b9856e14#后台线程\",\"74\":\"v-b9856e14#事务原理\",\"75\":\"v-b9856e14#redo-log-重做日志-1\",\"76\":\"v-b9856e14#undo-log\",\"77\":\"v-b1f4f0e2\",\"78\":\"v-b1f4f0e2#概念介绍\",\"79\":\"v-b1f4f0e2#mvcc\",\"80\":\"v-b1f4f0e2#当前读\",\"81\":\"v-b1f4f0e2#快照读\",\"82\":\"v-b1f4f0e2#实现原理\",\"83\":\"v-b1f4f0e2#undo-log\",\"84\":\"v-b1f4f0e2#undo-log-版本链\",\"85\":\"v-b1f4f0e2#readview-读视图\",\"86\":\"v-b1f4f0e2#版本链数据访问规则\",\"87\":\"v-8965f874\",\"88\":\"v-49034968\",\"89\":\"v-49034968#多表关系\",\"90\":\"v-49034968#一对一\",\"91\":\"v-49034968#一对多\",\"92\":\"v-49034968#多对多\",\"93\":\"v-49034968#多表查询\",\"94\":\"v-49034968#内连接\",\"95\":\"v-49034968#外连接\",\"96\":\"v-49034968#自连接\",\"97\":\"v-49034968#联合查询\",\"98\":\"v-49034968#子查询\",\"99\":\"v-49034968#标量子查询\",\"100\":\"v-49034968#列子查询\",\"101\":\"v-49034968#行子查询\",\"102\":\"v-49034968#表子查询\",\"103\":\"v-43c7fd75\",\"104\":\"v-43c7fd75#基本概念\",\"105\":\"v-43c7fd75#mysql的安装\",\"106\":\"v-43c7fd75#mysql版本\",\"107\":\"v-43c7fd75#数据库类型\",\"108\":\"v-43c7fd75#关系型数据库\",\"109\":\"v-43c7fd75#非关系型数据库\",\"110\":\"v-43c7fd75#mysql数据模型\",\"111\":\"v-60dc87cc\",\"112\":\"v-60dc87cc#索引概述\",\"113\":\"v-60dc87cc#概念\",\"114\":\"v-60dc87cc#优缺点\",\"115\":\"v-60dc87cc#索引结构\",\"116\":\"v-60dc87cc#二叉树\",\"117\":\"v-60dc87cc#红黑树\",\"118\":\"v-60dc87cc#b树\",\"119\":\"v-60dc87cc#b-树\",\"120\":\"v-60dc87cc#优化的b-树\",\"121\":\"v-60dc87cc#hash\",\"122\":\"v-60dc87cc#思考\",\"123\":\"v-60dc87cc#存储引擎支持\",\"124\":\"v-60dc87cc#索引分类\",\"125\":\"v-60dc87cc#回表查询\",\"126\":\"v-60dc87cc#思考题\",\"127\":\"v-60dc87cc#索引语法\",\"128\":\"v-60dc87cc#索引使用\",\"129\":\"v-60dc87cc#索引失效场景\",\"130\":\"v-60dc87cc#sql提示\",\"131\":\"v-60dc87cc#覆盖索引\",\"132\":\"v-60dc87cc#前缀索引\",\"133\":\"v-60dc87cc#单列-联合索引\",\"134\":\"v-60dc87cc#索引设计原则\",\"135\":\"v-789e275b\",\"136\":\"v-789e275b#介绍\",\"137\":\"v-789e275b#全局锁\",\"138\":\"v-789e275b#介绍-1\",\"139\":\"v-789e275b#一致性数据备份\",\"140\":\"v-789e275b#特点\",\"141\":\"v-789e275b#表级锁\",\"142\":\"v-789e275b#介绍-2\",\"143\":\"v-789e275b#_1-表锁\",\"144\":\"v-789e275b#_2-元数据锁\",\"145\":\"v-789e275b#_3-意向锁\",\"146\":\"v-789e275b#行级锁\",\"147\":\"v-789e275b#行锁\",\"148\":\"v-789e275b#间隙锁\",\"149\":\"v-789e275b#临键锁\",\"150\":\"v-43a7dcb0\",\"151\":\"v-10ff6421\",\"152\":\"v-4cf6c634\",\"153\":\"v-4cf6c634#介绍\",\"154\":\"v-4cf6c634#类型\",\"155\":\"v-4cf6c634#语法\",\"156\":\"v-4cf6c634#案例\",\"157\":\"v-4cf6c634#插入触发器\",\"158\":\"v-4cf6c634#更新触发器\",\"159\":\"v-4cf6c634#删除触发器\",\"160\":\"v-524a0e21\",\"161\":\"v-524a0e21#介绍和基本语法\",\"162\":\"v-524a0e21#介绍\",\"163\":\"v-524a0e21#操作语法\",\"164\":\"v-524a0e21#检查选项\",\"165\":\"v-524a0e21#更新及作用\",\"166\":\"v-524a0e21#视图的更新\",\"167\":\"v-524a0e21#视图的作用\",\"168\":\"v-78afab36\",\"169\":\"v-21ba2ec8\",\"170\":\"v-21ba2ec8#学习目录\",\"171\":\"v-21ba2ec8#参考资料\",\"172\":\"v-149399ac\",\"173\":\"v-149399ac#通用语法\",\"174\":\"v-149399ac#sql分类\",\"175\":\"v-149399ac#ddl语句\",\"176\":\"v-149399ac#数据库操作\",\"177\":\"v-149399ac#数据表操作\",\"178\":\"v-149399ac#字段操作\",\"179\":\"v-149399ac#dml语句\",\"180\":\"v-149399ac#添加数据\",\"181\":\"v-149399ac#修改数据\",\"182\":\"v-149399ac#删除数据\",\"183\":\"v-149399ac#dql语句\",\"184\":\"v-149399ac#dql语法\",\"185\":\"v-149399ac#查询类型\",\"186\":\"v-149399ac#基本查询\",\"187\":\"v-149399ac#条件查询\",\"188\":\"v-149399ac#聚合查询\",\"189\":\"v-149399ac#聚合函数\",\"190\":\"v-149399ac#分组查询\",\"191\":\"v-149399ac#排序查询\",\"192\":\"v-149399ac#分页查询\",\"193\":\"v-149399ac#执行顺序\",\"194\":\"v-149399ac#dcl语句\",\"195\":\"v-149399ac#用户控制\",\"196\":\"v-149399ac#权限控制\",\"197\":\"v-e01d4ed6\",\"198\":\"v-e01d4ed6#insert优化\",\"199\":\"v-e01d4ed6#批量插入\",\"200\":\"v-e01d4ed6#手动提交事务\",\"201\":\"v-e01d4ed6#主键顺序插入\",\"202\":\"v-e01d4ed6#大批量数据插入\",\"203\":\"v-e01d4ed6#primery-key优化\",\"204\":\"v-e01d4ed6#数据的组织方式\",\"205\":\"v-e01d4ed6#页分裂\",\"206\":\"v-e01d4ed6#页合并\",\"207\":\"v-e01d4ed6#主键设计原则\",\"208\":\"v-e01d4ed6#order-by优化\",\"209\":\"v-e01d4ed6#查询类别\",\"210\":\"v-e01d4ed6#举例说明\",\"211\":\"v-e01d4ed6#注意事项\",\"212\":\"v-e01d4ed6#group-by优化\",\"213\":\"v-e01d4ed6#查询类型\",\"214\":\"v-e01d4ed6#注意事项-1\",\"215\":\"v-e01d4ed6#limit优化\",\"216\":\"v-e01d4ed6#优化场景\",\"217\":\"v-e01d4ed6#举例说明-1\",\"218\":\"v-e01d4ed6#优化思路\",\"219\":\"v-e01d4ed6#count优化\",\"220\":\"v-e01d4ed6#优化思路-1\",\"221\":\"v-e01d4ed6#count的用法\",\"222\":\"v-e01d4ed6#update优化\",\"223\":\"v-e01d4ed6#注意事项-2\",\"224\":\"v-e01d4ed6#举例说明-2\",\"225\":\"v-21422c2d\",\"226\":\"v-21422c2d#sql执行频率\",\"227\":\"v-21422c2d#慢查询日志\",\"228\":\"v-21422c2d#profile分析\",\"229\":\"v-21422c2d#explain执行计划\",\"230\":\"v-9f994086\",\"231\":\"v-9f994086#mysql的体系结构\",\"232\":\"v-9f994086#存储引擎简介\",\"233\":\"v-9f994086#存储引擎特点\",\"234\":\"v-9f994086#innodb\",\"235\":\"v-9f994086#myisam\",\"236\":\"v-9f994086#memory\",\"237\":\"v-9f994086#存储引擎选择\",\"238\":\"v-79533b1a\",\"239\":\"v-79533b1a#介绍\",\"240\":\"v-79533b1a#基本语法\",\"241\":\"v-79533b1a#变量\",\"242\":\"v-79533b1a#系统变量\",\"243\":\"v-79533b1a#用户自定义变量\",\"244\":\"v-79533b1a#局部变量\",\"245\":\"v-79533b1a#if判断\",\"246\":\"v-79533b1a#参数\",\"247\":\"v-79533b1a#case\",\"248\":\"v-79533b1a#循环\",\"249\":\"v-79533b1a#while循环\",\"250\":\"v-79533b1a#repeat循环\",\"251\":\"v-79533b1a#loop循环\",\"252\":\"v-79533b1a#游标\",\"253\":\"v-79533b1a#条件处理程序\",\"254\":\"v-79533b1a#存储函数\",\"255\":\"v-13f32783\",\"256\":\"v-13f32783#事务操作\",\"257\":\"v-13f32783#事务的四大特性\",\"258\":\"v-13f32783#事务并发问题\",\"259\":\"v-13f32783#事务的隔离级别\",\"260\":\"v-2921a50f\",\"261\":\"v-2921a50f#大纲\",\"262\":\"v-2921a50f#redis入门\",\"263\":\"v-2921a50f#redis客户端\",\"264\":\"v-2921a50f#redis进阶\",\"265\":\"v-2921a50f#redis原理\",\"266\":\"v-2921a50f#参考资料\",\"267\":\"v-a164f926\",\"268\":\"v-20c7d348\",\"269\":\"v-20c7d348#缓存\",\"270\":\"v-20c7d348#缓存穿透\",\"271\":\"v-20c7d348#缓存雪崩\",\"272\":\"v-20c7d348#缓存击穿\",\"273\":\"v-20c7d348#缓存污染\",\"274\":\"v-20c7d348#缓存更新策略\",\"275\":\"v-20c7d348#主动更新策略\",\"276\":\"v-20c7d348#缓存淘汰策略\",\"277\":\"v-519b40a0\",\"278\":\"v-75198dab\",\"279\":\"v-10b5d72d\",\"280\":\"v-10b5d72d#本地进程缓存\",\"281\":\"v-10b5d72d#caffeine\",\"282\":\"v-10b5d72d#caffeine示例\",\"283\":\"v-10b5d72d#caffeine缓存驱逐策略\",\"284\":\"v-23873776\",\"285\":\"v-8846cbc0\",\"286\":\"v-8846cbc0#初识-lua\",\"287\":\"v-8846cbc0#快速入门\",\"288\":\"v-8846cbc0#变量\",\"289\":\"v-8846cbc0#循环\",\"290\":\"v-8846cbc0#条件\",\"291\":\"v-8846cbc0#函数\",\"292\":\"v-2e845f3e\",\"293\":\"v-2e845f3e#搭建主从架构\",\"294\":\"v-2e845f3e#_1-集群结构\",\"295\":\"v-2e845f3e#_2-准备实例和配置\",\"296\":\"v-2e845f3e#_3-启动\",\"297\":\"v-2e845f3e#_4-开启主从关系\",\"298\":\"v-2e845f3e#_5-测试\",\"299\":\"v-2e845f3e#数据同步原理\",\"300\":\"v-2e845f3e#全量同步\",\"301\":\"v-2e845f3e#增量同步\",\"302\":\"v-2e845f3e#总结\",\"303\":\"v-6a3d1060\",\"304\":\"v-6a3d1060#安装openresty\",\"305\":\"v-6a3d1060#_1-安装\",\"306\":\"v-6a3d1060#_2-启动和运行\",\"307\":\"v-6a3d1060#_3-备注\",\"308\":\"v-6a3d1060#openresty快速入门\",\"309\":\"v-6a3d1060#步骤1-修改nginx-conf文件\",\"310\":\"v-6a3d1060#步骤2-编写item-lua文件\",\"311\":\"v-6a3d1060#openresty获取请求参数\",\"312\":\"v-6a3d1060#封装http请求工具\",\"313\":\"v-6a3d1060#向tomcat发送http请求\",\"314\":\"v-6a3d1060#根据商品id对tomcat集群负载均衡\",\"315\":\"v-6a3d1060#redis缓存预热\",\"316\":\"v-6a3d1060#查询redis\",\"317\":\"v-6a3d1060#nginx本地缓存\",\"318\":\"v-b6a85f34\",\"319\":\"v-b6a85f34#rdb持久化\",\"320\":\"v-b6a85f34#aof持久化\",\"321\":\"v-b6a85f34#rdb与aof对比\",\"322\":\"v-9507482e\",\"323\":\"v-9507482e#哨兵的作用和工作原理\",\"324\":\"v-9507482e#哨兵的作用\",\"325\":\"v-9507482e#服务状态监控\",\"326\":\"v-9507482e#选举新的master\",\"327\":\"v-9507482e#实现故障转移\",\"328\":\"v-9507482e#小结\",\"329\":\"v-9507482e#搭建哨兵集群\",\"330\":\"v-9507482e#集群结构\",\"331\":\"v-9507482e#准备实例和配置\",\"332\":\"v-9507482e#启动\",\"333\":\"v-9507482e#测试\",\"334\":\"v-9507482e#redistemplate连接集群\",\"335\":\"v-8e986b64\",\"336\":\"v-3c43b28a\",\"337\":\"v-3c43b28a#搭建分片集群\",\"338\":\"v-3c43b28a#集群结构\",\"339\":\"v-3c43b28a#准备实例和配置\",\"340\":\"v-3c43b28a#启动\",\"341\":\"v-3c43b28a#创建集群\",\"342\":\"v-3c43b28a#测试\",\"343\":\"v-3c43b28a#散列插槽\",\"344\":\"v-3c43b28a#集群伸缩\",\"345\":\"v-3c43b28a#故障转移\",\"346\":\"v-3c43b28a#redistemplate访问分片集群\",\"347\":\"v-573ec1a9\",\"348\":\"v-53e49a9c\",\"349\":\"v-53e49a9c#简介\",\"350\":\"v-53e49a9c#官方地址\",\"351\":\"v-53e49a9c#快速入门\",\"352\":\"v-fcc65208\",\"353\":\"v-fcc65208#编写一个-redisconfig-配置类\",\"354\":\"v-fcc65208#自定义序列化方式\",\"355\":\"v-fcc65208#优化自定义序列化\",\"356\":\"v-fcc65208#小结\",\"357\":\"v-f84282fc\",\"358\":\"v-f84282fc#介绍\",\"359\":\"v-f84282fc#操作api\",\"360\":\"v-f84282fc#spring-boot-中使用\",\"361\":\"v-54dbf3e0\",\"362\":\"v-71e056ea\",\"363\":\"v-71e056ea#什么是nosql\",\"364\":\"v-71e056ea#nosql与sql\",\"365\":\"v-71e056ea#认识redis\",\"366\":\"v-71e056ea#安装redis\",\"367\":\"v-71e056ea#redis启动的三种方式\",\"368\":\"v-71e056ea#前台启动\",\"369\":\"v-71e056ea#后台启动\",\"370\":\"v-71e056ea#开机启动\",\"371\":\"v-71e056ea#redis客户端\",\"372\":\"v-71e056ea#命令行客户端\",\"373\":\"v-71e056ea#图形化客户端\",\"374\":\"v-71e056ea#编程语言客户端\",\"375\":\"v-74de4522\",\"376\":\"v-74de4522#string-字符串\",\"377\":\"v-74de4522#hash-哈希\",\"378\":\"v-74de4522#list-列表\",\"379\":\"v-74de4522#set-集合\",\"380\":\"v-74de4522#sortedset-有序集合\",\"381\":\"v-1366557b\",\"382\":\"v-21c9d5a4\",\"383\":\"v-21c9d5a4#语法\",\"384\":\"v-21c9d5a4#脚本命令\",\"385\":\"v-e750edf2\",\"386\":\"v-e750edf2#xadd\",\"387\":\"v-e750edf2#xtrim\",\"388\":\"v-e750edf2#xdel\",\"389\":\"v-e750edf2#xlen\",\"390\":\"v-e750edf2#xrange\",\"391\":\"v-e750edf2#xrevrange\",\"392\":\"v-e750edf2#xread\",\"393\":\"v-e750edf2#xgroup-create\",\"394\":\"v-e750edf2#xreadgroup-group\",\"395\":\"v-08e2c420\",\"396\":\"v-08e2c420#geo类型\",\"397\":\"v-08e2c420#bitmap类型\",\"398\":\"v-08e2c420#hyperloglog类型\",\"399\":\"v-06153dcd\",\"400\":\"v-7ffb8e61\",\"401\":\"v-7ffb8e61#用户空间与内核空间\",\"402\":\"v-7ffb8e61#阻塞io\",\"403\":\"v-7ffb8e61#非阻塞io\",\"404\":\"v-7ffb8e61#io多路复用\",\"405\":\"v-7ffb8e61#select\",\"406\":\"v-7ffb8e61#poll\",\"407\":\"v-7ffb8e61#epoll\",\"408\":\"v-7ffb8e61#事件通知机制\",\"409\":\"v-7ffb8e61#web服务流程\",\"410\":\"v-7ffb8e61#总结\",\"411\":\"v-7ffb8e61#信号驱动io\",\"412\":\"v-7ffb8e61#异步io\",\"413\":\"v-7ffb8e61#同步和异步\",\"414\":\"v-4202f375\",\"415\":\"v-4202f375#字符串对象string\",\"416\":\"v-4202f375#列表对象list\",\"417\":\"v-4202f375#哈希对象hash\",\"418\":\"v-4202f375#集合对象set\",\"419\":\"v-4202f375#有序集合对象zset\",\"420\":\"v-6dc1af78\",\"421\":\"v-6dc1af78#resp协议\",\"422\":\"v-6dc1af78#自定义客户端\",\"423\":\"v-3420ecf3\",\"424\":\"v-3420ecf3#动态字符串sds\",\"425\":\"v-3420ecf3#基本概念\",\"426\":\"v-3420ecf3#底层实现\",\"427\":\"v-3420ecf3#内存预分配\",\"428\":\"v-3420ecf3#sds小结\",\"429\":\"v-3420ecf3#整数集intset\",\"430\":\"v-3420ecf3#基本概念-1\",\"431\":\"v-3420ecf3#底层实现-1\",\"432\":\"v-3420ecf3#数组扩容\",\"433\":\"v-3420ecf3#intset小结\",\"434\":\"v-3420ecf3#字典-哈希表dict\",\"435\":\"v-3420ecf3#基本概念-2\",\"436\":\"v-3420ecf3#底层实现-2\",\"437\":\"v-3420ecf3#扩容收缩\",\"438\":\"v-3420ecf3#rehash\",\"439\":\"v-3420ecf3#dict小结\",\"440\":\"v-3420ecf3#压缩列表ziplist\",\"441\":\"v-3420ecf3#ziplistentry\",\"442\":\"v-3420ecf3#encoding编码\",\"443\":\"v-3420ecf3#连锁更新问题\",\"444\":\"v-3420ecf3#ziplist小结\",\"445\":\"v-3420ecf3#快速列表quicklist\",\"446\":\"v-3420ecf3#基本概念-3\",\"447\":\"v-3420ecf3#底层实现-3\",\"448\":\"v-3420ecf3#限制压缩\",\"449\":\"v-3420ecf3#quicklist小结\",\"450\":\"v-3420ecf3#跳表skiplist\",\"451\":\"v-3420ecf3#基本概念-4\",\"452\":\"v-3420ecf3#底层实现-4\",\"453\":\"v-3420ecf3#skiplist小结\",\"454\":\"v-79599d42\",\"455\":\"v-79599d42#删除策略\",\"456\":\"v-79599d42#淘汰策略\",\"457\":\"v-a98569f0\",\"458\":\"v-a98569f0#思考\",\"459\":\"v-a98569f0#网络模型\",\"460\":\"v-a98569f0#单线程网络模型\",\"461\":\"v-a98569f0#多线程网络模型\",\"462\":\"v-a98569f0#底层实现\",\"463\":\"v-38959971\",\"464\":\"v-38959971#为什么会设计redisobject\",\"465\":\"v-38959971#redisobject\",\"466\":\"v-38959971#编码方式\",\"467\":\"v-38959971#数据类型\",\"468\":\"v-38959971#命令处理\",\"469\":\"v-38959971#对象共享\",\"470\":\"v-38959971#引用计数器\",\"471\":\"v-bf1f86fe\",\"472\":\"v-ffb97496\",\"473\":\"v-724d33df\",\"474\":\"v-16722c46\",\"475\":\"v-6ce7b6da\",\"476\":\"v-a94b64b0\",\"477\":\"v-a94b64b0#题目描述\",\"478\":\"v-a94b64b0#题目地址\",\"479\":\"v-a94b64b0#解题思路\",\"480\":\"v-a94b64b0#_1-暴力三循环\",\"481\":\"v-a94b64b0#_2-固定指针-双循环指针\",\"482\":\"v-a94b64b0#代码示例\",\"483\":\"v-ebd584f6\",\"484\":\"v-ebd584f6#题目介绍\",\"485\":\"v-ebd584f6#题目地址\",\"486\":\"v-ebd584f6#解题思路\",\"487\":\"v-ebd584f6#代码\",\"488\":\"v-ebd584f6#方法1️⃣-模拟法\",\"489\":\"v-ebd584f6#复杂度分析\",\"490\":\"v-004e2d72\",\"491\":\"v-004e2d72#题目描述\",\"492\":\"v-004e2d72#思路分析\",\"493\":\"v-004e2d72#题目地址\",\"494\":\"v-004e2d72#代码示例\",\"495\":\"v-66839488\",\"496\":\"v-66839488#题目描述\",\"497\":\"v-66839488#题目地址\",\"498\":\"v-66839488#解题思路\",\"499\":\"v-66839488#方法1️⃣-递归法\",\"500\":\"v-66839488#代码code\",\"501\":\"v-66839488#复杂度分析\",\"502\":\"v-66839488#方法2️⃣-动态规划法1-使用dp数组进行记录\",\"503\":\"v-66839488#代码code-1\",\"504\":\"v-66839488#复杂度分析-1\",\"505\":\"v-66839488#方法3️⃣-动态规划法2-使用dp数组进行记录\",\"506\":\"v-66839488#代码code-2\",\"507\":\"v-66839488#复杂度分析-2\",\"508\":\"v-a28a27e0\",\"509\":\"v-a28a27e0#题目描述\",\"510\":\"v-a28a27e0#题目地址\",\"511\":\"v-a28a27e0#思路解析\",\"512\":\"v-a28a27e0#代码示例\",\"513\":\"v-71afee22\",\"514\":\"v-71afee22#题目描述\",\"515\":\"v-71afee22#题目地址\",\"516\":\"v-71afee22#思路分析\",\"517\":\"v-71afee22#代码示例\",\"518\":\"v-3f9113da\",\"519\":\"v-3f9113da#题目描述\",\"520\":\"v-3f9113da#题目地址\",\"521\":\"v-3f9113da#解题思路\",\"522\":\"v-3f9113da#方法1️⃣-递归法\",\"523\":\"v-3f9113da#代码code\",\"524\":\"v-3f9113da#复杂度分析\",\"525\":\"v-3f9113da#方法2️⃣-动态规划法1-使用dp数组进行记录\",\"526\":\"v-3f9113da#代码code-1\",\"527\":\"v-3f9113da#复杂度分析-1\",\"528\":\"v-3f9113da#方法3️⃣-动态规划法2-使用dp数组进行记录\",\"529\":\"v-3f9113da#代码code-2\",\"530\":\"v-3f9113da#复杂度分析-2\",\"531\":\"v-04c0516d\",\"532\":\"v-04c0516d#题目描述\",\"533\":\"v-04c0516d#题目地址\",\"534\":\"v-04c0516d#解题思路\",\"535\":\"v-04c0516d#代码实现\",\"536\":\"v-04c0516d#方法1-动态规划\",\"537\":\"v-04c0516d#复杂度分析\",\"538\":\"v-04c0516d#方法2-动态规划-优化版\",\"539\":\"v-04c0516d#复杂度分析-1\",\"540\":\"v-22c4764c\",\"541\":\"v-22c4764c#题目介绍\",\"542\":\"v-22c4764c#题目地址\",\"543\":\"v-22c4764c#题解\",\"544\":\"v-56c36d18\",\"545\":\"v-4d4cd2de\",\"546\":\"v-4d4cd2de#参考资料\",\"547\":\"v-5cc68e42\",\"548\":\"v-5cc68e42#章节分布\",\"549\":\"v-5cc68e42#参考资料\",\"550\":\"v-594b2522\",\"551\":\"v-5e01a32b\",\"552\":\"v-5e01a32b#_1-输入数据\",\"553\":\"v-5e01a32b#回归命令\",\"554\":\"v-4bbcf4f8\",\"555\":\"v-6f3dd303\",\"556\":\"v-77d179d8\",\"557\":\"v-77d179d8#_2-1-按分布范围分类\",\"558\":\"v-77d179d8#_2-2-按传输技术分类\",\"559\":\"v-77d179d8#_2-3-按拓扑结构分类\",\"560\":\"v-77d179d8#_2-4-按使用者分类\",\"561\":\"v-77d179d8#_2-5-按交换技术分类\",\"562\":\"v-77d179d8#_2-6-按传输介质分类\",\"563\":\"v-33201e36\",\"564\":\"v-33201e36#_1-1-计算机网络的概念\",\"565\":\"v-33201e36#_1-1-1-广义观点\",\"566\":\"v-33201e36#_1-1-2-资源共享观点\",\"567\":\"v-33201e36#_1-1-3-用户透明性观点\",\"568\":\"v-33201e36#_1-2-计算机网络的组成\",\"569\":\"v-33201e36#_1-2-1-从组成部分上看\",\"570\":\"v-33201e36#_1-2-2-从工作方式上看\",\"571\":\"v-33201e36#_1-2-3-从功能组成上看\",\"572\":\"v-33201e36#_1-3-计算机网络的功能\",\"573\":\"v-33201e36#_1-3-1-数据通信\",\"574\":\"v-33201e36#_1-3-2-资源共享\",\"575\":\"v-33201e36#_1-3-3-分布式处理\",\"576\":\"v-33201e36#_1-3-4-提高可靠性\",\"577\":\"v-33201e36#_1-3-5-负载均衡\",\"578\":\"v-3d008037\",\"579\":\"v-27d387b4\",\"580\":\"v-41c16c2a\",\"581\":\"v-d90a0794\",\"582\":\"v-6b2bf281\",\"583\":\"v-a94a8cca\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[2,12],\"2\":[2,39],\"3\":[1,25],\"4\":[1],\"5\":[1],\"6\":[1],\"7\":[1],\"8\":[1],\"9\":[1],\"10\":[2],\"11\":[1],\"12\":[1],\"13\":[1,1],\"14\":[2,14],\"15\":[1,55],\"16\":[3,46],\"17\":[1,54],\"18\":[1],\"19\":[2],\"20\":[1,14],\"21\":[2,18],\"22\":[2,33],\"23\":[2,37],\"24\":[2,43],\"25\":[2,8],\"26\":[1,28],\"27\":[1,30],\"28\":[2,5],\"29\":[1,37],\"30\":[1,11],\"31\":[2],\"32\":[1,35],\"33\":[1,51],\"34\":[2],\"35\":[1,49],\"36\":[1,170],\"37\":[1,85],\"38\":[1,1],\"39\":[1,1],\"40\":[1,1],\"41\":[1],\"42\":[1],\"43\":[1],\"44\":[2],\"45\":[1,3],\"46\":[1,3],\"47\":[1,33],\"48\":[1,3],\"49\":[1,21],\"50\":[2,50],\"51\":[2],\"52\":[2,3],\"53\":[1,31],\"54\":[1,15],\"55\":[1,27],\"56\":[1,38],\"57\":[2],\"58\":[1,49],\"59\":[1,8],\"60\":[1,4],\"61\":[3,27],\"62\":[3,27],\"63\":[3,30],\"64\":[4,14],\"65\":[1,1],\"66\":[3,12],\"67\":[5,10],\"68\":[3,20],\"69\":[3,6],\"70\":[3,3],\"71\":[5,6],\"72\":[3,14],\"73\":[1,49],\"74\":[1,24],\"75\":[3,18],\"76\":[2,37],\"77\":[2],\"78\":[1],\"79\":[1,15],\"80\":[1,18],\"81\":[1,15],\"82\":[1,26],\"83\":[2,17],\"84\":[3,18],\"85\":[2,23],\"86\":[1,41],\"87\":[2],\"88\":[2],\"89\":[1,6],\"90\":[1,11],\"91\":[1,10],\"92\":[1,12],\"93\":[1,18],\"94\":[1,18],\"95\":[1,19],\"96\":[1,22],\"97\":[1,22],\"98\":[1,26],\"99\":[1,10],\"100\":[1,18],\"101\":[1,6],\"102\":[1,3],\"103\":[2],\"104\":[1,29],\"105\":[1,10],\"106\":[1,11],\"107\":[1],\"108\":[1,10],\"109\":[1,35],\"110\":[1,1],\"111\":[2],\"112\":[1],\"113\":[1,10],\"114\":[1,17],\"115\":[1,21],\"116\":[1,10],\"117\":[1,8],\"118\":[1,16],\"119\":[1,8],\"120\":[1,5],\"121\":[1,38],\"122\":[1,17],\"123\":[1,14],\"124\":[1,41],\"125\":[1,14],\"126\":[1,51],\"127\":[1,36],\"128\":[1],\"129\":[1,61],\"130\":[1,23],\"131\":[1,20],\"132\":[1,44],\"133\":[2,16],\"134\":[1,36],\"135\":[2],\"136\":[1,16],\"137\":[1],\"138\":[1,10],\"139\":[1,20],\"140\":[1,23],\"141\":[1],\"142\":[1,17],\"143\":[2,21],\"144\":[2,54],\"145\":[2,42],\"146\":[1,34],\"147\":[1,14],\"148\":[1],\"149\":[1,4],\"150\":[2],\"151\":[2],\"152\":[2],\"153\":[1,21],\"154\":[1,9],\"155\":[1,30],\"156\":[1],\"157\":[1,30],\"158\":[1,31],\"159\":[1,34],\"160\":[2],\"161\":[1],\"162\":[1,15],\"163\":[1,36],\"164\":[1,25],\"165\":[1],\"166\":[1,17],\"167\":[1,10],\"168\":[2],\"169\":[2],\"170\":[1,22],\"171\":[1,28],\"172\":[2],\"173\":[1,14],\"174\":[1,22],\"175\":[1],\"176\":[1,23],\"177\":[1,74],\"178\":[1,24],\"179\":[1,14],\"180\":[1,20],\"181\":[1,16],\"182\":[1,15],\"183\":[1],\"184\":[1,16],\"185\":[1,17],\"186\":[1,17],\"187\":[1,45],\"188\":[1],\"189\":[1,25],\"190\":[1,30],\"191\":[1,23],\"192\":[1,23],\"193\":[1,23],\"194\":[1,8],\"195\":[1,32],\"196\":[1,46],\"197\":[2],\"198\":[1],\"199\":[1,11],\"200\":[1,15],\"201\":[1,17],\"202\":[1,46],\"203\":[2],\"204\":[1,32],\"205\":[1,51],\"206\":[1,17],\"207\":[1,10],\"208\":[2],\"209\":[1,17],\"210\":[1,34],\"211\":[1,16],\"212\":[2],\"213\":[1,9],\"214\":[1,8],\"215\":[1],\"216\":[1,5],\"217\":[1,7],\"218\":[1,4],\"219\":[1,10],\"220\":[1,11],\"221\":[1,41],\"222\":[1],\"223\":[1,11],\"224\":[1,4],\"225\":[2],\"226\":[1,31],\"227\":[1,51],\"228\":[1,31],\"229\":[1,78],\"230\":[2],\"231\":[1,31],\"232\":[1,31],\"233\":[1],\"234\":[1,36],\"235\":[1,16],\"236\":[1,39],\"237\":[1,29],\"238\":[2],\"239\":[1,19],\"240\":[1,43],\"241\":[1],\"242\":[1,33],\"243\":[1,34],\"244\":[1,28],\"245\":[1,10],\"246\":[1,23],\"247\":[1,20],\"248\":[1],\"249\":[1,15],\"250\":[1,21],\"251\":[1,21],\"252\":[1,20],\"253\":[1,26],\"254\":[1,31],\"255\":[2,6],\"256\":[1,25],\"257\":[1,23],\"258\":[1,18],\"259\":[1,33],\"260\":[2,1],\"261\":[1],\"262\":[1,10],\"263\":[1,5],\"264\":[1,14],\"265\":[1,8],\"266\":[1,26],\"267\":[2],\"268\":[2],\"269\":[1,15],\"270\":[1,28],\"271\":[1,15],\"272\":[1,36],\"273\":[1,43],\"274\":[1,34],\"275\":[1,29],\"276\":[1,24],\"277\":[2],\"278\":[2],\"279\":[2,20],\"280\":[1,46],\"281\":[1,63],\"282\":[1,38],\"283\":[1,46],\"284\":[2],\"285\":[2],\"286\":[2,13],\"287\":[1,15],\"288\":[1,76],\"289\":[1,47],\"290\":[1,21],\"291\":[1,57],\"292\":[2],\"293\":[1,17],\"294\":[2,19],\"295\":[2,86],\"296\":[2,26],\"297\":[2,46],\"298\":[2,16],\"299\":[1],\"300\":[1,62],\"301\":[1,46],\"302\":[1,30],\"303\":[2],\"304\":[1,60],\"305\":[2,72],\"306\":[2,73],\"307\":[2,95],\"308\":[1,7],\"309\":[3,39],\"310\":[3,27],\"311\":[1,34],\"312\":[1],\"313\":[1],\"314\":[1],\"315\":[1],\"316\":[1],\"317\":[1],\"318\":[2,29],\"319\":[1,129],\"320\":[1,84],\"321\":[1,30],\"322\":[2,8],\"323\":[1],\"324\":[1,24],\"325\":[1,21],\"326\":[1,37],\"327\":[1,33],\"328\":[1,31],\"329\":[1],\"330\":[1,17],\"331\":[1,74],\"332\":[1,15],\"333\":[1,5],\"334\":[1,96],\"335\":[2],\"336\":[2],\"337\":[1,19],\"338\":[1,23],\"339\":[1,86],\"340\":[1,40],\"341\":[1,75],\"342\":[1,24],\"343\":[1,58],\"344\":[1,87],\"345\":[1,42],\"346\":[1,30],\"347\":[2,48],\"348\":[2],\"349\":[1,18],\"350\":[1,6],\"351\":[1,82],\"352\":[2,65],\"353\":[3,65],\"354\":[1,51],\"355\":[1,31],\"356\":[1,31],\"357\":[2],\"358\":[1,39],\"359\":[1,42],\"360\":[3,81],\"361\":[2,32],\"362\":[2],\"363\":[1,20],\"364\":[1,41],\"365\":[1,31],\"366\":[1,21],\"367\":[1],\"368\":[1,13],\"369\":[1,29],\"370\":[1,43],\"371\":[1,8],\"372\":[1,42],\"373\":[1,44],\"374\":[1,13],\"375\":[2,15],\"376\":[2,87],\"377\":[2,39],\"378\":[2,34],\"379\":[2,36],\"380\":[2,59],\"381\":[2,48],\"382\":[2,11],\"383\":[1,8],\"384\":[1,24],\"385\":[3,111],\"386\":[1,22],\"387\":[1,12],\"388\":[1,8],\"389\":[1,7],\"390\":[1,17],\"391\":[1,17],\"392\":[1,18],\"393\":[2,29],\"394\":[2,25],\"395\":[2,15],\"396\":[1,65],\"397\":[1,38],\"398\":[1,47],\"399\":[2,53],\"400\":[2],\"401\":[1,49],\"402\":[1,18],\"403\":[1,28],\"404\":[1,74],\"405\":[1,79],\"406\":[1,81],\"407\":[1,66],\"408\":[1,47],\"409\":[1,6],\"410\":[1,42],\"411\":[1,18],\"412\":[1,16],\"413\":[1,6],\"414\":[2],\"415\":[1,42],\"416\":[1,24],\"417\":[1,49],\"418\":[1,37],\"419\":[1,70],\"420\":[2],\"421\":[1,120],\"422\":[1,124],\"423\":[2],\"424\":[1],\"425\":[1,47],\"426\":[1,75],\"427\":[1,26],\"428\":[1,21],\"429\":[1],\"430\":[1,38],\"431\":[1,10],\"432\":[1,162],\"433\":[1,10],\"434\":[2],\"435\":[1,42],\"436\":[1,75],\"437\":[1,59],\"438\":[1,110],\"439\":[1,26],\"440\":[1,8],\"441\":[1,40],\"442\":[1,60],\"443\":[1,34],\"444\":[1,40],\"445\":[1],\"446\":[1,20],\"447\":[1,102],\"448\":[1,62],\"449\":[1,11],\"450\":[1,15],\"451\":[1,12],\"452\":[1,20],\"453\":[1,21],\"454\":[2,65],\"455\":[1,58],\"456\":[1,98],\"457\":[2],\"458\":[1,34],\"459\":[1,47],\"460\":[1,39],\"461\":[1,23],\"462\":[1,167],\"463\":[2],\"464\":[1,34],\"465\":[1,47],\"466\":[1,45],\"467\":[1,45],\"468\":[1,19],\"469\":[1,51],\"470\":[1,22],\"471\":[1],\"472\":[2,1],\"473\":[2],\"474\":[2],\"475\":[2,1],\"476\":[2],\"477\":[1,36],\"478\":[1,3],\"479\":[1],\"480\":[2,9],\"481\":[2,57],\"482\":[1,50],\"483\":[2],\"484\":[1,19],\"485\":[1,2],\"486\":[1,5],\"487\":[1],\"488\":[2,25],\"489\":[1,5],\"490\":[2],\"491\":[1,38],\"492\":[1,15],\"493\":[1,3],\"494\":[1,24],\"495\":[2],\"496\":[1,30],\"497\":[1,2],\"498\":[1,27],\"499\":[2],\"500\":[1,13],\"501\":[1,7],\"502\":[4],\"503\":[1,34],\"504\":[1,5],\"505\":[4],\"506\":[1,30],\"507\":[1,6],\"508\":[2],\"509\":[1,35],\"510\":[1,3],\"511\":[1,31],\"512\":[1,28],\"513\":[2],\"514\":[1,77],\"515\":[1,3],\"516\":[1,34],\"517\":[1,29],\"518\":[2],\"519\":[1,23],\"520\":[1,3],\"521\":[1,25],\"522\":[2],\"523\":[1,13],\"524\":[1,7],\"525\":[4],\"526\":[1,27],\"527\":[1,5],\"528\":[4],\"529\":[1,32],\"530\":[1,6],\"531\":[2],\"532\":[1,42],\"533\":[1,3],\"534\":[1,35],\"535\":[1],\"536\":[2,30],\"537\":[2,5],\"538\":[4,31],\"539\":[2,6],\"540\":[2],\"541\":[1,64],\"542\":[1,7],\"543\":[1,44],\"544\":[2],\"545\":[1],\"546\":[1,18],\"547\":[2],\"548\":[1,4],\"549\":[1,16],\"550\":[2],\"551\":[2],\"552\":[2,5],\"553\":[1,7],\"554\":[2],\"555\":[2],\"556\":[2],\"557\":[3,15],\"558\":[2],\"559\":[3],\"560\":[3],\"561\":[3],\"562\":[3],\"563\":[3],\"564\":[2,6],\"565\":[2,3],\"566\":[3,13],\"567\":[3,8],\"568\":[3],\"569\":[3,26],\"570\":[3,8],\"571\":[4,12],\"572\":[3],\"573\":[3,8],\"574\":[4,9],\"575\":[3,4],\"576\":[4,2],\"577\":[4,11],\"578\":[2],\"579\":[2],\"580\":[2],\"581\":[2],\"582\":[2],\"583\":[1]},\"averageFieldLength\":[1.3938356164383565,28.760476721311242],\"storedFields\":{\"0\":{\"h\":\"首页\"},\"1\":{\"h\":\"是什么？\",\"t\":[\"该项目主要记录了本人在计算机技术学习道路上的收获和总结，自己对知识的学习笔记和总结，在步入职场以后也会记录自己在工作中遇到的各种问题，以及最后的解决方案，不仅如此还会记录自己在学习生活中的一些感想感悟，一些自己的思考和想法。\",\"随着时间的变迁，在不同的人生阶段对于同一个事物的看法是不同的，故此所有的知识点也仅代表了当前时刻自己对知识的掌握，会不断对知识进行迭代更新，以便于形成自己的知识体系。\"]},\"2\":{\"h\":\"为什么？\",\"t\":[\"提示\",\"目前在互联网上有很多大佬开源了他们的学习笔记，做的堪称完美，那么为什么不去直接使用他们整理好的学习笔记呢？为什么要反复造一些质量并不高的轮子呢？\",\"结合自己的想法\",\"做笔记其实并不是需要一步到位，十分完美且科学，如果以做出完美的笔记为目的，那么各类官方文档是不是更为权威呢？所有的技术和知识点笔记都是基于官方文档展开编写的，也不见得这些笔记没有价值。\",\"自己写总结的目的是为了记录自己对知识点的掌握程度，在未来的发展过程中不断的巩固，从而形成一个自己熟悉且较为完备的知识体系。盖好一栋大厦的关键在于打好地基，但后期的维护和补丁也不可或缺，做笔记并不是目的，目的是为了掌握知识点。\",\"更好的记忆与吸收知识\",\"知识只有被系统性的归纳起来，才能建立起知识体系，碎片化、零散化地去学习，会让自己陷入一种自我麻痹且极度自信的状态，会让你产生一种所有知识都懂假象，随便提起来一些知识点也都能说上两嘴，但是不能深究，一旦深入一点，就好像缓存穿透一般，所有的刨根问底都造成了真实伤害。\",\"缓存穿透\",\"是指查询一个根本不存在的数据，缓存层和持久层都不会命中。在日常工作中出于容错的考虑，如果从持久层查不到数据则不写入缓存层，缓存穿透将导致不存在的数据每次请求都要到持久层去查询，失去了缓存保护后端持久的意义。\"]},\"3\":{\"h\":\"参考与鸣谢\",\"t\":[\"本项目中的内容除了自己的日常学习、工作总结，也不乏来源于互联网，并非所有内容都是本人原创，但也绝不是简单的复制粘帖，本人根据互联网上的资料加上本人对知识的理解，总结的一份有自己思考成分的笔记。\",\"在对参考的部分，会给出参考的地址，方便自己或者读者进行知识追溯，也希望其他人在对本人文章进行参考时，也加上文章的来源，保证读者能够对知识点进行刨根问题，追究源头。\",\"也希望读者朋友们保持一个批判性思维，本人所写的所有内容也并非100%正确，可能也会有对知识的误解和遗漏、错误等情况，希望读者们不吝赐教，能够指出文章中一些能够完美，但时并未做到完美的点，也能够后续的读者展现出更高质量的文章，非常感谢大家的支持！\"]},\"4\":{\"h\":\"联系我\"},\"5\":{\"h\":\"算法题解\"},\"6\":{\"h\":\"数据库\"},\"7\":{\"h\":\"前端系列\"},\"8\":{\"h\":\"Java\"},\"9\":{\"h\":\"题解\"},\"10\":{\"h\":\"Spring 系列\"},\"11\":{\"h\":\"工具使用\"},\"12\":{\"h\":\"计算机网络\"},\"13\":{\"h\":\"TCP三次握手和四次挥手图文详解\",\"t\":[\"tcp连接\"]},\"14\":{\"h\":\"什么是TCP连接？\",\"t\":[\"TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议是同一层内另一个重要的传输协议。在因特网协议族中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。\"]},\"15\":{\"h\":\"三次握手\",\"t\":[\"三次握手是发生在TCP的连接过程中的，具体的步骤如下：\",\"客户端向服务端发起连接请求，发送请求报文段，将SYN同步位置为1，并且选择一个初始序列号seq=x，此时客户端由CLOSED(连接关闭)状态变为SYN-SENT(同步已发送状态)\",\"服务端接收到客户端发来的连接请求，此时同意进行连接时，向客户端发送确认报文段并且将SYN同步位和ACK都置为1，确认号ack=x+1，并且为自己也选一个初始序列号seq=y，确认报文段不携带数据，但是仍要占用一个序号，发送报文段的同时为该TCP连接分配对应的缓存和变量。此时服务端从LISTEN(监听)状态转变为SYN-RCVD(同步收到)状态。\",\"此时客户端接受到服务端发来的确认报文段，为了表示自己成功接受到报文段，还需要向服务端发送一个报文段，此时报文段的ACK位置为1，seq = x + 1，ack = y + 1，这里确认报文段也不携带数据，但是也要占用一个序号，此时发送报文段的同时为该TCP连接分配对应的缓存和变量。此时客户端从SYN-SENT(同步发送状态)转变为ESTABLISHED(已连接状态)。\",\"此时连接建立，TCP连接提供的是全双工信道，双方都可以进行数据的发送。此时服务端从SYN-RVCD(同步收到)状态转变为ESTABLISHED(已连接状态)。\",\"由于服务端的资源是在第二次握手时创建的，而客户端的资源是在第三次握手时创建的。这就使得服务器容易遭受SYN洪范攻击，即收到大量的连接请求而占用资源，导致正常的连接请求无法响应或者缓慢响应。\"]},\"16\":{\"h\":\"为什么需要三次握手而不是两次？或者四次？\",\"t\":[\"我们知道TCP连接是可靠的，但是网络信道并不可靠，即发送的数据有可能存在丢失或者延迟发送的可能，那么我们必须建立一套完整的机制保证数据能够可靠发送。\",\"假如是两次握手时，即客户端发送连接请求，服务端接受连接请求。这两次握手，那么就存在当客户端发送的连接请求报文段阻塞时，客户端久久未收到来自服务端的确认报文段，以为报文段丢失，则进行超时重传，再发一个连接请求报文段，如若第二次服务端接收到了请求，则做出响应，同意连接，发送确认报文段，并且建立连接。而此时网络信道恢复，第一次发送的报文段，成功传输到了服务端，服务端以为客户端建立了新的连接请求，则再次发送确认报文段，再次建立连接。而客户端收到重复的确认报文段以为是失效报文段，不以理睬。则现在客户端只有一个连接，服务端却有两个连接，让服务端的资源白白浪费。\",\"如果网络信道非常差，可能客户端发送很多请求以后，才能成功连接一次，但突然恢复以后，服务端又会收到大量的连接请求，会创建更多的连接，浪费更多的资源。\",\"如果是四次握手，那么对比于三次握手，肯定是更加的安全和可靠，但是三次握手已经足够保证连接可靠，四次握手将会导致连接时间变长，连接过程更加复杂，则浪费更多的资源。\",\"4次及4次以上，同理即可。\"]},\"17\":{\"h\":\"四次挥手\",\"t\":[\"四次挥手是发生在TCP的连接释放过程中，具体的步骤如下：\",\"在客户端传送完数据以后，需要进行连接的释放，此时由客户端发送连接释放报文段，将FIN位置为1，表示请求连接断开，序号seq= u，u为此前传输数据包的报文段的序号 + 1，并且将客户端的TCP连接断开，则此时客户端就不能够再发送数据，但是服务端还可以向客户端发送数据，FIN报文段即使不携带任何数据，也要消耗掉一个序号。\",\"服务端收到来自客户端的连接释放报文段，表示同意断开连接，则立刻发送确认报文段，将ACK位置为1，表示同意断开连接，序号seq = v，v为服务端最后一次传输成功的报文段的序号 + 1，ack = u + 1，连接释放报文段也要消耗一个序号。此时仅仅只有客户端向服务端方向的连接断开，但是TCP连接是全双工的，服务端还可以向客户端发送数据，客户端也可以接受到数据。\",\"若服务端还有数据未完成传输，则可以继续进行传输数据，待数据传输完成以后，向客户端发送连接释放报文段，将FIN置为1，ACK置为1，seq = w，w为服务端成功传输最后一个数据包的序号 + 1，ack = u + 1，连接释放报文段也要占用一个序号。此时将服务端到客户端方向的连接断开。\",\"客户端收到来自服务端的连接释放报文段，需要做出回应，发送确认报文段，将其ACK位置为1，确认号ack = w + 1，seq = u + 1。此时TCP连接还未释放，需要经过时间等待计时器设置的时间后，客户端才进入连接关闭状态。\",\"小结\",\"综上所述，TCP连接的3次握手和4次挥手归根结底是在保证连接可靠的情况下尽可能的减少资源的浪费。\"]},\"18\":{\"h\":\"计算机组成原理\"},\"19\":{\"h\":\"2.算法复杂度问题\"},\"20\":{\"h\":\"时间复杂度\",\"t\":[\"这里主要总结数据结构中时间复杂度的计算方法，在学习过程中，参考了B站的数据结构——时间复杂度计算这个视频，可以在看完视频后，再阅读本文，效果更佳。\",\"根据循环的层次不同，分为三个类别：\",\"单层循环\",\"两层循环\",\"多层循环\",\"这里一一进行说明。\"]},\"21\":{\"h\":\"1.单层循环\",\"t\":[\"解决思路\",\"列出循环次数 t 以及每轮循环的变化值。\",\"找到 t 与 i 的关系\",\"确定循环的停止条件。\",\"联立两式，解方程。\",\"写结果。\",\"单层循环相对来讲是比较简单的，但是这里还是想整理成方法论，在做题过程中，不容易出错。下面我们来具体举例说明。\"]},\"22\":{\"h\":\"例子1：简单\",\"t\":[\"int func(int n){ int i = 0; while (i < n){ i ++; } return i; } \",\"我们根据方法论，具体操作如下：\",\"列出循环次数 t 以及每轮循环的变化值。\",\"t\",\"0\",\"1\",\"2\",\"3\",\"...\",\"k\",\"i\",\"0\",\"1\",\"2\",\"3\",\"...\",\"n - 1\",\"找到 t 与 i 的关系\",\"此时 t 和 i 的关系式为 i = t\",\"确定循环的停止条件。\",\"循环结束的条件为，i = n\",\"联立两式，解方程。\",\"联立即可得到 t = n\",\"写结果\",\"即一共循环了 n 次\"]},\"23\":{\"h\":\"例子2：中等难度\",\"t\":[\"int func(int n){ int i = n * n; while (i != 1){ i /= 2; } return i; } \",\"同样，我们根据方法论的步骤进行解答：\",\"列出循环次数 t 以及每轮循环的变化值。\",\"t\",\"0\",\"1\",\"2\",\"3\",\"...\",\"k\",\"i\",\"n2\",\"2n2​\",\"4n2​\",\"8n2​\",\"...\",\"2kn2​\",\"找到 t 与 i 的关系\",\"i = 2kn2​\",\"确定循环的停止条件。\",\"当 i = 1 时退出循环\",\"联立两式，解方程。\",\"i = 2kn2​ = 1 , 解得 k = 2log2​n\",\"写结果。\",\"那么对应的时间复杂度就是 O(log2​n)\"]},\"24\":{\"h\":\"例子3：较难\",\"t\":[\"int func(int n){ int i = 0; int sum = 0; while (sum < n){ sum += ++i; // 这里实际上就可以拆分为两条语句。 // 1. ++i; 这里是先 ++ 再返回。 // 2. sum = sum + i; } return i; } \",\"列出循环次数 t 以及每轮循环的变化值。\",\"t\",\"0\",\"1\",\"2\",\"3\",\"...\",\"T\",\"i\",\"0\",\"1\",\"2\",\"3\",\"...\",\"I\",\"sum\",\"0\",\"1\",\"3\",\"6\",\"...\",\"t=0∑I​\",\"找到 t 与 i 的关系\",\"t = i\",\"确定循环的停止条件。\",\"sum >= n\",\"联立两式，解方程。\",\"t=0∑k​=n=2i∗(i+1)​，解得i=2−1±1+8n​​\",\"写结果。\",\"t = i，则对应的时间复杂度为 O(n21​)\"]},\"25\":{\"h\":\"2.两层循环\",\"t\":[\"解题思路\",\"列出外层循环中 i 的变化量。\",\"列出内层语句的执行次数。\",\"求和，写结果。\"]},\"26\":{\"h\":\"例子1\",\"t\":[\"int func(int n,int m){ for(int i = 0;i < n;i ++){ for(int j = 0;j < m;j ++){ arr[i][j] = 0; } } return n * m; } \",\"列出外层循环中 i 的变化量。\",\"和步骤2合并一起\",\"列出内层语句的执行次数。\",\"i\",\"0\",\"1\",\"2\",\"3\",\"...\",\"n - 1\",\"j\",\"m\",\"m\",\"m\",\"m\",\"...\",\"m\",\"求和，写结果。\",\"一共执行的次数T = [(n - 1) - 0 + 1] * m = n * m;\",\"对应的时间复杂度为 O(nm)\"]},\"27\":{\"h\":\"例子2\",\"t\":[\"int func(int n){ for(int i = 0;i < n;i ++){ for(int j = 0;j < i;j ++){ arr[i][j] = 0; } } return n; } \",\"列出外层循环中 i 的变化量。\",\"和步骤2合并一起\",\"列出内层语句的执行次数。\",\"i\",\"0\",\"1\",\"2\",\"3\",\"...\",\"n - 1\",\"j\",\"0\",\"1\",\"2\",\"3\",\"...\",\"i\",\"求和，写结果。\",\"一共执行的次数 $ T = \\\\frac {n * [0 + (n - 1)]} {2} $\",\"则对应的时间复杂度 O(n2)\"]},\"28\":{\"h\":\"3.三层循环\",\"t\":[\"解题思路\",\"方法1: 抽象为计算三维体积\",\"方法2: 列式求和\"]},\"29\":{\"h\":\"例子\",\"t\":[\"int func(int n){ for(int i = 1;i <= n;i ++){ for(int j = 1;j <= i;j++){ for(int k = 1;k <= j;k++){ arr[i][j][k] = 0; } } } return n; } \",\"第一种方法我目前也没有理解，具体是怎么做的。\",\"计算体积\",\"体积公式 V=31​s∗h\",\"第二种方法:\",\"i=1∑n​j=1∑i​k=1∑j​1=i=1∑n​j=1∑i​j=i=1∑n​2i(i+1)​=21​(i=1∑n​i2+i=1∑n​i)=21​(6n(n+1)(2n+1)​+2n(n+1)​)=6n3+3n2+2n​\",\"则对应的时间复杂度为 O(n3)\"]},\"30\":{\"h\":\"空间复杂度\",\"t\":[\"空间复杂度是很容易判断的，这里主要对递归操作进行说明。\",\"每次递归时，调用一次递归函数，则为 O(n)\",\"每次递归时，调用两次递归函数，则为 O(n2)\",\"......\",\"以此类推即可。\"]},\"31\":{\"h\":\"1.数据结构的基本概念\"},\"32\":{\"h\":\"基本概念\",\"t\":[\"数据：数据是信息的载体，是描述客观事物属性的数、字符及所能输入到计算机中并能被计算机程序识别和处理的符号的集合。\",\"数据元素：是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。如类实例化的一个对象就是数据元素，不可分割。\",\"数据对象：数据对象是具有相同性质的数据元素的集合，是数据的一个子集。即同属于一个类的对象实例。\",\"数据类型：数据类型是一个值的集合和定义在此集合上的一组操作的总称。\",\"原子类型：其值不可再分的数据类型。————基本数据类型。\",\"结构类型：其值可以在分解为若干变量的数据类型。————对象实例内的各个属性值。\",\"抽象数据类型：抽象数据组织及与之相关的操作。————仅仅定义，没有实现。如栈、队列的定义。\",\"数据结构：是相互之间存在的一种或多种特定关系的数据元素的集合。在任何时候，数据都不是独立存在的，他们存在着某种关系。\"]},\"33\":{\"h\":\"数据结构三要素\",\"t\":[\"数据结构包含三个要素，分别为：逻辑结构、存储结构、数据的运算。\",\"数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的视线依赖于所采用的存储结构。\",\"逻辑结构：是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。主要分为 线性结构 和 非线性结构 两种。\",\"集合：结构中元素同属于同一个集合，别无其他关系。\",\"线性结构：结构中的数据元素之间只存在一对一的关系。\",\"树形结构：结构中的数据元素之间存在一对多的关系。\",\"图状结构或网状结构：结构中的数据元素之间存在多对多的关系。\",\"存储结构：是指数据结构在计算机中的表示，也称为物理结构。主要的存储结构有：顺序存储、链式存储、索引存储、散列存储。\",\"顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。\",\"链式存储：不要求逻辑上相邻的元素在物理位置上也相邻，只要求逻辑相邻，借助指针存储地址来表示元素之间的逻辑关系。\",\"索引存储：在存储元素信息时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式为 （关键字、地址）。\",\"散列存储：根据元素的关键字直接计算出该元素的存储位置，又称为哈希 Hash 存储。\",\"数据的运算：施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。\"]},\"34\":{\"h\":\"3.线性表\"},\"35\":{\"h\":\"线性表定义和操作\",\"t\":[\"线性表\",\"线性表是具有相同数据类型的n个数据元素的有限集序列，其中n为表长，当n=0时线性表是一个空表。若用L命名线性表，其一般表示为：L = ( a1 ,a2 ,...,ai ,ai+1 ,...,an )\",\"线性表的基本操作：\",\"InitList(&L):初始化表，构造一个空的线性表。\",\"Length(L):求表长，返回线性表L的长度，即L中元素的个数。\",\"LocateElem(L,e):按值查找操作，在表L中查找具有给定关键字值的元素。\",\"GetElem(L,i):按位查找操作。获取表L中第i个位置的数据元素的值。\",\"ListInsert(&L,i,e):插入操作，在表L中的第i个位置上插入指定的元素e.\",\"ListDelete(&L,i,&e):删除操作，删除表L中的第i个位置的元素，并用e返回删除元素的值。\",\"PrintList(L):输出操作，按前后顺序输出线性表L的所有元素值。\",\"Empty(L):判空操作，若L表为空，则返回True，否则返回false。\",\"DestroyList(&L):销毁操作，销毁线性表，并释放线性表L所占用的内存空间。\"]},\"36\":{\"h\":\"顺序表\",\"t\":[\"顺序表\",\"线性表的顺序结构又称为顺序表，他是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理上也相邻。\",\"线性表的顺序存储类型描述：\",\"ElemType 是线性表的元素类型\",\"#define MaxSize 50 // 定义线性表的最大容量 typedef struct{ ElemType data[MaxSize]; // 顺序表的元素 int length; // 顺序表当前的长度 }SqList; // 顺序表的类型定义 \",\"顺序表的特点\",\"顺序表中元素的逻辑顺序和实际的物理顺序相同，所以插入和删除操作需要移动大量元素。\",\"顺序表中第一个元素存储在线性表的起始位置，第 i 个元素的存储位置后面紧接着存储的是第 i + 1 个元素，称 i 为元素 ai 在线性表中的位序。\",\"顺序表最重要的特点是支持随机访问，即通过首地址和元素需要可在 O(1) 时间内找到指定的元素。\",\"通常情况下使用数组来表述线性表的顺序存储结构。\",\"顺序表的存储密度高，每个结点只存储数据元素。\",\"注意\",\"线性表中元素的位序是从 1 开始的，而数组中元素的下标是从 0 开始的。\",\"顺序表上基本操作的实现：\",\"说明\",\"这里实现了顺序表的插入、删除、按值查询、按序号查询操作的算法。\",\"插入操作\",\"在顺序表 L 的第 i 个位置插入新元素 e 。若 i 的位置不合法，则返回 fasle，表示插入失败。否则将第 i 个元素及其后的所有元素依次往后移动一个位置，腾出一个空位置插入新元素 e，顺序表长度增加 1 ，插入成功，返回 true。\",\"bool ListInsert(SqList &L, int i, ElemType e){ // 判断 i 的范围是否合法 if (i < 1 || i >= L.length){ return false; } // 当存储空间已满时，则无法插入 if (L.length >= MaxSize){ return false; } // 将第 i 个元素及之后的元素后移 for (int j = L.length; j >= i; j--){ L.data[j] = L.data[j - 1]; } // 在位置 i 处放入 e L.data[i - 1] = e; // 线性表长度加 1 L.length ++; return true; } \",\"最好情况：在表头插入（即 i = n + 1），元素后移语句将不执行，时间复杂度为 O(1)\",\"最坏情况：在表头插入（即 i = 1），元素后移语句将执行 n 次，时间复杂度为 O(n)\",\"平均情况：假设 pi​ 是在第 i 个位置上插入的一个结点的概率，则在长度为 n 的线性表中插入一个结点时，所需要移动结点的平均次数为 i=1∑n+1​pi​(n−i+1)=i=1∑n+1​n+11​∗(n−i+1)=n+11​i=1∑n+1​(n−i+1)=n+11​2n(n+1)​=2n​ ，则平均时间复杂度为 O(n)\",\"删除操作\",\"删除顺序表 L 中第 i 个位置的元素，用引用变量 e 返回。\",\"bool ListDelete(SqList &L, int i, ElemType &e){ // 判断 i 的位置是否合法 if (i < 1 || i >= L.length){ return false; } // 将被删除的元素赋值给 e e = L.data[i - 1]; // 将第 i 个位置后的元素前移 for (int j = i; j < L.length; j ++){ L.data[j - 1] = L.data[j]; } // 线性表长度 减1 L.length --; return true; } \",\"最好情况：删除表尾元素，则无需移动元素，时复杂度为 O(1)\",\"最坏情况：删除表头元素，则需要移动除表头元素以外的所有元素，时间复杂度为 O(n)\",\"平均情况：假设 pi​ 是删除第 i 个位置结点的概率，则在长度为 n 的线性表中删除一个结点时，所需要移动结点的平均次数为 i=1∑n​pi​(n−i)=i=1∑n​n1​∗(n−i)=n1​i=1∑n​(n−i)=n1​2n(n−1)​=2n−1​ ，则平均时间复杂度为 O(n)\",\"按值查询\",\"在顺序表 L 中查找第一个元素值等于 e 的元素，返回其位序。如果没有找到，则返回 0。\",\"需要注意的是，位序是从 1 开始的，而索引是从 0 开始的。\",\"int LocateElem(SqList &L, ElemeType e){ int i; for (i = 0; i < L.length; i ++){ if (L.data[i] == e){ return i + 1; } } return 0; } \",\"最好情况：查找的元素就在第一个，则只需要比较一次，时间复杂度为 O(1)\",\"最坏情况：查找的元素在最后一个，需要将所有的元素都进行对比，时间复杂度为 O(n)\",\"平均情况：假设 pi​ 是在第 i 个位置上插入的一个结点的概率，则在长度为 n 的线性表中查找值为 e 的元素需要比较的平均次数为 i=1∑n​pi​∗i=i=1∑n​n1​∗i=n1​2n(n+1)​=2n+1​，则平均时间复杂度为 O(n)\",\"按序号查询\",\"在顺序表 L 中查找位序为 i 个元素的值。\",\"需要注意的是，位序是从 1 开始的，而索引是从 0 开始的。\",\"int getByIndex(SqList &L,int i){ if (i <= 0 || i > L.length){ return -1; } return L.data[i - 1]; } \",\"因为顺序表支持随机访问，所以这里通过位序或者索引进行查找的最好、最坏和平均复杂度都是 O(1) 。\"]},\"37\":{\"h\":\"单链表\",\"t\":[\"单链表\",\"线性表的链式存储成为单链表，他是通过一组任意的存储单元来存储线性表中的数据元素。通过节点中存储后续节点的指针来进行连接。\",\"单链表中节点类型的描述\",\"typedef struct LNode{ // 定义单链表节点类型 ElemeType data; // 数据域 struct LNode *next; // 指针域 }LNode, *LinkList; \",\"单链表的特点\",\"可以存储大量数据，解决了顺序表需要大量连续存储单元的缺点\",\"存储数据域，还存储指针域，浪费了存储空间\",\"单链表元素离散的分布在存储空间中，是非随机存取的存储结构\",\"通常头指针来标示一个单链表，为了方便操作，在第一个实际节点之间附加一个头结点\",\"单链表上基本操作的实现\",\"头插法建立单链表\",\"该方法从一个空表开始，生成新结点，并将读取到的数据存放到新节点的数据域中，然后将新节点插入到当前链表的表头，即头结点之后。\",\"LinkList List_HeadInsert(LinkList &L){ // 逆向建立单链表 LNode *s; int x; L = (LinkList)malloc(sizeof(LNode));// 创建头结点 L->next = NULL; // 初始化为空链表 scanf(\\\"%d\\\",&x); // 输入结点的值 while (x != 9999) { // 输入 9999 表示结束 s = (LNode*)malloc(sizeof(LNode)); // 创建新节点 s->data = x; // 赋值 s->next = L->next; // 赋指针 L->next = s; // 将新节点插入表中，L为头指针 scanf(\\\"%d\\\",&x); // 读取下一个值 } return L; } \",\"每个结点插入的时间为 O(1) ，则当单链表长为 n 时，总时间复杂度为 O(n)\",\"尾插法建立单链表\",\"按序号查找结点值\",\"按值查找表节点\",\"插入结点操作\",\"对某一节点进行前插操作\",\"删除节点操作\",\"求表长操作\",\"int *GetListLen(LinkList L){ int length = 0; for (Node i = L; i = L.next ; i != null){ length ++; } return length; } \"]},\"38\":{\"h\":\"双链表\",\"t\":[\"双链表\"]},\"39\":{\"h\":\"循环链表\",\"t\":[\"循环链表\"]},\"40\":{\"h\":\"静态链表\",\"t\":[\"静态链表\"]},\"41\":{\"h\":\"顺序表与链表的比较和选择\"},\"42\":{\"h\":\"数据结构\"},\"43\":{\"h\":\"计算机操作系统\"},\"44\":{\"h\":\"MySQL基础 - 约束\"},\"45\":{\"h\":\"概念\",\"t\":[\"约束是作用于表中字段上的规则，用于限制存储在表中的数据。\"]},\"46\":{\"h\":\"目的\",\"t\":[\"为了保证数据库中数据的正确、有效性和完整性。\"]},\"47\":{\"h\":\"分类\",\"t\":[\"约束\",\"描述\",\"关键字\",\"非空约束\",\"限制该字段的数据不能为null\",\"NOT NULL\",\"唯一约束\",\"保证该字段的所有数据都是唯一，不重复的\",\"UNIQUE\",\"主键约束\",\"主键是一行数据的唯一标识，要求非空且唯一\",\"PRIMARY KEY\",\"默认约束\",\"保存数据时，如果未指定该字段的值，则赋予该默认值\",\"DEFULT\",\"条件约束\",\"保证字段值满足指定的条件\",\"CHECK\",\"外键约束\",\"用来让两张表的数据之间建立连接，保证数据的一致性和完整性\",\"FOREIGN KEY\",\"注意\",\"约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。\"]},\"48\":{\"h\":\"外键约束\",\"t\":[\"其他5种约束的适用方法较为简单，这里仅对外键约束做详细介绍。\"]},\"49\":{\"h\":\"语法\",\"t\":[\"添加外键\",\"-- 建表时添加外键 CREATE TABLE 表名( 字段名 数据类型, ... [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名) ); -- 建表后添加外键 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名); \",\"删除外键\",\"ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; \"]},\"50\":{\"h\":\"删除/更新行为\",\"t\":[\"添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除/更新行为。具体的删除/更新行 为有以下几种:\",\"行为\",\"说明\",\"NO ACTION\",\"当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(与RESTRICT一致)默认行为\",\"RESTRICT\",\"当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(与NO ACTION一致)默认行为\",\"CASCADE\",\"当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录。\",\"SET NULL\",\"当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（这就要求该外键允许取null）。\",\"SET DEFAULT\",\"父表有变更时，子表将外键列设置成一个默认的值(Innodb不支持)\",\"ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE; \"]},\"51\":{\"h\":\"MySQL运维 - 分库分表\"},\"52\":{\"h\":\"MySQL基础 - 函数\",\"t\":[\"函数\",\"函数是一段可以直接被另一段程序调用的程序或者代码。\"]},\"53\":{\"h\":\"字符串函数\",\"t\":[\"MySQL中内置了很多的字符串函数，常用的几个如下所示:\",\"函数\",\"功能\",\"CONCAT(S1,S2,...,Sn)\",\"字符串拼接，将S1、S2、...、Sn按照顺序拼接成一个字符串\",\"LOWER(str)\",\"将字符串str全部转成小写\",\"UPPER(str)\",\"将字符串str全部转成大写\",\"LPAD(str,n,pad)\",\"左填充，用字符串pad对str的左边进行填充，达到n个字符串长度\",\"RPAD(str,n,pad)\",\"右填充，用字符串pad对str的右边进行填充，达到n个字符串长度\",\"TRIM(str)\",\"去掉字符串头部和尾部的空格\",\"SUBSTRING(str,start,len)\",\"返回字符串str从start位置开始的len个长度的字符串\"]},\"54\":{\"h\":\"数值函数\",\"t\":[\"函数\",\"功能\",\"CEIL(x)\",\"向上取整\",\"FLOOR(x)\",\"向下取整\",\"MOD(x,y)\",\"x对y取模，x%y\",\"RAND()\",\"返回0～1之间的随机数\",\"ROUND(x,y)\",\"求参数x的四舍五入值，保留y位小数\"]},\"55\":{\"h\":\"日期函数\",\"t\":[\"函数\",\"功能\",\"CURDATE()\",\"返回当前日期\",\"CURTIME()\",\"返回当前时间\",\"NOW()\",\"返回当前日期和时间\",\"YEAR(date)\",\"获取指定日期date的年份\",\"MONTH(date)\",\"获取指定日期date的月份\",\"DAY(date)\",\"获取指定日期date的天数\",\"DATE_ADD(date,INTERVAL expr type)\",\"返回一个日期/时间值加上一个时间间隔expr后的时间值\",\"DATEDIFF(date1,date2)\",\"返回起始时间date1和结束时间 date2 之间相差的天数\"]},\"56\":{\"h\":\"流程函数\",\"t\":[\"流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。\",\"函数\",\"功能\",\"IF(value,t,f)\",\"如果value为true，则返回t，否则返回f\",\"IFNULL(value1,value2)\",\"如果value1不为null，则返回value1，否则返回value2\",\"CASE WHEN [val1] THEN [res1] WHEN [val2] THEN [res2]... ELSE [defult] END\",\"如果val1为true，则返回res1，如果val2为true，则返回res2，...，否则返回defult\",\"CASE [expr] WHEN [val1] THEN [res1] WHEN [val2] THEN [res2] ELSE [defult] END\",\"如果expr的值等于val1，返回res1，expr的值等于val2，返回res2，...，否则返回defult\"]},\"57\":{\"h\":\"MySQL进阶 - InnoDB存储引擎\"},\"58\":{\"h\":\"逻辑存储结构\",\"t\":[\" InnoDB引擎的存储结构主要包含5个部分：\",\"表空间Tablespace\",\"主要是MySQL中的ibd文件，一个MySQL实例可以对应多个表空间，用于存储记录、索引等数据。表空间用来管理多个Segment段。\",\"段Segment\",\"段分为数据段(Leaf node segment)、索引段(Non-leaf node segment)、回滚段(Rollback segment)，InnoDB是索引组织表，数据段就是B+树的叶子结点，索引段即为B+树的非叶子结点。段用来管理多个Extent区。\",\"区Extent\",\"区是表空间中的单元结构。每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页。\",\"页Page\",\"页是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4-5个区。\",\"行Row\",\"InnoDB存储引擎数据是按行进行存放的。\",\"字段解释\",\"Trx_id：每次对某条记录产生改动时，都会把对应的事务id赋值给trx_id隐藏列。\",\"Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。\",\"这个字段在后面的MVCC版本控制时会使用到。\"]},\"59\":{\"h\":\"架构\",\"t\":[\"MySQL5.5版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特征，在日常开发中使用非常广泛。下面是InnoDB架构图。\",\"InnoDB架构\"]},\"60\":{\"h\":\"内存结构\",\"t\":[\"内存结构\",\"上图为InnoDB的内存架构，由图可知，主要分为三个部分\"]},\"61\":{\"h\":\"Buffer Pool 缓冲池\",\"t\":[\"缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池中没有所需数据，再从磁盘加载并且缓存），然后再以一定的频率刷新到磁盘，从而减少磁盘IO，加快处理速度。\",\"缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：\",\"free page：空闲Page，未被使用。\",\"clean page：被使用的Page，但是数据并未被修改过。\",\"dirty page：脏页，脏Page，被使用过的Page，数据被修改过，页中数据与磁盘中数据产生了不一致。\"]},\"62\":{\"h\":\"Change Buffer 更改缓冲区\",\"t\":[\"更改缓冲区（针对于非唯一的二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer 中，在未来数据被读取时，再将数据恢复到 Buffer Pool 中，再将合并后的数据写回磁盘内。\",\"Change Buffer 的意义是什么？\",\"与聚集索引不同，二级索引通常情况下是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。\",\"有了Change Buffer 以后，我们可以在缓冲池中进行合并处理，减少磁盘IO。\"]},\"63\":{\"h\":\"Log Buffer 日志缓冲区\",\"t\":[\"日志缓冲区，用来保存要写入到磁盘中的Log日志数据（redo log、undo log），默认大小为16MB，日志缓冲区中的数据会定期刷新到磁盘中。如果需要更新、插入或者删除许多行的事务，增加日志缓冲区的大小可以节省磁盘IO。\",\"参数\",\"innodb_log_buffer_sie：缓冲区大小\",\"innodb_flush_log_at_trx_commit：日志刷新到磁盘时机\",\"该参数有三个值，默认为 1\",\"0 : 每秒将日志写入并刷新到磁盘一次。\",\"1 : 日志在每次事务提交时写入并刷新到磁盘。\",\"2 : 日志在每次事务提交后写入，并每秒刷新到磁盘一次。\"]},\"64\":{\"h\":\"Adaptive Hash Index 自适应哈希索引\",\"t\":[\"自适应哈希索引，用于优化对Buffer Pool 数据的查询，InnoDB存储引擎会监控对表上各索引页的查询，如果观察到哈希索引可以提升速度，则建立哈希索引，称之为自适应哈希索引。\",\"自适应哈希索引无需人工干预，是系统根据情况自动完成的。\",\"参数\",\"adaptive_hash_index\"]},\"65\":{\"h\":\"磁盘结构\",\"t\":[\"磁盘结构\"]},\"66\":{\"h\":\"System Tablespace 系统表空间\",\"t\":[\"系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。（在MySQL5.x版本中还包含InnoDB数据字典、undo log等）\",\"参数\",\"innodb_data_file_path\"]},\"67\":{\"h\":\"File-Pre-Table Tablespaces 独立表空间\",\"t\":[\"每个表的文件表空间包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中。\",\"参数\",\"innodb_file_pre_table 默认打开，为ON，即每张表都有独立的空间\"]},\"68\":{\"h\":\"General Tablespaces 通用表空间\",\"t\":[\"通用表空间需要通过 CREATE TABLETABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。\",\"创建表空间\",\"CREATE TABLESPACE tablespace_name ADD DATAFILE 'file_name' ENGINE = 'engine_name'; \",\"创建表并且指定表空间\",\"CREATE TABLE table_name(...) TABLESPACE tablespace_name; \"]},\"69\":{\"h\":\"Undo Tablespaces 撤销表空间\",\"t\":[\"撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小为16MB），用于存储undo log日志。\"]},\"70\":{\"h\":\"Temporary Tablespaces 临时表\",\"t\":[\"InnoDB使用会话临时表和全局临时表空间。存储用户创建的临时表等数据。\"]},\"71\":{\"h\":\"Double Write Buffer Files 双写缓冲区\",\"t\":[\"双写缓冲区，InnoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。\"]},\"72\":{\"h\":\"Redo Log 重做日志\",\"t\":[\"重做日志是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲以及重做日志文件，前者是在内存中，后者是在磁盘中。当事务提交之后会把所有修改信息都存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用。\",\"以循环方式写入重做日志文件，涉及两个文件\",\"ib_logfile0\",\"ib_logfile1\"]},\"73\":{\"h\":\"后台线程\",\"t\":[\"后台线程的作用就是将InnoDB缓冲池 Buffer Poll 中的数据，在合适的时间内刷新到磁盘。\",\"后台线程主要有四类：\",\"Master Thread\",\"核心后台线程，主要负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中，保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收。\",\"IO Thread\",\"在InnoDB存储引擎中，使用了大量的AIO来处理IO请求，这样可以极大的提高数据库的性能，而IO Thread主要负责这些IO请求的回调。\",\"线程类型\",\"默认个数\",\"职责\",\"Read Thread\",\"4\",\"负责读操作\",\"Write Thread\",\"4\",\"负责写操作\",\"Log Thread\",\"1\",\"负责将日志缓冲区刷新到磁盘\",\"Insert Buffer Thread\",\"1\",\"负责将写缓冲区内容刷新到磁盘\",\"Purge Thread\",\"主要用于回收事务已经提交了的 undo log ，在事务提交之后，undo log 可能不用了，就用它来回收。\",\"Page Cleaner Thread\",\"协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。\"]},\"74\":{\"h\":\"事务原理\",\"t\":[\"事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体向系统提交或撤销操作请求，即这些操作要么同时成功要么同时失败。\",\"事务特性 ACID\",\"原子性 Atomicity : 事务是不可分割的最小操作单元，要么全部成功，要么全部失败。\",\"一致性 Consistency : 事务完成时，必须使所有的数据都保持一致性。\",\"隔离性 Isolation : 数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。\",\"持久性 Durablity : 事务一旦提交或回滚，它对数据库中数据的改变就是永久的。\"]},\"75\":{\"h\":\"Redo Log 重做日志\",\"t\":[\"重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。\",\"该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo logo file），前者是在内存中，后者是在磁盘中。\",\"当事务提交之后会把所有的修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。\",\"数据操作流程\"]},\"76\":{\"h\":\"Undo Log\",\"t\":[\"回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚 和 MVCC（多版本并发控制），是用来实现事务的原子性。\",\"Undo Log和Redo Log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，Undo Log中会记录一条对应的insert记录，反之 亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rolback时，就可以从Undo Log中的逻辑记录读取到相应的内容并进行回滚。\",\"Undo Log销毁：undo Log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。\",\"Undo Log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的rollback segment 回滚段中，内部包含 1024 个undo log segment。\"]},\"77\":{\"h\":\"MySQL进阶 - MVCC多版本并发控制\"},\"78\":{\"h\":\"概念介绍\"},\"79\":{\"h\":\"MVCC\",\"t\":[\"MVCC全称为Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐藏字段、undo log 日志、readView。\"]},\"80\":{\"h\":\"当前读\",\"t\":[\"读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如： select ... lock in share mode （共享锁），select ... for update 、insert、delete（排他锁）都是一种当前读。\"]},\"81\":{\"h\":\"快照读\",\"t\":[\"简单的select语句（不加锁）就是快照读，快照读读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。\",\"Read Commit：每次select，都生成一个快照读。\",\"Repeated Read：开启事务后第一个select语句才是快照读的地方。\",\"Serializable：快照读会退化为当前读。\"]},\"82\":{\"h\":\"实现原理\",\"t\":[\"记录中的隐藏字段分别为：DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID。\",\"隐藏字段\",\"含义\",\"DB_TRX_ID\",\"最近修改事务的ID，记录插入这条记录或最后一次修改该记录的事务ID\",\"DB_ROLL_PTR\",\"回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本\",\"DB_ROW_ID\",\"隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段\",\"ibd2sdi指令\",\"ibd2sdi指令可以查看ibd文件，语法如下：\",\"ibd2sdi 'filename.ibd'\"]},\"83\":{\"h\":\"Undo Log\",\"t\":[\"回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。\",\"当insert的时候，产生的 undo log 日志只在回滚时需要，在事务提交后，可以被立即删除。\",\"而update、delete的时候，产生的 undo log 日志不仅在回滚时需要，在快照读时也需要，不会立刻被删除。\"]},\"84\":{\"h\":\"Undo Log 版本链\",\"t\":[\"在并发访问的情况下，有多个事务需要对同一个数据进行操作，此时则在Undo Log 中记录下每一次操作的原数据，作为事务在未提交情况下回滚的依据。\",\"不同事务或者相同事务对同一条数据记录进行操作，会导致该记录的 Undo Log 生成一条记录版本链条，链表的头部是最新的旧数据，链表的尾部是最早的旧数据。\",\"具体的事务回滚，不单单依赖Undo Log，还依靠ReadView。Undo Log记录事务回滚的数据，ReadView决定回滚到哪个链条节点。\"]},\"85\":{\"h\":\"ReadView 读视图\",\"t\":[\"Read View 读视图是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交）ID。\",\"ReadView中包含了4个核心字段：\",\"字段\",\"含义\",\"m_ids\",\"当前活跃的事务ID集合，即当前还未提交的事务ID集合\",\"min_trx_id\",\"最小活跃事务ID\",\"max_trx_id\",\"预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）\",\"creator_trx_id\",\"ReadView创建者的事务ID\"]},\"86\":{\"h\":\"版本链数据访问规则\",\"t\":[\"trx_id 代表的是当前的事务ID：\",\"trx_id == creator_trx_id : 可以访问该版本\",\"trx_id < min_trx_id : 可以访问该版本\",\"trx_id > max_trx_id : 不可以访问该版本\",\"min_trx_id <= trx_id <= max_trx_id : 如果 trx_id 不在 m_ids 中是可以访问该版本的，即事务已经提交了\",\"注意\",\"不同的隔离级别，生成ReadView的时机不同：\",\"Read Commited : 在事务中每一次执行快照读时生成ReadView\",\"Repeatable Read : 仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView\",\"MVCC-实现原理\",\"特性\",\"实现方式\",\"原子性\",\"Undo Log\",\"持久性\",\"Redo Log\",\"一致性\",\"Undo Log + RedoLog\",\"隔离性\",\"MVCC + 锁\"]},\"87\":{\"h\":\"MySQL运维 - 主从复制\"},\"88\":{\"h\":\"MySQL基础 - 多表查询\"},\"89\":{\"h\":\"多表关系\",\"t\":[\"提示\",\"在正式学习数据库的多表查询之前，我们需要了解到需要多表查询的场景，以及有哪些多表查询的情况，也就是数据表之间的关系。\"]},\"90\":{\"h\":\"一对一\",\"t\":[\"一对一关系是我们比较常见的关系，比如数据表A中的一条值对应数据表B中的一条值，这种情况经常用于多表的拆分。例如将最常用的字段抽取出来，使得提高查询的效率。\",\"实现\",\"在任意一方加入外键，关联另外一方的主键，并且设置唯一约束(UNIQUE)。\"]},\"91\":{\"h\":\"一对多\",\"t\":[\"一对多的关系也可以看作多对一，就看你是从那个视角去看待这段关系。例如，一个部门下有多个员工，但是一个员工只能属于一个部门，这种关系就是一对多关系。\",\"实现\",\"在多的一方建立外键，指向的一的一方的主键。\"]},\"92\":{\"h\":\"多对多\",\"t\":[\"这种关系也是我们经常遇到的一种关系，如学生和课程之间的关系，一个学生可以选择多门课程，而一门课程中也可以有多个学生，这就是一种多对多的关系.\",\"实现\",\"这种关系的实现相对来说较为复杂，需要我们建立一张中间表，这张中间表的字段最少包含了两个外键，关联了两方多的主键，从而确保多对多的关系。\"]},\"93\":{\"h\":\"多表查询\",\"t\":[\"多表查询是指从多张数据表中查询数据。然而在多表查询之前，我们首先需要了解一个简单的概念：笛卡尔积。\",\"笛卡尔积\",\"笛卡尔积是指在数学中，两个集合A和B的所有组合情况。在多表查询时，需要消除无效的笛卡尔积。\",\"例如，我们在连接查询的时候，不指定条件列表，则查询出来的数据是两张表的笛卡尔积组合。即按行将两张表排列组合，一共有 表a的行数 * 表b的行数 个值。\"]},\"94\":{\"h\":\"内连接\",\"t\":[\"相当于查询数据表A、B之间的交集部分。内连接分为两种类型\",\"内连接\",\"隐式内连接\",\"SELECT 字段列表 FROM 表1,表2 WHERE 条件列表; \",\"显示内连接\",\"SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件...; \"]},\"95\":{\"h\":\"外连接\",\"t\":[\"外连接有两种情况，左外连接和右外连接。\",\"左外连接：查询左表的所有数据，以及两张表交集部分的数据。\",\"左外连接\",\"SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 连接条件...; \",\"右外连接：查询右表的所有数据，以及两张表交集部分的数据。\",\"右外连接\",\"SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 连接条件...; \"]},\"96\":{\"h\":\"自连接\",\"t\":[\"自连接顾名思义就是自己连接自己，当前表与自身的连接查询，是通过将一张表复制成两张，将这两张表进行连接查询，自连接查询必须使用表别名。\",\"SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件列表 ...; \",\"注意\",\"自连接是不区分左连接和右连接的，因为两张表的是完全相同的，无论将哪张表放在左边，其结果都是相同的。\",\"自连接可以是内连接，也可以是外连接查询。\"]},\"97\":{\"h\":\"联合查询\",\"t\":[\"对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。\",\"SELECT 字段列表 FROM 表1 表2 ... UNION [ALL] SELECT 字段列表 FROM 表A 表B ...; \",\"注意\",\"对于联合查询而言，多张表的列数必须保持一致，字段类型也需要保持一致。\",\"union all 会讲全部的数据直接合并在一起，而 union 会将数据合并后去重。\"]},\"98\":{\"h\":\"子查询\",\"t\":[\"子查询又称为嵌套查询，即在SQL语句中嵌套使用SELECT语句，一次SELECT的返回集又称为了另外一个SELECT的数据集。\",\"SELECT * FROM table1 WHERE column1 = ( SELECT column1 FROM table2 ); \",\"提示\",\"子查询的外部可以是INSERT、DELETE、UPDATE、SELECT操作中的任意一个。\",\"根据子查询的结果不同，分为：\",\"标量子查询（子查询的结果为单个值）\",\"列子查询（子查询的结果为一列）\",\"行子查询（子查询的结果为一行）\",\"表子查询（子查询的结果为多行多列）\"]},\"99\":{\"h\":\"标量子查询\",\"t\":[\"标量子查询指的是子查询的返回的结果是一行一列的一个值，如数字、字符串、日期等简单的形式。\",\"常用的操作符号：=、!=、>、>=、 < 、<=\"]},\"100\":{\"h\":\"列子查询\",\"t\":[\"列子查询指的是子查询的返回结果是一列，可以是多行的数据集。\",\"常用的操作符： IN、NOT IN、ANY、SOME、ALL\",\"操作符\",\"描述\",\"IN\",\"在指定的集合范围之内，多选一\",\"NOT IN\",\"不在指定的集合范围内\",\"ANY\",\"子查询的返回列表中，有任意一个满足即可\",\"SOME\",\"与ANY等同，使用SOME的地方均可以使用ANY\",\"ALL\",\"子查询的返回列表的所有值都必须满足\"]},\"101\":{\"h\":\"行子查询\",\"t\":[\"行子查询指的是子查询返回的结果是一行，可以是多列的数据集。\",\"常用的操作符：=、!= 、IN、NOT IN\"]},\"102\":{\"h\":\"表子查询\",\"t\":[\"表子查询指的是子查询返回的结果是多行多列的数据集。\",\"常用的操作符：IN\"]},\"103\":{\"h\":\"MySQL基础 - 基础概念\"},\"104\":{\"h\":\"基本概念\",\"t\":[\"区别\",\"在学习MySQL之前，我们需要明确一些基本概念，以便于后续的理解和学习。\",\"数据库\",\"数据库是存储数据的仓库，数据是有组织的进行存储。简写为DataBase （DB）\",\"数据库管理系统\",\"操纵和管理数据库的大型软件系统。简写为DataBase Management System （DBMS）\",\"SQL\",\"操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准。又叫架构话查询语言，Structured Query Language（SQL）\",\"MySQL\",\"由瑞典MySQL AB公司开发的一款关系型数据库管理系统（Relational DataBase Management System RDBMS），属于Oracle旗下。\"]},\"105\":{\"h\":\"MySQL的安装\",\"t\":[\"提示\",\"直接在MySQL官方网站，根据自己的操作系统下载安装即可。\",\"MySQL官方下载地址：https://www.mysql.com/downloads/\"]},\"106\":{\"h\":\"MySQL版本\",\"t\":[\"社区版 MySQL Community Server\",\"免费\",\"不提供技术支持\",\"商业版 MySQL Enterprise Edition\",\"收费\",\"提供专业技术支持\"]},\"107\":{\"h\":\"数据库类型\"},\"108\":{\"h\":\"关系型数据库\",\"t\":[\"建立在关系模型基础上，由多张相互连接的二维表组成的数据库。\",\"特点\",\"使用表存储数据，格式统一，便于维护\",\"使用SQL语言操作，标准统一，使用方便。\"]},\"109\":{\"h\":\"非关系型数据库\",\"t\":[\"分布式的、非关系型的、不保证遵循ACID原则的数据存储系统。最常见的解释就是NoSQL，non-relational或者Not only SQL。非关系型可以分为以下几种类型：\",\"键值(Key-Value)存储数据库\",\"注\",\"主要有：Tokyo Cabinet/Tyrant， Redis， Voldemort， Oracle BDB\",\"列存储数据库\",\"注\",\"主要有：Cassandra， HBase， Riak\",\"文档型数据库\",\"注\",\"主要有：CouchDB， MongoDb\",\"图形(Graph)数据库\",\"注\",\"主要有：Neo4J， InfoGrid， Infinite Graph\"]},\"110\":{\"h\":\"MySQL数据模型\",\"t\":[\"MySQL数据模型\"]},\"111\":{\"h\":\"MySQL进阶 - 索引\"},\"112\":{\"h\":\"索引概述\"},\"113\":{\"h\":\"概念\",\"t\":[\"索引是帮助MySQL的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式饮用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。\"]},\"114\":{\"h\":\"优缺点\",\"t\":[\"优点\",\"提高数据检索的效率，降低数据库的IO成本\",\"通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗\",\"缺点\",\"索引列也是要占用空间的\",\"索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。\",\"注意\",\"索引是一种典型的使用空间换时间的例子。\"]},\"115\":{\"h\":\"索引结构\",\"t\":[\"MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种：\",\"索引结构\",\"描述\",\"Hash索引\",\"底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询\",\"R-tree\",\"空间索引是MyISAM引擎的一个特殊索引，主要用于地理空间数据类型，通常使用较少\",\"Full-text\",\"是一种通过建立倒排索引，快速匹配文档的方式，类似于Lucene,Solr,Es\"]},\"116\":{\"h\":\"二叉树\",\"t\":[\"二叉树\",\"缺点\",\"使用二叉树做索引结构，顺序插入时，会退化成为一个链表，查询性能大大降低。大量数据的情况下，层级较深，检索速度慢。\"]},\"117\":{\"h\":\"红黑树\",\"t\":[\"红黑树\",\"缺点\",\"红黑树虽然解决了退化为单链表的这种现象，但是其本质上仍然是二叉树，在大量数据的情况下，层级较深，检索速度还是很慢。\"]},\"118\":{\"h\":\"B树\",\"t\":[\"B树(B-Tree)又称为多路平衡查找树，一般是以阶树来衡量B树，以其最大度数作为B树的阶数，一棵n阶B树的节点最多能存储n-1个数据，n个指针。\",\"B树\",\"小知识\",\"树的度数指的是一个节点的子节点个数。\",\"B树随着数据的插入或者删除会自动进行节点的裂变和合并，这里的具体细节可以去学习数据结构中的B树。\",\"B树知识点\",\"// todo 待更新B树\"]},\"119\":{\"h\":\"B+树\",\"t\":[\"B+树是B树的一个变种，基本的结构和节点的变化规律不变，仅在非叶子结点中存储索引，在叶子结点中存储数据。并且在叶子结点中，相邻的叶子结点会有一个单向的指针连接，形成一个单向链表。\",\"B+树\"]},\"120\":{\"h\":\"优化的B+树\",\"t\":[\"MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上增加了一个指向相邻叶子结点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。\",\"MySQL优化的B+树\"]},\"121\":{\"h\":\"Hash\",\"t\":[\"哈希索引就是采用一定的Hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。\",\"是哈希结构，那么就不可避免的会出现哈希碰撞（哈希冲突），即多个键值对映射到了同一个槽位上，此时就产生了哈希碰撞，可以通过构建链表来解决。\",\"知识点\",\"解决哈希碰撞的方法有很多，如：拉链法、开放寻址法、再哈希法、建立公共溢出区等方法进行解决。\",\"哈希索引的特点：\",\"hash索引只能用于对等比较（== ， in） ，不支持范围查找(between , > , < , ...)\",\"无法利用索引完成排序操作。\",\"查询效率高，通常只需要一次检索就可以了，效率通常要高于B+Tree索引。\",\"存储引擎支持\",\"在MySQL中，支持hash索引的是Memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。其他引擎不支持。\",\"自适应hash就是InnoDB存储引擎根据我们的查询条件，在指定的条件下会自动的将B+树索引构建成hash索引。\"]},\"122\":{\"h\":\"思考\",\"t\":[\"思考题\",\"为什么InnoDB存储引擎选择使用B+树索引结构？\",\"相对于二叉树，在相同数据规模的情况下，B+树具有更少的层级，查询速度更快\",\"对于B树，无论是叶子结点还是非叶子结点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要保存大量数据，只能增加树的高度，导致性能降低。\",\"对于Hash索引，B+树支持范围匹配和排序操作。\"]},\"123\":{\"h\":\"存储引擎支持\",\"t\":[\"索引\",\"InnoDB\",\"MyISAM\",\"Memory\",\"B+Tree索引\",\"✅\",\"✅\",\"✅\",\"Hash索引\",\"❌\",\"❌\",\"✅\",\"R-Tree索引\",\"❌\",\"✅\",\"❌\",\"Full-text索引\",\"5.6版本以后✅\",\"✅\",\"❌\"]},\"124\":{\"h\":\"索引分类\",\"t\":[\"索引主要分为4个类型：主键索引、唯一索引、常规索引、全文索引\",\"分类\",\"含义\",\"特点\",\"关键字\",\"主键索引\",\"针对于表中主键创建的索引\",\"默认自动创建，只能有一个\",\"PRIMARY\",\"唯一索引\",\"避免同一个表中某数据列中的值重复\",\"可以有多个\",\"UNIQUE\",\"常规索引\",\"快速定位特定数据\",\"可以有多个\",\"全文索引\",\"全文索引查找的是文本中的关键词，而不是比较索引中的值\",\"可以有多个\",\"FULLTEXT\",\"在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：\",\"分类\",\"含义\",\"特点\",\"聚集索引\",\"将数据和索引的存储放到了一块，索引结构的叶子结点保存了行数据\",\"必须有，而且只能有一个\",\"二级索引\",\"将数据和索引分开存储，索引结构的叶子结点关联的是对应的主键\",\"可以存在多个\",\"聚集索引的选取规则：\",\"如果存在主键，主键索引就是聚集索引\",\"如果不存在主键，将使用第一个唯一UNIQUE索引作为聚集索引。\",\"如果没有主键，也没有合适的唯一索引，那么InnoDB引擎就会生成一个rowid作为隐藏的聚集索引。\"]},\"125\":{\"h\":\"回表查询\",\"t\":[\"回表查询\",\"我们在对数据的查询时，通常会给定查询条件，而当我们的查询条件并不是聚集索引中的值，而是二级索引中的值，这时候的查询过程为：\",\"先通过筛选条件在二级索引中查找对应的记录值，找到记录值的id；\",\"使用记录值的id再在聚集索引中查询，得到数据的记录值。\",\"这个过程我们就叫做回表查询，虽然只执行了一条查询语句，但是实际的底层在B+树内查询了两次。\"]},\"126\":{\"h\":\"思考题\",\"t\":[\"以下SQL语句中，那个执行效率更高？为什么？\",\"select * from user where id = 10; select * from user where name = 'Mast'; \",\"备注：id为主键，name字段创建的有索引。\",\"答案\",\"第一条SQL使用id查询的效率更高，因为id是主键，而主键会建立聚集索引，聚集索引中查询直接就能够得到数据的记录值。而使用name字段查询，虽然建立有索引，但是其为二级索引，查询后的值为该字段对应的id值，此时还需要通过id值在聚集索引中查询，有回表查询，查询了两次B+树，而第一条SQL只查询了一次B+树。\",\"InnoDB主键索引的B+Tree高度为多高呢？\",\"答案\",\"假设： 一行数据大小为1K=1024B=1024字节，一页中能存储16行这样的数据，InnoDB的指针占用6个字节的空间，主键即使为bigint，占用8个字节。\",\"高度为2时： n * 8 + (n + 1) * 6 = 16 * 1024 解得：n = 1170\",\"所以一共能存储 1171 * 16 = 18736 个数据\",\"高度为3时： 1171 * 1171 * 16 = 21939856 个数据\"]},\"127\":{\"h\":\"索引语法\",\"t\":[\"创建索引\",\"CREATE [UNIQUE | FULLTEXT] INDEX index_name ON table_name(index_col_name,...); \",\"在表 table_name 中创建名为index_name 的索引。\",\"注意\",\"[UNIQUE | FULLTEXT]是可选项，分别为创建唯一索引和全文索引，如果都不选的话，则创建的是常规索引。一个索引可以关联多个字段。\",\"根据索引关联字段的个数，可以讲索引分为两种类型：\",\"单列索引：索引列表只有一个字段。\",\"联合索引：又叫组合索引，即索引列表有多个字段。\",\"查看索引\",\"SHOW INDEX FROM table_name; \",\"查看指定表的索引。\",\"删除索引\",\"DROP INDEX index_name ON table_name; \",\"删除表 table_name 名为 index_name 的索引。\"]},\"128\":{\"h\":\"索引使用\"},\"129\":{\"h\":\"索引失效场景\",\"t\":[\"最左前缀法则 如果索引了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。\",\"举个简单的例子，如为 mail(5)、tel(6)、username(7)三个字段建立联合索引，括号内为长度，则在使用的时候根据 mail -> tel -> username 这个顺序来判断是否走索引。\",\"查询条件的顺序为：mail - tel - username，则走索引，长度为 5 + 6 + 7 = 18\",\"查询条件的顺序为：mail - username - tel，则走索引，但长度为 5\",\"查询条件的顺序为：tel - username - mail，则不走索引，长度为NULL ......以此类推，满足最左前缀法则，哪里不满足，则从哪里断开，可以根据索引长度来判断\",\"范围查询 联合索引中，出现范围查（> ，<），范围查询右侧的列索引失效。\",\"索引列运算 不要在索引列上进行运算操作，索引将失效。\",\"字符串类型不加引号 在字符串类型字段上使用时，不加引号，索引将失效。\",\"模糊查询 如果仅仅是尾部模糊匹配，索引不会失效。如果是开头模糊匹配，则索引失效。\",\"or连接的条件 用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被使用到。\",\"数据分布影响 如果MySQL评估使用索引比全表更慢，则不会使用索引。\"]},\"130\":{\"h\":\"SQL提示\",\"t\":[\"SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化的目的。\",\"use index 建议使用索引\",\"explain select * from tb_user use index(idx_user_pro) where profession = '软件工程'; \",\"ignore index 忽略索引\",\"explain select * from tb_user ignore index(idx_user_pro) where profession = '软件工程'; \",\"force index 强制索引\",\"explain select * from tb_user force index(idx_user_pro) where profession = '软件工程'; \"]},\"131\":{\"h\":\"覆盖索引\",\"t\":[\"尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到），减少select *\",\"即尽量保证所需要的数据在使用索引内包含，保证所需要的所有数据都能够通过索引查询到。即保证返回的字段，能通过索引直接查到，不回表查询。\",\"小贴士\",\"using index condition:查找使用了索引，但是需要回表查询数据。\",\"using where;using index：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据。\"]},\"132\":{\"h\":\"前缀索引\",\"t\":[\"当字段类型为字符串（varchar，text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。\",\"语法\",\"create index idx_xxxx on table_name(column(n)); \",\"前缀长度 可以根据索引的选择性来决定，而选择性是指不重复的索引值(基数)和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。\",\"select count(distinct email) / count(*) from tb_user; select count(distanct substring((email,1,5) / count(*) from tb_user; \"]},\"133\":{\"h\":\"单列/联合索引\",\"t\":[\"单列索引：即一个索引值包含了单个列\",\"联合索引：即一个索引值包含了多个列 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。\",\"小知识\",\"有时候即便我们创建了联合索引，MySQL也不一定就会使用，在多联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。\"]},\"134\":{\"h\":\"索引设计原则\",\"t\":[\"针对于数据量较大，且查询比较频繁的表建立索引。\",\"针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。\",\"尽量选择区分度较高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。\",\"如果是字符串类型和字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。\",\"尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。\",\"要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改茶的效率。\",\"如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引更有效地用于查询。\"]},\"135\":{\"h\":\"MySQL进阶 - 锁\"},\"136\":{\"h\":\"介绍\",\"t\":[\"锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除了传统的计算机资源(CPU、RAM、I/O)的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。\"]},\"137\":{\"h\":\"全局锁\"},\"138\":{\"h\":\"介绍\",\"t\":[\"全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。\",\"其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。\"]},\"139\":{\"h\":\"一致性数据备份\",\"t\":[\"加锁\",\"flush tables with read lock; \",\"备份\",\"mysqldump -uroot -p1234 tb_user > tb_user.sql; \",\"注意：这并不是一条SQL语句！而是一条Shell脚本！\",\"解锁\",\"unlock tables; \"]},\"140\":{\"h\":\"特点\",\"t\":[\"数据库中加全局锁，是一个比较重的操作，存在以下问题：\",\"如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就完全停止。\",\"如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。\",\"在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction参数来完成不加锁的一致性数据备份。\",\"mysaldump --single-transaction -uroot -p1234 tb_user > tb_user.sql \"]},\"141\":{\"h\":\"表级锁\"},\"142\":{\"h\":\"介绍\",\"t\":[\"表级锁，每次操作锁住整张表。锁定力度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。\",\"对于表级锁，主要分为以下三种类型：\",\"表锁\",\"元数据锁（meta data lock，MDL）\",\"意向锁\"]},\"143\":{\"h\":\"1.表锁\",\"t\":[\"分类 对于表锁，又可以分为两类：\",\"表共享读锁（read lock）\",\"表独占写锁（write lock）\",\"语法\",\"加锁：\",\"lock tables 表名 ... read/write \",\"释放锁\",\"unlock tables / 客户端断开连接 \",\"注意\",\"读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的读。\"]},\"144\":{\"h\":\"2.元数据锁\",\"t\":[\"MDL加锁过程是系统自动控制，无需显示使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。\",\"在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁（排他）。\",\"对应SQL\",\"锁类型\",\"说明\",\"lock table xxx read / write\",\"SHARED_READ_ONLY / SHARED_NO_READ_WRITE\",\"select 、 select ... lock in share mode\",\"SHARED_READ\",\"与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE\",\"insert 、 update 、delete 、 select ... for update\",\"SHARED_WRITE\",\"与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE\",\"alter table ...\",\"EXCLUSIVE\",\"与其他的MDL都互斥\",\"查看元数据锁：\",\"select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadate_locks; \"]},\"145\":{\"h\":\"3.意向锁\",\"t\":[\"为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。\",\"意向共享锁（IS）：\",\"select ... lock in share mode ``` 与表锁共享锁 read 兼容，与表锁排他锁 write 互斥。 2. 意向排他锁（IX）： ```sql insert、update、delete、select ... for update \",\"与表锁共享锁 read 及排他锁 write 都互斥。意向锁之间不会互斥。\",\"通过以下SQL，查看意向锁及行锁的加锁情况。\",\"select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks; \"]},\"146\":{\"h\":\"行级锁\",\"t\":[\"行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发程度高。主要应用在InnoDB存储引擎中。\",\"InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：\",\"行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。\",\"间隙锁（Gap Lock）：锁定索引记录间隙（不包含该记录值），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。\",\"临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。\"]},\"147\":{\"h\":\"行锁\",\"t\":[\"InnoDB实现了以下两种类型的行锁：\",\"共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。\",\"排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。\",\"兼容和互斥\",\"只有共享锁和共享锁之间是兼容的，其余全是冲突的。\",\"可以将共享看作是只读。\"]},\"148\":{\"h\":\"间隙锁\"},\"149\":{\"h\":\"临键锁\",\"t\":[\"相关信息\",\"// todo:有点繁琐，暂未理解\"]},\"150\":{\"h\":\"MySQL运维 - 日志\"},\"151\":{\"h\":\"MySQL进阶 - MySQL管理\"},\"152\":{\"h\":\"MySQL进阶 - 触发器\"},\"153\":{\"h\":\"介绍\",\"t\":[\"触发器是于表有关的数据库对象，指在insert、update、delete之前或者之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以与协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。\",\"使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。\",\"举例\",\"语句级触发：执行一次SQL，触发器会触发一次，无论影响多少行。 行级触发：如一个SQL语句更新了3行数据，则触发器会触发三次。\"]},\"154\":{\"h\":\"类型\",\"t\":[\"触发器类型\",\"NEW和OLD\",\"INSERT型触发器\",\"NEW表示将要或者已经新增的数据\",\"UPDATE型触发器\",\"OLD表示修改之前的数据，NEW表示将要或已经修改后的数据\",\"DELETE型触发器\",\"OLD表示将要或者已经删除的数据\"]},\"155\":{\"h\":\"语法\",\"t\":[\"创建\",\"MySQL目前只支持行级触发器\",\"CREATE TRIGGER trigger_name BEFORE/AFTER INSERT/UPDATE/DELETE ON tbl_name FOR EACH ROW -- 行级触发器 BEGIN -- 触发器语句 trigger_stmt; END; \",\"查看\",\"SHOW TRIGGERS; \",\"删除\",\"-- 如果没有指定schema_name，默认为当前数据库 DROP TRIGGER [schema_name.]trigger_name; \"]},\"156\":{\"h\":\"案例\"},\"157\":{\"h\":\"插入触发器\",\"t\":[\"CREATE TRIGGER user_insert_trigger AFTER INSERT ON user FOR EACH ROW BEGIN -- user表中数据插入时，则向日志表中插入一条数据 INSERT INTO user_logs(id,operate_type,excute_sql) VALUE (null,\\\"INSERT\\\",concat(\\\"SQL:INSERT INTO user(id,username,password) VALUE (\\\",new.id,\\\",\\\",new.username,\\\",\\\",new.password,\\\")\\\")); END; \"]},\"158\":{\"h\":\"更新触发器\",\"t\":[\"CREATE TRIGGER user_update_trigger AFTER UPDATE ON user FOR EACH ROW BEGIN -- user表中数据更新时，则向日志表中插入一条数据 INSERT INTO user_logs(id,operate_type,excute_sql) VALUE (null,\\\"UPDATE\\\",concat(\\\"SQL:INSERT INTO user(id,username,password) VALUE (\\\",new.id,\\\",\\\",new.username,\\\",\\\",new.password,\\\")\\\")); END; \"]},\"159\":{\"h\":\"删除触发器\",\"t\":[\"CREATE TRIGGER user_delete_trigger AFTER DELETE ON user FOR EACH ROW BEGIN -- user表中数据删除时，则向日志表中插入一条数据 INSERT INTO user_logs(id,operate_type,excute_sql) VALUE (null,\\\"DELETE\\\",concat(\\\"SQL:INSERT INTO user(id,username,password) VALUE (\\\",new.id,\\\",\\\",new.username,\\\",\\\",new.password,\\\")\\\")); END; \",\"小知识\",\"在触发器内所执行的SQL中，我们可以使用NEW和OLD两个关键字来调用执行后和执行前的数据。\"]},\"160\":{\"h\":\"MySQL进阶 - 视图\"},\"161\":{\"h\":\"介绍和基本语法\"},\"162\":{\"h\":\"介绍\",\"t\":[\"视图View是一种虚拟存在的表，视图中的数据并不在数据库中实际存在，行和列数据来自定义视图中使用的表，并且是在使用视图时动态生成的。\",\"简单的来说，视图不保存数据，只是保存了查询的SQL逻辑，不保存查询的结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。\",\"简单理解\",\"可以理解为给SQL语句设置别名，我们在使用的时候可以直接使用别名进行子查询、联合查询等操作。\"]},\"163\":{\"h\":\"操作语法\",\"t\":[\"创建\",\"CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH[CASCADED | LOCAL] CHECK OPTION]; \",\"查询\",\"-- 查看创建视图语句 SHOW CREATE VIEW 视图名称; -- 查看视图数据 SELECT * FROM 视图名称; \",\"视图就是一张逻辑SQL查询的临时表，我们可以直接按照表的操作来操作视图。\",\"修改\",\"-- 方法一：和创建视图一致，但是需要保证OR REPLACE关键字，说明是替换原来的视图 CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH[CASCADED | LOCAL] CHECK OPTION]; -- 方法二 ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH[CASCADED | LOCAL] CHECK OPTION]; \",\"删除\",\"DROP VIEW [IF EXISTS] 视图名称 [,视图名称...]; \"]},\"164\":{\"h\":\"检查选项\",\"t\":[\"当使用WITH CHECK OPTION 子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插入、删除 更新，以使其符合视图的定义。MySQL允许基于另一个视图创建视图，他还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，MySQL提供了两个选项：CASCADED、LOCAL，默认值为CASCADED。\",\"CASCADED会强制检查当前视图和其依赖的视图的筛选条件。\",\"LOCAL会检查当前视图，并且检查定义检查条件的依赖的视图。\",\"简单理解\",\"可以简单的理解为CASCADED是强制检查所有相关的视图，无论是否定义，而LOCAL只会检查定义检查条件的视图。\"]},\"165\":{\"h\":\"更新及作用\"},\"166\":{\"h\":\"视图的更新\",\"t\":[\"要使视图可以更新，视图中的行与基础表中的行之间必须存在一对一的关系，如果视图包含了以下任意一项，则该视图就不可更新：\",\"聚合函数或者窗口函数(SUM()、MIN()、MAX()、COUNT()等)；\",\"DISTINCT\",\"GROUP BY\",\"HAVING\",\"UNION 或者 UNION ALL\"]},\"167\":{\"h\":\"视图的作用\",\"t\":[\"简单\",\"视图不仅可以简化用户对数据的理解，也可以简化他们的操作，那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的查询条件。\",\"安全\",\"数据库可以授权，但是不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据。\"]},\"168\":{\"h\":\"MySQL运维 - 读写分离\"},\"169\":{\"h\":\"MySQL 数据库\"},\"170\":{\"h\":\"学习目录\",\"t\":[\"基础篇 \",\"MySQL基础\",\"SQL基础语法\",\"函数\",\"约束\",\"多表查询\",\"事务\",\"进阶篇 \",\"存储引擎\",\"索引\",\"SQL优化\",\"视图\",\"存储过程\",\"触发器\",\"锁\",\"InnoDB引擎\",\"MySQL管理\",\"运维篇 \",\"日志\",\"主从复制\",\"分库分表\",\"读写分离\"]},\"171\":{\"h\":\"参考资料\",\"t\":[\"博主在学习MySQL数据库时参考的了黑马程序员出品的《MySQL从入门到精通 从mysql安装到mysql高级、mysql优化全囊括》的系列课程，这里在此对黑马开源教学视频，表示感谢。\",\"视频地址\",\"https://www.bilibili.com/video/BV1Kr4y1i7ru\",\"除了参考视频教程外，还阅读了《MySQL必知必会》这本工具书。书的PDF资料在这里下载。\",\"PDF下载\",\"链接: https://pan.baidu.com/s/1qThvvyOXlFioEi09GIlM6w?pwd=nrtj\",\"提取码: nrtj\"]},\"172\":{\"h\":\"MySQL基础 - SQL基础语法\"},\"173\":{\"h\":\"通用语法\",\"t\":[\"SQL语句可以单行或者多行书写，以分号结尾。\",\"SQL语句可以使用空格/缩进符来增强语句的可读性。\",\"MySQL数据库的SQL语言不区分大小写，关键字建议使用大写。\",\"注释\",\"注释\",\"单行注释：-- 注释内容 或者 # 注释内容(MySQL特有的语法)\",\"多行注释：使用/* 注释内容 */\"]},\"174\":{\"h\":\"SQL分类\",\"t\":[\"DDL\",\"Data Definition Language 数据定义语言，用来定义数据库对象（数据库、数据表、字段）\",\"DML\",\"Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改\",\"DQL\",\"Data Query Language 数据查询语言，用来对数据库中的数据进行查询操作\",\"DCL\",\"Data Control Language 数据控制语言，用来创建数据库用户、控制数据表的访问权限\"]},\"175\":{\"h\":\"DDL语句\"},\"176\":{\"h\":\"数据库操作\",\"t\":[\"查询\",\"查询所有数据库\",\"SHOW DATABASES; \",\"查询当前数据库\",\"SELECT DATABASE(): \",\"创建\",\"CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFULT CHARSET 字符集] [COLLATE 排序规则]; \",\"删除\",\"DROP DATABASE [IF EXISTS] 数据库名; \",\"使用\",\"USE 数据库名; \"]},\"177\":{\"h\":\"数据表操作\",\"t\":[\"查询\",\"查询当前数据库的所有表\",\"SHOW TABLES; \",\"查询表结构\",\"DESC 表名; \",\"查询指定表的建表语句\",\"SHOW CREATE TABLE 表名; \",\"创建\",\"CREATE TABLE 表名( 字段1 字段1类型 [COMMENT 字段1注释], 字段2 字段2类型 [COMMENT 字段2注释], 字段3 字段3类型 [COMMENT 字段3注释], ...... 字段n 字段n类型 [COMMENT 字段n注释] )[COMMENT 表注释]; \",\"提示\",\"[]代表可选参数，并且最后一个字段后没有逗号，最后以分号结尾。\",\"删除\",\"删除表\",\"DROP TABLE [IF EXISTS]表名； \",\"删除指定数据表，并且重新创建该表\",\"TRUNCATE TABLE 表名; \",\"说明\",\"删除数据表后，会讲数据表内的所有数据清空。这里的功能可以看作，将数据表内的所有数据全部清空。但是实际上的操作流程是将表删除，然后重新创建。而DELETE * FROM 表名语句能够将所有的数据清空，但是例如字段自增的序号和建立的一些索引等是不会被清除的。\",\"修改\",\"修改表名\",\"ALTER TABLE 旧表名 RENAME [TO] 新表名; \",\"提示\",\"这里的[TO]是可有可无的，没有也不会对SQL语句造成歧义，影响功能，写上以后会使SQL的可读性更高。\",\"修改表字符集\",\"ALTER TABLE 表名 [DEFAULT] CHARACTER SET 字符集名 [DEFAULT] COLLATE 校对规则名; \",\"表内字段修改\",\"说明\",\"由于对表字段的修改，也可以归纳为字段操作，且其操作较多，就将其全部归纳到字段操作里。即下一小节。\"]},\"178\":{\"h\":\"字段操作\",\"t\":[\"添加字段\",\"ALTER TABLE 表名 ADD 字段名 字段数据类型(长度)[COMMENT 字段注释][约束]; \",\"删除字段\",\"ALTER TABLE 表名 DROP 字段名; \",\"修改字段\",\"修改数据类型\",\"ALTER TABlE 表名 MODIFY 字段名 新数据类型(长度); \",\"修改字段名称和字段类型\",\"ALTER TABlE 表名 CHANGE 旧字段名 新字段名 数据类型(长度)[COMMENT 字段注释][约束]; \"]},\"179\":{\"h\":\"DML语句\",\"t\":[\"说明\",\"理论上讲DML数据操作语言，应该包含增、删、改、查4个部分，但是由于数据查询的操作使用频繁，且种类繁多，我们将其抽取出来，单独作为一个章节，为DQL进行说明，这里就只了解增、删、改这三个操作。\"]},\"180\":{\"h\":\"添加数据\",\"t\":[\"给指定字段添加数据\",\"INSERT INTO 表名 (字段1,字段2,...,字段n) VALUES (值1,值2,...,值n); \",\"给全部字段添加数据\",\"INSERT INTO 表名 VALUES (值1,值2,...,值n); \",\"批量添加数据\",\"-- 指定字段添加数据 INSERT INTO 表名 (字段1,字段2,...,字段n) VALUES (值1,值2,...,值n),...,(值1,值2,...,值n); -- 全部字段添加数据 INSERT INTO 表名 VALUES (值1,值2,...,值n),...,(值1,值2,...,值n); \",\"注意\",\"插入数据时指定的字段顺序需要于值的顺序是一一对应的\",\"字符串和日期型数据应该包含在引号之中\",\"插入的数据大小，应该在字段数据类型的规定范围以内\"]},\"181\":{\"h\":\"修改数据\",\"t\":[\"UPDATE 表名 SET 字段名1 = 值1,字段名2 = 值2,.... [WHERE 条件]; \",\"危险警告\",\"涉及的数据的修改时，需要严格谨慎检查自己的SQL语句，这里修改数据的筛选条件可有可无，但是没有筛选条件时则会修改整张表的所有数据。\"]},\"182\":{\"h\":\"删除数据\",\"t\":[\"DELETE FROM 表名 [WHERE 条件]; \",\"危险警告\",\"涉及的数据的删除时，和前面的数据修改相同，需要严格谨慎检查自己的SQL语句，这里删除数据的筛选条件可有可无，但是没有筛选条件时则会删除整张表的所有数据。\",\"DELETE语句只能按行删除数据，不能只删除某一个字段的值，不过可以使用UPDATE语句来进行修改。\"]},\"183\":{\"h\":\"DQL语句\"},\"184\":{\"h\":\"DQL语法\",\"t\":[\"SELECT 字段列表 FROM 表名 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 \"]},\"185\":{\"h\":\"查询类型\",\"t\":[\"基本查询\",\"条件查询（WHERE）\",\"聚合查询（count、max、min、avg、sum）\",\"分组查询（GROUP BY）\",\"排序查询（ORDER BY）\",\"分页查询（LIMIT）\"]},\"186\":{\"h\":\"基本查询\",\"t\":[\"查询多个字段\",\"-- 指定字段 SELECT 字段1,字段2,字段3,... FROM 表名; -- 所有字段 SELECT * FROM 表名; \",\"设置别名\",\"SELECT 字段1 [AS 别名1],字段2 [AS 别名2],... FROM 表名; \",\"去除重复记录\",\"SELECT DISTINCT 字段列表 FROM 表名; \"]},\"187\":{\"h\":\"条件查询\",\"t\":[\"语法\",\"SELECT 字段列表 FROM 表名 WHERE 条件列表; \",\"条件\",\"运算符\",\"功能\",\">\",\"大于\",\">=\",\"大于等于\",\"<\",\"小于\",\"<=\",\"小于等于\",\"<>或者!=\",\"不等于\",\"BETWEEN...AND...\",\"在某个范围之内,包含临界值\",\"IN(...)\",\"在in之后的列表中，多选之\",\"LIKE 占位符\",\"模糊匹配(_匹配单个字符，%匹配任意个字符)\",\"IS NULL\",\"是否为NULL\",\"AND 或者 &&\",\"并且(同时成立)\",\"OR 或者 ||\",\"或者(成立任意一个即可)\",\"NOT 或者 !\",\"非，不是\"]},\"188\":{\"h\":\"聚合查询\"},\"189\":{\"h\":\"聚合函数\",\"t\":[\"介绍 将一列数据作为一个整体，进行纵向计算\",\"常见的聚合函数\",\"函数\",\"功能\",\"count\",\"统计数量\",\"max\",\"最大值\",\"min\",\"最小值\",\"avg\",\"平均值\",\"sum\",\"求和\",\"语法\",\"SELECT 聚合函数(字段列表) FROM 表名; \",\"注意\",\"null值不参与所有聚合函数运算。\"]},\"190\":{\"h\":\"分组查询\",\"t\":[\"语法\",\"SELECT 字段列表 FROM 表名 [WHERE 条件列表] GROUP BY 分组字段名 [HAVING 分组后的过滤条件]; \",\"WHERE 和 HAVING 区别 执行时机不同：where是分组之前进行过滤，不符合where条件的不参与分组，而having是在分组之后进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。\",\"注意\",\"执行顺序：where > 聚合函数 > having\",\"分组以后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义\"]},\"191\":{\"h\":\"排序查询\",\"t\":[\"语法\",\"SELECT 字段列表 FROM 表名 ORDER BY 字段1 [排序方式1],字段2 [排序方式2],...; \",\"排序方式\",\"ASC : 升序(默认值)\",\"DESC : 降序\",\"提示\",\"如果是多字段排序，只有当第一个字段的值相同时，才会根据第二个字段比较，以此类推。\"]},\"192\":{\"h\":\"分页查询\",\"t\":[\"语法\",\"SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数; \",\"注意\",\"起始索引从0开始，起始索引 = (查询的页码 - 1) * 每页显示的记录数\",\"分页查询是数据库的方言，不同的数据库拥有不同的语法实现，MySQL中使用的是LIMIT子句实现\",\"如果查询的是第一页数据，起始索引可以省略，直接简写为LIMIT 查询记录数，如LIMIT 10。\"]},\"193\":{\"h\":\"执行顺序\",\"t\":[\"SELECT -- 5 字段列表 FROM -- 1 表名 WHERE -- 2 条件列表 GROUP BY-- 3 分组字段列表 HAVING -- 4 分组后条件列表 ORDER BY-- 6 排序字段列表 LIMIT -- 7 分页参数 \"]},\"194\":{\"h\":\"DCL语句\",\"t\":[\"DCL全称为Data Control Language(数据控制语言)，用来管理数据库 用户，控制数据库的访问权限。\"]},\"195\":{\"h\":\"用户控制\",\"t\":[\"查询用户\",\"USE mysql; SELECT * FROM user; \",\"创建用户\",\"CREATE USER '用户名'@'主机名' IDENTIFIED BY ‘密码’; \",\"删除用户\",\"DROP USER ‘'用户名'@'主机名'; \",\"修改用户\",\"ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY ‘新密码’; \",\"注意\",\"在MySQL数据库中，所有的用户信息和用户权限信息都存储于mysql数据库内的表中。\",\"主机名可以使用 % 通配。\",\"这类SQL开发人员操作的比较少，通常是DBA(Database Adminstrator数据库管理员)使用\"]},\"196\":{\"h\":\"权限控制\",\"t\":[\"MySQL中定义了很多种权限，但是常用的就以下几种：\",\"权限\",\"说明\",\"ALL、ALL PRIVILEGES\",\"所有权限\",\"SELECT\",\"查询数据权限\",\"INSERT\",\"插入数据权限\",\"UPDATE\",\"更新数据权限\",\"DELETE\",\"删除数据权限\",\"ALTER\",\"修改表权限\",\"DROP\",\"删除数据库/数据表权限\",\"CREATE\",\"创建数据库/数据表权限\",\"查询权限\",\"SHOW GRANTS FOR '用户名'@'主机名'; \",\"授予权限\",\"GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名'; \",\"撤销权限\",\"REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名'; \",\"提示\",\"多个权限之间，使用逗号分隔\",\"授权时，数据库名和表名可以使用 * 进行通配，代表所有。\"]},\"197\":{\"h\":\"MySQL进阶 - SQL优化\"},\"198\":{\"h\":\"insert优化\"},\"199\":{\"h\":\"批量插入\",\"t\":[\"insert into table_name values (values_list...); \",\"一次性可以插入多个数据，来减少多次请求带来的性能消耗，但是一次性插入的数据量不建议超过500-1000条。\"]},\"200\":{\"h\":\"手动提交事务\",\"t\":[\"start transaction; insert into table_name values (values_list1...); insert into table_name values (values_list2...); insert into table_name values (values_list3...); commit; \",\"在多次数据插入时，可以手动开启事务，将数据分组提交。\"]},\"201\":{\"h\":\"主键顺序插入\",\"t\":[\"主键乱序：8 5 3 6 9 4 2 1 7 10 主键有序：1 2 3 4 5 6 7 8 9 10 \",\"提示\",\"主键有序插入比主键乱序插入的速度要快，这是由于MySQL底层的数据结构造成的，我们在下一章节的主键优化里详细说明。\"]},\"202\":{\"h\":\"大批量数据插入\",\"t\":[\"如果一次性需要插入大量的数据，使用insert语句插入的性能不高，此时可以使用MySQL提供的load指令进行插入。\",\"load指令可以将文件内的数据，一次性加载进数据库内。\",\"具体操作如下：\",\"-- 客户端连接服务端时，加上参数 --local-infile mysql --local-infile -u root -p -- 设置全局参数为local_infile = 1，开启从本地加载文件导入数据库的开关 set global local_infile = 1; -- 执行load指令，将准备好的数据加载到数据表内 load data local infile 'file_path' into table `table_name` fields terminated by 'split_char' lines terminated by 'line_break'; \",\"参数说明\",\"file_path : 存储数据文件的路径地址\",\"table_name : 要插入数据的数据表名称\",\"split_char : 行内数据字段分隔符号\",\"line_break : 换行分隔符，即以什么标准判断数据行之间的分隔。\"]},\"203\":{\"h\":\"primery key优化\"},\"204\":{\"h\":\"数据的组织方式\",\"t\":[\"在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table IOT）。\",\"而InnoDB存储引擎中，默认的聚集索引就是主键索引。\",\"逻辑存储结构\",\"参数说明\",\"TableSpace：表空间，内存储的是segment段\",\"Segment：段，其存储的是extent区\",\"Extent：区，其存储的是page页【固定1M】\",\"Page：页，其内存储的是row行【固定16k】\",\"Row：行，其内存储的是数据行\",\"这里的Extent和Page的空间大小是固定的，每个Extent区占据1M，每个Page页占据16K，则一个extent内包含了64个page\"]},\"205\":{\"h\":\"页分裂\",\"t\":[\"页可以为空，也可以填充一半，也可以填充100%。每个页包含了 2 - N 行数据，如果一行的数据过大，会行溢出，根据主键排序。\",\"我们分别从 主键顺序插入 和 主键乱序插入 这两个角度来探究这个问题：\",\"主键顺序插入 主键顺序插入数据，由于数据在页内存储会根据主键排序，那么此时所有的数据在页内都会顺序排列，页内剩余空间不足时，则开启下一个页，尽可能的保证了空间的利用率。也不存在数据的移动问题。\",\"主键乱序插入 同理，数据按主键排序，那么在主键乱序插入一组数据以后，此时页内的数据是有序的，但是如果下一次想要插入的数据主键不为最大值，那么此时需要将数据插入到页中，而不是直接添加到页尾，则此时需要进行数据的移动。\",\"主键乱序插入\",\"先开启一个新的数据页，page3\",\"将page1中50%的位置，将后半段数据移动到page3\",\"将主键为50的这行数据，插入到page3的末尾。\",\"由于要保证page之间有序，还需要调整页间指针的方向，调整为 page1 -> page3 -> page2\",\"此时则完成了数据的插入。\",\"小知识\",\"我们将这种页面分裂的现象，叫做页分裂。那么在插入时会伴随页分裂，则相同的在数据删除时，就会出现页合并。\"]},\"206\":{\"h\":\"页合并\",\"t\":[\"当删除一行记录时，实际上并没有将记录值物理删除，只是记录被标记（flaged）为删除并且他的空间变得允许被其他记录值重新声明。当页中删除的记录达到MERGE_THRESHOLD(默认为页的50%)，innoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。\",\"小贴士\",\"MERGE_THRESHOLD：合并页的阀值，可以自己设置，在创建表或者创建索引时指定。\"]},\"207\":{\"h\":\"主键设计原则\",\"t\":[\"满足业务需求的情况下，尽量降低主键的长度。\",\"插入数据时，尽量使用顺序插入，选择使用AUTO_INCREMENT自增主键。\",\"尽量不要使用UUID做主键或者是其他自然主键，如身份证号。\",\"业务操作时避免对主键的修改。\"]},\"208\":{\"h\":\"order by优化\"},\"209\":{\"h\":\"查询类别\",\"t\":[\"Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫做FileSort排序。\",\"Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为Using index，不需要额外排序，操作效率较高。\",\"对于满足排序列表的索引，在order by查询时是直接通过索引进行查询，是Using index，而不满足排序列表的索引则会通过全表扫描，是Using filesort\"]},\"210\":{\"h\":\"举例说明\",\"t\":[\"举个简单的例子：\",\"select id,age,name from tb_name order by age; \",\"在没有建立任何索引的情况下，这条SQL是通过全表扫描进行查询的，但是如果对age字段建立索引，则再进行查询时，是通过索引查询的，Using index。\",\"这里也是满足索引的最左前缀法则，即只要从左往右开始，有字段存在符合的索引，则就可以通过索引进行查询，如果全部都能通过索引则仅为Using index，否则为Using index和Using filesort并存。\",\"注意\",\"建立索引时也会区分字段的排序规则，有ASC和DESC两种，默认为ASC。\",\"如果存在和排序列表中相符合或者完全相反的索引，那么都是可以使用索引进行查询的，完全相同时则无可厚非，直接进行查询即可，而完全相反时只需要反向扫描即可。\"]},\"211\":{\"h\":\"注意事项\",\"t\":[\"根据排序字段建立合适的索引，多字段排序时，也是遵循最最前缀法则的。\",\"尽量使用覆盖索引。\",\"多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC、DESC）。\",\"如何不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size（默认为256k）。\"]},\"212\":{\"h\":\"group by优化\"},\"213\":{\"h\":\"查询类型\",\"t\":[\"Using index : 使用索引，直接使用索引对相关的信息进行查询。\",\"Using temporary : 使用中间表，需要通过建立中间临时表对所需要的数据进行查询，效率相对较低。\"]},\"214\":{\"h\":\"注意事项\",\"t\":[\"在分组操作时，可以通过索引来提高效率。\",\"分组操作时，索引的使用也是满足最左前缀法则的。\",\"尽量建立联合索引，覆盖索引，避免回表查询。\"]},\"215\":{\"h\":\"limit优化\"},\"216\":{\"h\":\"优化场景\",\"t\":[\"对limit来讲，从越大数据开始的分页，耗时越长。需要对此优化。\"]},\"217\":{\"h\":\"举例说明\",\"t\":[\"如：返回 2000000 - 200010的数据，其他数据全部丢弃，此时查询的代价就比较大。\"]},\"218\":{\"h\":\"优化思路\",\"t\":[\"一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。\"]},\"219\":{\"h\":\"count优化\",\"t\":[\"MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高。\",\"但是对于InnoDB引擎，它count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。\"]},\"220\":{\"h\":\"优化思路\",\"t\":[\"自己计数，不通过InnoDB引擎提供的计数方式进行计算。\",\"例如\",\"我们在使用Redis时，将数据量的存储起来，对于数据的变动，维护好这个存储的变量即可。\",\"也可以建立相关的表，于使用Redis类似，维护好数据表内的数据即可。\"]},\"221\":{\"h\":\"count的用法\",\"t\":[\"count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是Null，累计值就加1，否则不加，最后返回累计值。\",\"count(*) InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。\",\"count(主键)\",\"InnoDB引擎会遍历整张表，把每一行的主键ID值都取出来，返回给服务层。服务层拿到主键以后，直接按行进行累加（主键不可能为null）\",\"count(字段) 没有not null约束：innoDB引擎会遍历整张表，把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。\",\"有not null约束：InnoDB引擎会遍历整张表，把每一行的字段值都取出来，返回给服务层，直接按行进行累加。\",\"count(1) InnoDB引擎遍历整张表，但不取值，服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。\",\"效率排行\",\"count(字段) < count(主键 id) < count(1) ≈ count(*)\",\"尽量使用count(*)\"]},\"222\":{\"h\":\"update优化\"},\"223\":{\"h\":\"注意事项\",\"t\":[\"InnoDB引擎中的行锁是针对索引加的锁，不是针对记录值加的锁，并且该索引不能失效，否则会从行锁升级为表锁。\",\"提示\",\"所以在更新操作时，尽量使用主键、索引字段进行更新，以减少在并发环境下，造成的影响。\"]},\"224\":{\"h\":\"举例说明\",\"t\":[\"如未使用索引字段进行数据更新，则在筛选该数据记录值时会进行全表扫描，则会占用的是整张表的资源。\"]},\"225\":{\"h\":\"MySQL进阶 - SQL性能分析\"},\"226\":{\"h\":\"SQL执行频率\",\"t\":[\"MySQL客户端连接成功后，通过 SHOW [session | global] status 命令可以查看服务器状态信息。\",\"通过如下指令，可以查看当前数据库的INSERT、SELECT、UPDATE、DELETE操作的访问频次：\",\"SHOW GLOBAL STATUS LIKE \\\"Com_______\\\"; \",\"需要注意的是，这里一共有7个空格。\",\"这里查询完成以后就能够看到增删改查的执行次数。\",\"Com_insert：插入\",\"Com_update：更新\",\"Com_select：查询\",\"Com_delete：删除\",\"性能查询\",\"我们可以根据这个数据来判断我们主要对那些操作进行优化。\"]},\"227\":{\"h\":\"慢查询日志\",\"t\":[\"慢查询日志记录了所有执行时间超过指定参数(long_query_time，单位：秒，默认10秒)的所有SQL语句的日志。\",\"MySQL中默认不开启慢查询日志，开启的话需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：\",\"-- 开启MySQL中的慢查询 slow_query_log = 1 -- 设置慢查询的 时间为2秒钟，SQL语句执行超过两秒，则会被视为慢查询，记录慢查询日志 long_query_time = 2 \",\"配置完毕以后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息/var/lib/mysql/localhost-slow.log\",\"功能\",\"慢查询日志主要就是为了记录那些查询时间较长的SQL语句，方便于我们的优化。\",\"前景提要\",\"通过慢查询日志，我们能够找到查询时间较低的SQL，但是有时候我们对于SQL已经优化到了极致，由于数据量的巨大，无法再压缩SQL的执行时间，或者有些SQL本应该很快执行完毕，但是仍耗费了很长时间，而耗费的时间又在我们慢日志统计时间的临界值，而这类SQL是非常需要我们进行优化的。这两种情况时，需要优化的没有被统计，而无法优化的又被统计到，那么此时慢查询就无法满足我们的需求，这时候就需要使用Profile分析。\"]},\"228\":{\"h\":\"Profile分析\",\"t\":[\"show profiles分析能够在做SQL优化时帮助我们了解时间都耗费到哪去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作：\",\"查看是否支持profile\",\"SELECT @@have_profiling; \",\"默认情况下profile是关闭的，可以通过 set 语句在 globle|session 级别开启profiling;\",\"开启profile\",\"set [session|globle] profile = 1; \",\"查看每一条执行过的SQL语句的耗时情况\",\"show profiles; \",\"查看指定query_id 的SQL语句各个阶段的耗时情况\",\"shwo profile for query query_id; \",\"查看指定query_id 的SQL语句的CPU的使用情况\",\"show profile cpu for query query_id; \"]},\"229\":{\"h\":\"explain执行计划\",\"t\":[\"前景提要\",\"前面我们了解的几种方法要么通过SQL的执行频率，要么通过SQL的执行时间来判断SQL是否需要优化，而这些方式并不能够真正的评判一条SQL的性能。\",\"explain 或者 desc 命令获取MySQL如何执行SELECT语句的信息，包括SELETC语句执行过程中表如何连接和连接的顺序。\",\"语法\",\"-- 直接在SELECT语句之前加上关键字 explain 或者 desc EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件列表; \",\"explain执行计划各字段的含义：\",\"id SELECT 查询的序列号，表示查询中执行 SELECT 子句或者是操作表的顺序（id相同，执行顺序从上到下；id不同，值越大，越先执行）。\",\"select_type 表示SELECT的类型，常见的取值有SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等。\",\"type【重要】 表示连接类型，性能由好到差的连接类型为：NULL、system、const、eq_ref、ref、range、index、all。\",\"possible_key 显示可能应用到这张表上的索引，一个或者多个。\",\"key 实际使用的索引，如果为NULL，则表示没有使用索引。\",\"key_len 表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，再不损失精度的前提下，长度越短越小。\",\"rows MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。\",\"filtered 表示查询返回结果的行数占需要的读取行数的百分比，filtered的值越大越好。\",\"extra\\n备注信息，一般为NULL。\"]},\"230\":{\"h\":\"MySQL进阶 - 存储引擎\"},\"231\":{\"h\":\"MySQL的体系结构\",\"t\":[\"MySQL的体系结构示意图\",\"连接层 连接层处于MySQL体系结构中的最上层，是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、以及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。\",\"服务层 服务层处于MySQL体系结构中的第二层，主要完成大多书的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有存储引擎的功能也在这一层实现，如 过程、函数等。\",\"引擎层\",\"引擎层处于MySQL体系结构中的第三层，真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。\",\"存储层 存储层位于MySQL结构体系的最底层，主要是将数据存储在文件系统之上，完成与存储引擎的交互。\"]},\"232\":{\"h\":\"存储引擎简介\",\"t\":[\"存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式，存储引擎是基于表的，而不是基于库的，所以存储引擎也可以被称为表的类型。\",\"也就是说，同一个数据库的不同表可以选择不同的存储引擎。\",\"查看支持的存储引擎\",\"SHOW ENGINES; \",\"存储引擎列表\",\"创建一张表并且指定引擎\",\"create table users( id int primary key auto_increment, username varchar(10) )engine=InnoDB \",\"该SQL代表的意思是：创建一张名为users的表，其中有id和username两个字段，并且设置存储引擎为InnoDB\"]},\"233\":{\"h\":\"存储引擎特点\"},\"234\":{\"h\":\"InnoDB\",\"t\":[\"介绍 InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL5.5以后，InnoDB是默认的MySQL存储引擎。\",\"特点\",\"DML操作遵循ACID模型，支持事务\",\"行级锁，提高并发访问性能\",\"支持外键FOREIGN KEY约束，保证数据的完整性和正确性\",\"文件xxx.ibd：xxx代表的是数据表名，InnoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表架构(frm、sdi)、数据和索引。\",\"参数：innodb_file_per_table\",\"show variables like 'innodb_file_per_table'; \",\"优点：提供良好的事务管理、崩溃修复能力和并发控制。\",\"缺点：读写效率稍差，空间占用比较大。\"]},\"235\":{\"h\":\"MyISAM\",\"t\":[\"介绍 MyISAM是MySQL早期的默认存储引擎。\",\"特点\",\"不支持事务，不支持外键\",\"支持表锁，但不支持行锁\",\"访问速度快\",\"文件\",\"xxx.sdi：存储表结构信息\",\"xxx.MYD：存储数据\",\"xxx.MYI：存储索引\"]},\"236\":{\"h\":\"Memory\",\"t\":[\"介绍 Memory存储引擎的表数据存储在内存中，由于受到硬件问题、断电问题的影响，只能将这些表作为临时表或者缓存使用。\",\"特点\",\"存放在内存中，访问速度快\",\"支持Hash索引(\",\"文件 xxx.sdi：存储表结构信息，只有这一个，索引和数据均存储在内存中。\",\"特点\",\"InnoDB\",\"MyISAM\",\"Memory\",\"存储限制\",\"64TB\",\"有\",\"有\",\"事务安全\",\"支持\",\"-\",\"-\",\"锁机制\",\"行锁\",\"表锁\",\"表锁\",\"B+tree索引\",\"支持\",\"支持\",\"支持\",\"Hash索引\",\"-\",\"-\",\"支持\",\"全文索引\",\"支持\",\"支持\",\"-\",\"空间使用\",\"高\",\"低\",\"N/A\",\"内存使用\",\"高\",\"低\",\"中等\",\"批量插入速度\",\"低\",\"高\",\"高\",\"支持外键\",\"支持\",\"-\",\"-\"]},\"237\":{\"h\":\"存储引擎选择\",\"t\":[\"在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。\",\"InnoDB : 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。\",\"MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。\",\"Memory：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。但更多时候选择Redis数据库。\"]},\"238\":{\"h\":\"MySQL进阶 - 存储过程\"},\"239\":{\"h\":\"介绍\",\"t\":[\"存储过程是事先经过编译并且存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。\",\"存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。\",\"个人理解\",\"这里我个人理解的是 类似于 编程语言中的函数，将一些语句封装起来，直接进行函数的调用即可。\",\"特点\",\"封装、复用\",\"可以接收参数，也可以返回数据\",\"减少网络交互，效率提升\"]},\"240\":{\"h\":\"基本语法\",\"t\":[\"创建\",\"CREATE PROCEDURE 存储过程名称([参数列表]) BEGIN -- SQL语句 END; \",\"注意\",\"在命令行中，执行创建存储过程的SQL时，需要通过关键字delimiter指定SQL语句的结束符。\",\"例如：delimiter $$ ，即定义为 $$ 为结束标识符。\",\"则此时不会以默认的 ; 为结束标识符，而是我们设置的$$，但是存储过程中的SQL语句，还是以 ; 为结束符号。\",\"调用\",\"CALL 名称([参数列表]); \",\"查看\",\"-- 查询指定数据库的存储过程及状态信息 SELECT * FROM INFORMATION_SCHEMA_ROUTINES WHERE ROUTINE_SCHEMA = 'xxx'； -- 查询某个存储过程的定义 SHOW CREATE PROCEDURE 存储过程名称; \",\"删除\",\"DROP PROCEDURE [IF EXISTS] 存储过程名称; \"]},\"241\":{\"h\":\"变量\"},\"242\":{\"h\":\"系统变量\",\"t\":[\"系统变量是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全面变量(GLOBAL)、会话变量(SESSION)。\",\"查看系统变量\",\"-- 查看所有系统变量 SHOW [SESSION | GLOBAL] VARIABLES; -- 可以通过LIKE模糊匹配的方式查找变量 SHOW [SESSION | GLOBAL] VARIABLES LIKE '.....'; -- 查看指定变量的值 SELECT @@[SESSION. | GLOBAL.]系统变量名; \",\"设置系统变量\",\"SET [SESSION | GLOBAL] 系统变量名 = 值; SET @@[SESSION. | GLOBAL.]系统变量名 = 值; \",\"注意\",\"如果没有指定SESSION | GLOBAL，默认是SESSION，会话变量。\",\"MySQL服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 /etc/my.cnf 中配置。\"]},\"243\":{\"h\":\"用户自定义变量\",\"t\":[\"用户自定义变量是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用\\\"@变量名\\\" 使用就可以。其作用域为当前的连接。\",\"赋值\",\"-- 使用SET SET @var_name = expr[,@var_name = expr]...; SET @var_name := expr[,@var_name := expr]...; -- 使用SELECT SELECT @var_anme := expr [,@var_name := expr]...; SELECT 字段名 INTO @var_name FROM 表名; \",\"提示\",\"在赋值时我们能看到有两种写法， = 和 := 。这两个实际上没有区别，但是在MySQL中，判断相等的运算符是 = 而不是 == ，这就容易造成混淆，所以推荐使用 :=\",\"使用\",\"SELECT @var_name; \",\"注意\",\"用户定义的变量无需对其进行声明或者初始化，只不过获取到的值为NULL\"]},\"244\":{\"h\":\"局部变量\",\"t\":[\"局部变量是根据需要定义的在局部生效的变量，访问之前，需要使用DECLARE声明，可以作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN......END块。\",\"声明\",\"DECLARE 变量名 变量类型 [DEFAULT ...]; \",\"变量类型就是数据库字段类型:INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。\",\"赋值\",\"SET 变量名 = 值; SET 变量名 := 值; SELECT 字段名 INTO 变量名 FROM 表名 ...; \"]},\"245\":{\"h\":\"IF判断\",\"t\":[\"语法\",\"IF 条件1 THEN ... ELSEIF 条件2 THEN -- 可选 ... ELSE -- 可选 ... END IF; \"]},\"246\":{\"h\":\"参数\",\"t\":[\"类型\",\"含义\",\"备注\",\"IN\",\"该类参数作为输入，也就是需要调用时传入值\",\"默认\",\"OUT\",\"该类参数作为输出，也就是该参数可以作为返回值\",\"INOUT\",\"既可以作为输入参数，也可以作为输出参数\",\"用法\",\"CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型]) BEGIN -- SQL语句 END; \"]},\"247\":{\"h\":\"case\",\"t\":[\"语法1\",\"CASE case_value WHEN when_value1 THEN statement_list1 [WHEN when_value2 THEN statement_list2] [ELSE statement_list] END CASE; \",\"语法2\",\"CASE WHEN search_condition1 THEN statement_list1 [WHEN search_condition2 THEN statement_list2] [ELSE statement_list] END CASE; \"]},\"248\":{\"h\":\"循环\"},\"249\":{\"h\":\"WHILE循环\",\"t\":[\"while循环时有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句，具体语法为：\",\"-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑 WHILE 条件 DO -- SQL逻辑 END WHILE; \"]},\"250\":{\"h\":\"REPEAT循环\",\"t\":[\"repeat是有条件的循环控制语句，当满足条件的时候推出循环。具体语法为：\",\"-- 先执行一次逻辑，然后判定逻辑是否满足，如果满足，则退出。如果不满足，则继续下一次循环。 REPEAT SQL逻辑 UNTIL条件 END REPEAT; \",\"提示\",\"类似于编程语言中的 do ... while() 循环，但是repeat是满足条件则推出和do while刚好相反。\"]},\"251\":{\"h\":\"LOOP循环\",\"t\":[\"Loop实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。loop可以配合以下两个语句使用：\",\"LEAVE : 必须用在循环中，退出循环。\",\"ITERATE : 必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。\",\"[begin_lable:] LOOP SQL逻辑 END LOOP [end_lable]; -- 退出指定标记的循环体 LEAVE lable; -- 直接进入下一次循环 ITERATE lable; \",\"提示\",\"leave和iterate相当于编程语言中的 break和continue关键字的用法。\"]},\"252\":{\"h\":\"游标\",\"t\":[\"游标CURSOR是用来存储查询结果的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH和CLOSE，其语法如下：\",\"声明游标\",\"DECLEAR 游标名称 CURSOR FOR 查询语句; \",\"打开游标\",\"OPEN 游标名称; \",\"获取游标记录\",\"FETCH 游标名称 INTO 变量[,变量...]; \",\"关闭游标\",\"CLOSE 游标名称; \"]},\"253\":{\"h\":\"条件处理程序\",\"t\":[\"条件处理程序Handler可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：\",\"DECLARE handler_action HANDLER FOR condition_value [,condition_value] ... statement; \",\"handler_action \",\"CONTINUE:继续执行当前程序\",\"EXIT:终止执行当前程序\",\"condition_value \",\"SQLSTATE sqlstate_value:状态码，如02000\",\"SQLWARNING:所有以01开头的SQLSTATE代码的简写\",\"NOT FOUND:所有以02开头的SQLSTATE代码的简写\",\"SQLEXCEPTION:所有没有被SQLWARNING或者NOT FOUND捕获的SQLSTATE代码的简写\"]},\"254\":{\"h\":\"存储函数\",\"t\":[\"存储函数就是有返回值的存储过程，存储函数的参数只能是IN类型的，具体语法如下：\",\"CREATE FUNCTION 存储函数名称([参数列表]) RETURNS type [characteristic ...] BEGIN -- SQL语句 RETURN ...; END; \",\"characteristic说明：\",\"DETERMINSRIC：相同的输入参数总是产生相同的结果\",\"NO SQL：不包含SQL语句\",\"READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句、\",\"比较\",\"存储函数就是必须有返回值的存储过程，存储过程的范围 > 存储函数的范围。\",\"存储函数是通过函数调用，而存储过程是使用call调用\"]},\"255\":{\"h\":\"MySQL基础 - 事务\",\"t\":[\"事务是一组操作的集合，他是一个不可分隔的工作单位，事务会把所有的操作作为一个整体一起向系统提交或者撤销操作请求，即这些操作要么同时成功，要么同时失败。\"]},\"256\":{\"h\":\"事务操作\",\"t\":[\"查看/设置事务提交方式\",\"SELECT @@autocommit; SET @@autocommit = 0; \",\"说明\",\"这里的@@autocommit 属性的值有两种：\",\"1：则开启自动提交\",\"0：关闭自动提交，此时事务执行完毕时，需要我们使用指令进行提交。\",\"开启事务\",\"START TRANSACTION; -- 或者 BEGIN; \",\"提交事务\",\"COMMIT; \",\"回滚事务\",\"ROLLBACK; \"]},\"257\":{\"h\":\"事务的四大特性\",\"t\":[\"提示\",\"事务的ACID特性，是面试中经常被问到的一个知识点，也是实际业务中容易出错的一个点，需要认真学习。\",\"原子性(Atomicity):事务是不可分割的最小操作单元，要么全部成功，要么全部失败。\",\"一致性(Consistency):事务完成时，必须使得所有的数据都保持一致状态。\",\"隔离性(Isolation):数据库提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。\",\"持久性(Durability):事务一旦提交或者回滚，它对数据库中数据的改变就是永久的。\"]},\"258\":{\"h\":\"事务并发问题\",\"t\":[\"在单线程环境下，对数据库的任何操作都是安全的。但是在并发环境下，对数据库进行事务操作，可能会产生一系列的问题。\",\"问题\",\"描述\",\"脏读\",\"一个事务读到另外一个事务还没有提交的数据。\",\"不可重复读\",\"一个事务先后读取同一条记录，但是两次读取的数据不一致\",\"幻读\",\"一个事务按照指定条件查询数据时，没有对应的数据记录值，但是在插入操作时，又发现数据已经存在。删除现象也是如此\"]},\"259\":{\"h\":\"事务的隔离级别\",\"t\":[\"隔离级别\",\"脏读\",\"不可重复读\",\"幻读\",\"Read Uncommitted(读未提交)\",\"✅\",\"✅\",\"✅\",\"Read Committed(读已提交)\",\"❌\",\"✅\",\"✅\",\"Repeatable Read\",\"❌\",\"❌\",\"✅\",\"Serializable(串行化)\",\"❌\",\"❌\",\"❌\",\"查看事务的隔离级别\",\"SELECT @@TRANSACTION_ISOLATION; \",\"设置事务的隔离级别\",\"SET [Session|Global] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE} \",\"注意\",\"事务的隔离级别越高，数据的安全性也越高，但是性能越低。\"]},\"260\":{\"h\":\"Redis 数据库\",\"t\":[\"Redis\"]},\"261\":{\"h\":\"大纲\"},\"262\":{\"h\":\"Redis入门\",\"t\":[\"Redis入门 - Redis概念和基础\",\"Redis入门 - 基础通用指令\",\"Redis入门 - 5种基本数据类型\",\"Redis入门 - 3种特殊数据类型\",\"Redis入门 - 发布订阅\",\"Redis入门 - 事务\",\"Redis入门 - Lua脚本\",\"Redis入门 - Redis Stream\"]},\"263\":{\"h\":\"Redis客户端\",\"t\":[\"Redis客户端 - Jdies快速入门\",\"Redis客户端 - Jedis连接池\",\"Redis客户端 - SpringDataRedis\",\"Redis客户端 - RedisSerializer\"]},\"264\":{\"h\":\"Redis进阶\",\"t\":[\"Redis进阶 - 缓存问题\",\"Redis进阶 - Redis持久化\",\"Redis进阶 - Redis主从\",\"Redis进阶 - Redis哨兵\",\"Redis进阶 - Redis分片集群\",\"Redis进阶 - JVM进程缓存\",\"Redis进阶 - Lua语法\",\"Redis进阶 - 多级缓存\",\"Redis进阶 - 缓存同步\",\"Redis进阶 - 键值设计\",\"Redis进阶 - 批处理优化\",\"Redis进阶 - 服务端优化\",\"Redis进阶 - 集群最佳实践\"]},\"265\":{\"h\":\"Redis原理\",\"t\":[\"Redis原理 - RedisObject对象机制\",\"Redis原理 - 数据结构的底层实现\",\"Redis原理 - 五种数据类型的底层结构关系\",\"Redis原理 - IO详解\",\"Redis原理 - Redis网络模型\",\"Redis原理 - 通信协议RESP\",\"Redis原理 - 内存策略\"]},\"266\":{\"h\":\"参考资料\",\"t\":[\"菜鸟教程\",\"博主在使用Redis数据库时，经常查阅菜鸟教程编写的《Redis教程》系列文档，这里表示感谢。\",\"文档地址\",\"https://www.runoob.com/redis/\",\"黑马程序员\",\"博主在学习Redis数据库时参考的了黑马程序员出品的《Redis入门到实战教程》的系列课程，这里在此对黑马开源教学视频，表示感谢。\",\"视频地址\",\"https://www.bilibili.com/video/BV1cr4y1671t\",\"Java全栈知识体系\",\"视频地址\",\"https://www.pdai.tech/\"]},\"267\":{\"h\":\"Redis进阶 - 批处理优化\"},\"268\":{\"h\":\"Redis进阶 - 缓存问题\"},\"269\":{\"h\":\"缓存\",\"t\":[\"缓存就是数据交换的缓冲区（Cache），是存储数据的临时地方，一般读写性能比较高。\",\"例如\",\"内存是硬盘的缓存\",\"cache 是内存的缓存\",\"作用\",\"降低后端负载\",\"提高读写效率，降低响应时间\",\"成本\",\"数据一致性成本\",\"代码维护成本\"]},\"270\":{\"h\":\"缓存穿透\",\"t\":[\"缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。如请求不存在的数据，则 Redis 缓存中不存在，数据库中也不存在，频繁请求，造成资源的浪费。\",\"解决方案\",\"缓存空对象 \",\"优点：实现简单，维护方便\",\"缺点：1. 额外的内存消耗。 2. 可能造成短期的不一致\",\"布隆过滤 \",\"优点：内存占用小，没有多余的key\",\"缺点：1. 实现复杂 2. 存在误判可能\",\"增强ID的复杂度，避免被猜测ID规律\",\"做好数据的基础格式校验\"]},\"271\":{\"h\":\"缓存雪崩\",\"t\":[\"缓存雪崩是指在同一时间段内，大量的缓存 Key 同时失效或者 Redis 服务宕机，导致瞬间大量请求到达数据库，带来巨大压力。\",\"解决方案\",\"给不同的 Key 的TTL添加随机值\",\"利用 Redis 集群提高服务的可用性\",\"给缓存业务添加降级限流操作\",\"给业务添加多级缓存\"]},\"272\":{\"h\":\"缓存击穿\",\"t\":[\"缓存击穿问题也叫热点 key 问题，就是一个被高并发访问并且缓存重建业务较复杂的 key 突然失效，无数的请求访问会在瞬间给数据库带来巨大的冲击。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库，导致请求数据库的总量比较大。\",\"解决方案\",\"互斥锁 \",\"查询缓存，未命中\",\"获取锁，再更新缓存\",\"更新完以后，释放锁\",\"逻辑过期\",\"解决方案\",\"优点\",\"缺点\",\"互斥锁\",\"1. 没有额外的内存消耗 2. 保证一致性 3. 实现简单\",\"1. 线程需要等待，性能受影响 2. 可能有死锁风险\",\"逻辑过期\",\"线程无需等待，性能较好\",\"1. 不保证一致性 2. 有额外内存消耗 3. 实现复杂\"]},\"273\":{\"h\":\"缓存污染\",\"t\":[\"缓存污染问题指的是缓存中一些只会被访问一次或者几次的数据，被访问完以后，再也不会被访问到，但这部分数据依然留在缓存中，占用缓存空间。\",\"缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会被访问的数据。然而缓存空间是有限的，如果缓存写满了，再往缓存中存储数据时就会有额外的性能开销，影响 Redis 的性能。这部分开销主要是指往缓存中写数据时判断缓存淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。\",\"最大缓存设置多少\",\"系统的设计选择是一个权衡的过程：大容量缓存是能带来性能加速的收益，但是成本也会更高，而小容量缓存不一定就起不到加速访问的效果。一般来说，我会建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销。对于 Redis 来说，一旦确定了缓存最大容量，比如 4GB，你就可以使用下面这个命令来设定缓存的大小了：\",\"CONFIG SET maxmemory 4gb \",\"不过，缓存被写满是不可避免的, 所以需要数据淘汰策略。\",\"缓存淘汰策略\",\"具体的放到下一个小节来说\"]},\"274\":{\"h\":\"缓存更新策略\",\"t\":[\"内存淘汰\",\"超时剔除\",\"主动更新\",\"说明\",\"不用自己维护，利用 Redis 的内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存\",\"给缓存数据添加TTL时间，到期后自动删除缓存。下次查询时更新缓存。\",\"编写业务逻辑，在修改数据库的同时，更新缓存。\",\"一致性\",\"差\",\"一般\",\"好\",\"维护成本\",\"无\",\"低\",\"高\",\"业务场景：\",\"低一致性需求：数据的变化频率低，使用内存淘汰机制。例如：店铺类型的查询缓存。\",\"高一致性需求：数据经常发生改变，主动更新，并以超时剔除作为兜底方案。例如：店铺详情查询的缓存。\"]},\"275\":{\"h\":\"主动更新策略\",\"t\":[\"Cache Aside Pattern：由缓存的调用者，在更新数据库的同时更新缓存。\",\"Read/Write Through Pattern：缓存和数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。\",\"Write Behind Caching Pattern：调用者只操作缓存，由其他线程异步的将缓存数据持久化到数据库，保证最终一致。\",\"一般情况下都使用第一种方法，可控性更高。\",\"在操作缓存时，数据库发生修改则直接删除对应的缓存，待查询时再创建缓存。\",\"单体系统，将缓存和数据库操作放在同一个事务内。\",\"分布式系统，使用TCC等分布式事务方案。\",\"先操作数据库，在删除缓存。\"]},\"276\":{\"h\":\"缓存淘汰策略\",\"t\":[\"Redis 一共支持 8 种淘汰策略\",\"noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键。\",\"allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键。\",\"volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键。\",\"allkeys-random：加入键的时候如果过限，从所有key随机删除。\",\"volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐。\",\"volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键。\",\"volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键。\",\"allkeys-lfu：从所有键中驱逐使用频率最少的键。\"]},\"277\":{\"h\":\"Redis进阶 - 缓存同步\"},\"278\":{\"h\":\"Redis进阶 - 集群最佳实践\"},\"279\":{\"h\":\"Redis进阶 - JVM进程缓存\",\"t\":[\"传统缓存的问题\",\"传统的缓存策略一般是请求到达 Tomcat 后，先查询 Redis ，如果未命中则查询数据库，存在下面的问题：\",\"请求要经过 Tomcat 处理，Tomcat 的性能成为整个系统的瓶颈\",\"Redis 缓存失效时，会对数据库产生冲击\",\"多级缓存方案\",\"多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻 Tomcat 压力，提升服务性能：\"]},\"280\":{\"h\":\"本地进程缓存\",\"t\":[\"缓存在日常开发中起着至关重要的作用，由于是存储在内存汇总，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们把缓存分为两类：\",\"分布式缓存：例如 Redis\",\"优点：存储容量更大、可靠性更好、可以再集群间共享\",\"缺点：访问缓存有网络开销\",\"场景：缓存数据量较大、可靠性要求较高、需要在集群间共享\",\"进程本地缓存：例如 HashMap、GuavaCache\",\"优点：读取本地内存，没有网络开销，速度更快\",\"缺点：存储容量有限、可靠性能较低、无法共享\",\"场景：性能要求较高，缓存数据量较小\",\"Caffeine 是一个基于 Java8 开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前 Spring 内部的缓存使用的就是 Caffeine。\",\"Github 地址：https://github.com/ben-manes/caffeine\"]},\"281\":{\"h\":\"Caffeine\",\"t\":[\"Caffeine 是一个基于 Java8 开发的提供了近乎最佳命中率的高性能的缓存库。\",\"缓存和 ConcurrentMap 有点相似，但还是有所区别。最根本的区别是 ConcurrentMap 将会持有所有加入到缓存当中的元素，直到它们被从缓存当中手动移除。但是，Caffeine 的缓存 Cache 通常会被配置成自动驱逐缓存中元素，以限制其内存占用。在某些场景下，LoadingCache 和AsyncLoadingCache 因为其自动加载缓存的能力将会变得非常实用。\",\"Caffeine 提供了灵活的构造器去创建一个拥有下列特性的缓存：\",\"自动加载元素到缓存当中，异步加载的方式也可供选择\",\"当达到最大容量的时候可以使用基于就近度和频率的算法进行基于容量的驱逐\",\"将根据缓存中的元素上一次访问或者被修改的时间进行基于过期时间的驱逐\",\"当向缓存中一个已经过时的元素进行访问的时候将会进行异步刷新\",\"key 将自动被弱引用所封装\",\"value 将自动被弱引用或者软引用所封装\",\"驱逐(或移除)缓存中的元素时将会进行通知\",\"写入传播到一个外部数据源当中\",\"持续计算缓存的访问统计指标\",\"为了提高集成度，扩展模块提供了 JSR-107 JCache 和 Guava 适配器。 JSR-107 规范了基于 Java 6 的 API，在牺牲了功能和性能的代价下使代码更加规范。\",\"Guava 的 Cache 是 Caffeine 的原型库并且 Caffeine 提供了适配器以供简单的迁移策略。\",\"原文地址\",\"https://github.com/ben-manes/caffeine/wiki/Home-zh-CN\"]},\"282\":{\"h\":\"Caffeine示例\",\"t\":[\"@Test void testCaffeine(){ // 1.创建缓存对象 Cache<String,String> cache = Caffeine.newBuilder().build(); // 2.存数据 cache.put(\\\"username\\\",\\\"codermast\\\"); // 3.1取数据，不存在则返回 Null String username = cache.getIfPresent(\\\"username\\\"); System.out.println(\\\"username = \\\" + username); // 3.2取数据，不存在则从数据库查询 String username2 = cache.get(\\\"username\\\",key -> { // 这里写的是去数据库查询的业务逻辑 // ... return \\\"Hello World!\\\"; }); System.out.println(\\\"username2 = \\\" + username2); } \"]},\"283\":{\"h\":\"Caffeine缓存驱逐策略\",\"t\":[\"Caffeine 提供了三种缓存驱逐策略：\",\"基于容量：设置缓存的数量上限，使用 LRU 规则选择\",\"// 创建缓存对象 Cache<String,String> cache = Caffeine.newBuilder() .maximumSize(1) // 设置缓存大小上限为 1 .build(); \",\"基于时间：设置缓存的有效时间\",\"// 创建缓存对象 Cache<String,String> cache = Caffeine.newBuilder() .expireAfterWrite(Duration.ofSeconds(10)) // 设置缓存有效期为 10 s，从最后一次写入操作开始计时 .build(); \",\"基于引用：设置缓存为软引用或者弱引用，利用 GC 来回收缓存数据。性能较差，不建议使用。\",\"在默认情况下，当一个缓存元素过期的时候，Caffeine 不会自动立即将其清理和驱逐。而是在一次读或者写操作后，或者在空闲时间完成对失效数据的驱逐。\",\"注释\",\"JVM 进程缓存和 Redis 缓存，本质上都是对数据的缓存，目的都是为了加速数据的读取。\"]},\"284\":{\"h\":\"Redis进阶 - 键值设计\"},\"285\":{\"h\":\"Redis进阶 - Lua语法\"},\"286\":{\"h\":\"初识 Lua\",\"t\":[\"Lua 是一种轻量小巧的脚本语言，用标准的 C 语言编写并以源代码形式开放，其设计的目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。\",\"官网：https://www.lua.org/\"]},\"287\":{\"h\":\"快速入门\",\"t\":[\"在 Linux 虚拟机的任意目录下，新建一个 hello.lua 文件\",\"touch hello.lua \",\"添加下面的内容\",\"print(\\\"Hello World!\\\") \",\"运行\",\"lua hello.lua \",\"运行结果\",\"Hello World! \"]},\"288\":{\"h\":\"变量\",\"t\":[\"在正式了解变量之前，需要先对 Lua 中的数据类型有个简单的了解，下面是 Lua 语言中的一些数据类型。\",\"数据类型\",\"描述\",\"nil\",\"这个最简单，只有值 nil 属于该类型，表示一个无效值（在条件表达式中相当于 false）\",\"boolean\",\"包含两个数：false 和 true\",\"number\",\"表示双精度类型的实浮点数\",\"string\",\"字符串由一对双引号或者单引号来表示\",\"function\",\"由 C 或者 Lua 编写的函数\",\"table\",\"Lua 中的表（table）其实是一个 “关联数组” （associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过 “构造表达式” 来完成，最简单的构造表达式是 {} ，用来创建一个空表。\",\"Lua 声明变量的时候，并不需要指定数据类型：\",\"声明字符串：local str = 'hello'\",\"声明数字：local num = 21\",\"声明布尔类型：local flag = true\",\"声明数组 key 为索引的 table ：local arr = {'Java', 'Python' , 'Lua'}\",\"声明 table ，类似 Java 的 Map：local map = {name = 'Jack', age = 21}\",\"访问 table 的几种方式：\",\"角标访问(从 1 开始)：table[1]\",\"Key 访问： \",\"map['name']\",\"map.name\"]},\"289\":{\"h\":\"循环\",\"t\":[\"一组被重复执行的语句称之为循环体，能否继续重复，决定循环的终止条件。\",\"循环结构是在一定条件下反复执行某段程序的流程结构，被反复执行的程序被称为循环体。\",\"循环语句是由循环体及循环的终止条件两部分组成的。\",\"While循环：在判断条件为 true 时会重复执行循环体语句\",\"while(condition) do statements end \",\"For循环：可以重复执行指定语句，重复次数可在 for 语句中控制。\",\"for var=exp1,exp2,exp3 do <执行体> end \",\"泛型for循环：通过一个迭代器函数来遍历所有值\",\"a = {\\\"one\\\", \\\"two\\\", \\\"three\\\"} for i, v in ipairs(a) do print(i, v) end \",\"i是数组索引值，v是对应索引的数组元素值。ipairs是Lua提供的一个迭代器函数，用来迭代数组。\",\"Repeat循环：在条件进行判断前循环体都会执行一次，然后才进行条件判断。\",\"repeat statements until( condition ) \",\"类似于 do ... while ... 循环\"]},\"290\":{\"h\":\"条件\",\"t\":[\"在布尔表达式为 true 时会if中的代码块会被执行，在布尔表达式为 false 时，紧跟在 if 语句 end 之后的代码会被执行。\",\"Lua认为false和nil为假，true 和非nil为真。要注意的是Lua中 0 为 true。\",\"if(布尔表达式) then --[ 布尔表达式为 true 时执行该语句块 --] else --[ 布尔表达式为 false 时执行该语句块 --] end \"]},\"291\":{\"h\":\"函数\",\"t\":[\"optional_function_scope function function_name( argument1, argument2, argument3..., argumentn) function_body return result_params_comma_separated end \",\"optional_function_scope: 该参数是可选的指定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。\",\"function_name: 指定函数名称。\",\"argument1, argument2, argument3..., argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。\",\"function_body: 函数体，函数中需要执行的代码语句块。\",\"result_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。\",\"Lua函数可以返回多个结果值，比如string.find，其返回匹配串\\\"开始和结束的下标\\\"（如果不存在匹配串返回nil）。\",\"> s, e = string.find(\\\"www.runoob.com\\\", \\\"runoob\\\") > print(s, e) 5 10 \",\"Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 ... 表示函数有可变的参数。\",\"资料\",\"https://www.runoob.com/lua/lua-tutorial.html\"]},\"292\":{\"h\":\"Redis进阶 - Redis主从\"},\"293\":{\"h\":\"搭建主从架构\",\"t\":[\"单节点 Redis 的并发能力是有上限的，要进一步提高 Redis 的并发能力，就需要搭建主从集群，实现读写分离。\",\"在 Redis 5.0 以前，从节点都叫做 slave，在 5.0 版本以后被称为 replica，本质上是一个东西。\"]},\"294\":{\"h\":\"1.集群结构\",\"t\":[\"我们搭建的主从集群结构如图：\",\"共包含三个节点，一个主节点，两个从节点。\",\"这里我们会在同一台虚拟机中开启3个redis实例，模拟主从集群，信息如下：\",\"IP\",\"PORT\",\"角色\",\"192.168.150.101\",\"7001\",\"master\",\"192.168.150.101\",\"7002\",\"slave\",\"192.168.150.101\",\"7003\",\"slave\"]},\"295\":{\"h\":\"2.准备实例和配置\",\"t\":[\"要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。\",\"创建目录\",\"我们创建三个文件夹，名字分别叫7001、7002、7003：\",\"# 进入/tmp目录 cd /tmp # 创建目录 mkdir 7001 7002 7003 \",\"恢复原始配置\",\"修改redis-6.2.4/redis.conf文件，将其中的持久化模式改为默认的RDB模式，AOF保持关闭状态。\",\"# 开启RDB # save \\\"\\\" save 3600 1 save 300 100 save 60 10000 # 关闭AOF appendonly no \",\"拷贝配置文件到每个实例目录\",\"然后将redis-6.2.4/redis.conf文件拷贝到三个目录中（在/tmp目录执行下列命令）：\",\"# 方式一：逐个拷贝 cp redis-6.2.4/redis.conf 7001 cp redis-6.2.4/redis.conf 7002 cp redis-6.2.4/redis.conf 7003 # 方式二：管道组合命令，一键拷贝 echo 7001 7002 7003 | xargs -t -n 1 cp redis-6.2.4/redis.conf \",\"修改每个实例的端口、工作目录\",\"修改每个文件夹内的配置文件，将端口分别修改为7001、7002、7003，将rdb文件保存位置都修改为自己所在目录（在/tmp目录执行下列命令）：\",\"sed -i -e 's/6379/7001/g' -e 's/dir .\\\\//dir \\\\/tmp\\\\/7001\\\\//g' 7001/redis.conf sed -i -e 's/6379/7002/g' -e 's/dir .\\\\//dir \\\\/tmp\\\\/7002\\\\//g' 7002/redis.conf sed -i -e 's/6379/7003/g' -e 's/dir .\\\\//dir \\\\/tmp\\\\/7003\\\\//g' 7003/redis.conf \",\"修改每个实例的声明IP\",\"虚拟机本身有多个IP，为了避免将来混乱，我们需要在redis.conf文件中指定每一个实例的绑定ip信息，格式如下：\",\"# redis实例的声明 IP replica-announce-ip 192.168.150.101 \",\"每个目录都要改，我们一键完成修改（在/tmp目录执行下列命令）：\",\"# 逐一执行 sed -i '1a replica-announce-ip 192.168.150.101' 7001/redis.conf sed -i '1a replica-announce-ip 192.168.150.101' 7002/redis.conf sed -i '1a replica-announce-ip 192.168.150.101' 7003/redis.conf # 或者一键修改 printf '%s\\\\n' 7001 7002 7003 | xargs -I{} -t sed -i '1a replica-announce-ip 192.168.150.101' {}/redis.conf \"]},\"296\":{\"h\":\"3.启动\",\"t\":[\"为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：\",\"# 第1个 redis-server 7001/redis.conf # 第2个 redis-server 7002/redis.conf # 第3个 redis-server 7003/redis.conf \",\"如果要一键停止，可以运行下面命令：\",\"printf '%s\\\\n' 7001 7002 7003 | xargs -I{} -t redis-cli -p {} shutdown \"]},\"297\":{\"h\":\"4.开启主从关系\",\"t\":[\"现在三个实例还没有任何关系，要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。\",\"有临时和永久两种模式：\",\"修改配置文件（永久生效）\",\"在redis.conf中添加一行配置：slaveof <masterip> <masterport>\",\"使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）：\",\"slaveof <masterip> <masterport> \",\"：在5.0以后新增命令replicaof，与salveof效果一致。\",\"这里我们为了演示方便，使用方式二。\",\"通过redis-cli命令连接7002，执行下面命令：\",\"# 连接 7002 redis-cli -p 7002 # 执行slaveof slaveof 192.168.150.101 7001 \",\"通过redis-cli命令连接7003，执行下面命令：\",\"# 连接 7003 redis-cli -p 7003 # 执行slaveof slaveof 192.168.150.101 7001 \",\"然后连接 7001节点，查看集群状态：\",\"# 连接 7001 redis-cli -p 7001 # 查看状态 info replication \"]},\"298\":{\"h\":\"5.测试\",\"t\":[\"执行下列操作以测试：\",\"利用redis-cli连接7001，执行set num 123\",\"利用redis-cli连接7002，执行get num，再执行set num 666\",\"利用redis-cli连接7003，执行get num，再执行set num 888\",\"可以发现，只有在7001这个master节点上可以执行写操作，7002和7003这两个slave节点只能执行读操作。\"]},\"299\":{\"h\":\"数据同步原理\"},\"300\":{\"h\":\"全量同步\",\"t\":[\"主从第一次同步是全量同步：\",\"master 是如何判断 slave 是不是第一次来同步数据？这里会用到两个很重要的概念：\",\"Replication ID：简称replid，是数据集的标记，id 一致则说明是同一数据集。每一个 master 都有位移的 replid，slave 则会继承 master 节点的 replid。\",\"Offset：偏移量，随着记录在 repl_baklog 中的数据增多而逐渐增大。slave 完成同步时也会记录当前同步的 offset。如果 slave 的 offset 小于 master 的 offset，说明 slave 数据落后于 master，需要更新。\",\"因此 slave 做数据同步，必须想 master 声明自己的 replication id 和 offset，master 才可以判断到底需要同步哪些数据。\",\"先判断 replication id 是否相同，再判断 offset 的大小关系。\",\"全量同步的流程\",\"slave 节点请求增量同步\",\"master 节点判断 replid，发现不一致，拒绝增量同步。\",\"master 将完整内存数据生成 RDB，发送 RDB到 slave\",\"slave 清空本地数据，加载master 的 RDB\",\"master 将 RDB 期间的命令记录在 repl_baklog，并持续将 log 中的命令发送给 slave\",\"slave 收到接受的命令，保持与 master 之间的同步。\"]},\"301\":{\"h\":\"增量同步\",\"t\":[\"主从第一次同步是全量同步，但如果 slave 冲去后同步，则执行增量同步。\",\"注意\",\"repl_baklog 大小有上限，写满以后会覆盖最早的数据。如果 slave 断开时间过久，导致数据被覆盖，则无法实现增量同步，只能再次全量同步。\",\"可以从以下几个方面来优化 Redis 主从集群：\",\"在 master 中配置 repl_diskless-sync yes 启用无磁盘复制，避免全量同步时的磁盘 IO。一般适用于网络带宽较大的情况下。\",\"Redis 单节点上的内存占用不要太大，减少 RDB 导致的过多磁盘 IO。\",\"适当提高 repl_baklog 的大小，发现 slave 宕机时尽快实现故障恢复，尽可能避免全量同步\",\"限制一个 master 上的 slave 节点数量，如果实在是太多 slave，则可以采用 主-从-从链式结构，减少 master 压力\"]},\"302\":{\"h\":\"总结\",\"t\":[\"简述全量同步和增量同步的区别？\",\"全量同步：master 将完整内存数据生成 RDB，发送 RDB 到 slave。后续命令则记录在repl_baklog，逐个发送给 slave。\",\"增量同步：slave 提交自己的 offset 到 master，master 获取 repl_baklog 中从 offset 之后的命令给 slave\",\"什么时候执行全量同步？\",\"slave 节点第一次连接 master 节点时。\",\"slave 节点断开时间太久，repl_baklog 中的 offset 已经被覆盖时\",\"什么时候执行增量同步？\",\"slave 节点断开又恢复，并且在 repl_baklog 中能找到 offset 时。\"]},\"303\":{\"h\":\"Redis进阶 - 多级缓存\"},\"304\":{\"h\":\"安装OpenResty\",\"t\":[\"在正式安装 OpenResty 之前，我们需要了解它是干什么的。\",\"OpenResty® 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。\",\"OpenResty® 通过汇聚各种设计精良的 Nginx 模块（主要由 OpenResty 团队自主开发），从而将 Nginx 有效地变成一个强大的通用 Web 应用平台。这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。\",\"OpenResty® 的目标是让你的Web服务直接跑在 Nginx 服务内部，充分利用 Nginx 的非阻塞 I/O 模型，不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。\",\"OpenResty官网：https://openresty.org/cn/\"]},\"305\":{\"h\":\"1.安装\",\"t\":[\"首先你的Linux虚拟机必须联网\",\"安装开发库\",\"首先要安装OpenResty的依赖开发库，执行命令：\",\"yum install -y pcre-devel openssl-devel gcc --skip-broken \",\"安装OpenResty仓库\",\"你可以在你的 CentOS 系统中添加 openresty 仓库，这样就可以便于未来安装或更新我们的软件包（通过 yum check-update 命令）。运行下面的命令就可以添加我们的仓库：\",\"yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo \",\"如果提示说命令不存在，则运行：\",\"yum install -y yum-utils \",\"然后再重复上面的命令\",\"安装OpenResty\",\"然后就可以像下面这样安装软件包，比如 openresty：\",\"yum install -y openresty \",\"安装opm工具\",\"opm是OpenResty的一个管理工具，可以帮助我们安装一个第三方的Lua模块。\",\"如果你想安装命令行工具 opm，那么可以像下面这样安装 openresty-opm 包：\",\"yum install -y openresty-opm \",\"目录结构\",\"默认情况下，OpenResty安装的目录是：/usr/local/openresty\",\"看到里面的nginx目录了吗，OpenResty就是在Nginx基础上集成了一些Lua模块。\",\"配置nginx的环境变量\",\"打开配置文件：\",\"vi /etc/profile \",\"在最下面加入两行：\",\"export NGINX_HOME=/usr/local/openresty/nginx export PATH=${NGINX_HOME}/sbin:$PATH \",\"NGINX_HOME：后面是OpenResty安装目录下的nginx的目录\",\"然后让配置生效：\",\"source /etc/profile \"]},\"306\":{\"h\":\"2.启动和运行\",\"t\":[\"OpenResty底层是基于Nginx的，查看OpenResty目录的nginx目录，结构与windows中安装的nginx基本一致：\",\"所以运行方式与nginx基本一致：\",\"# 启动nginx nginx # 重新加载配置 nginx -s reload # 停止 nginx -s stop \",\"nginx的默认配置文件注释太多，影响后续我们的编辑，这里将nginx.conf中的注释部分删除，保留有效部分。\",\"修改/usr/local/openresty/nginx/conf/nginx.conf文件，内容如下：\",\"#user nobody; worker_processes 1; error_log logs/error.log; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 8081; server_name localhost; location / { root html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } \",\"在Linux的控制台输入命令以启动nginx：\",\"nginx \",\"然后访问页面：http://192.168.150.101:8081，注意ip地址替换为你自己的虚拟机IP：\"]},\"307\":{\"h\":\"3.备注\",\"t\":[\"加载OpenResty的lua模块\",\"#lua 模块 lua_package_path \\\"/usr/local/openresty/lualib/?.lua;;\\\"; #c模块 lua_package_cpath \\\"/usr/local/openresty/lualib/?.so;;\\\"; \",\"common.lua\",\"-- 封装函数，发送http请求，并解析响应 local function read_http(path, params) local resp = ngx.location.capture(path,{ method = ngx.HTTP_GET, args = params, }) if not resp then -- 记录错误信息，返回404 ngx.log(ngx.ERR, \\\"http not found, path: \\\", path , \\\", args: \\\", args) ngx.exit(404) end return resp.body end -- 将方法导出 local _M = { read_http = read_http } return _M \",\"释放Redis连接API：\",\"-- 关闭redis连接的工具方法，其实是放入连接池 local function close_redis(red) local pool_max_idle_time = 10000 -- 连接的空闲时间，单位是毫秒 local pool_size = 100 --连接池大小 local ok, err = red:set_keepalive(pool_max_idle_time, pool_size) if not ok then ngx.log(ngx.ERR, \\\"放入redis连接池失败: \\\", err) end end \",\"读取Redis数据的API：\",\"-- 查询redis的方法 ip和port是redis地址，key是查询的key local function read_redis(ip, port, key) -- 获取一个连接 local ok, err = red:connect(ip, port) if not ok then ngx.log(ngx.ERR, \\\"连接redis失败 : \\\", err) return nil end -- 查询redis local resp, err = red:get(key) -- 查询失败处理 if not resp then ngx.log(ngx.ERR, \\\"查询Redis失败: \\\", err, \\\", key = \\\" , key) end --得到的数据为空处理 if resp == ngx.null then resp = nil ngx.log(ngx.ERR, \\\"查询Redis数据为空, key = \\\", key) end close_redis(red) return resp end \",\"开启共享词典：\",\"# 共享字典，也就是本地缓存，名称叫做：item_cache，大小150m lua_shared_dict item_cache 150m; \"]},\"308\":{\"h\":\"OpenResty快速入门\",\"t\":[\"这里我们使用 nginx 拦截 http 请求，处理后返回数据。\"]},\"309\":{\"h\":\"步骤1 修改nginx.conf文件\",\"t\":[\"在 nginx.conf 的 http 下面，添加对 OpenResty 的 Lua 模块支持\",\"# 加载 lua 模块 lua_package_path \\\"/usr/local/openresty/lualib/?.lua;;\\\"; # 加载 c 模块 lua_package_cpath \\\"/usr/local/openresty/lualib/?.so;;\\\"; \",\"在 nginx.conf 的 serevr 下面，添加对 /api/item 这个路径的监听：\",\"location /api/item { # 响应类型，这里返回 json default_type application/json # 响应数据由 lua/item.lua 这个文件来决定 content_by_lua_file lua/item.lua; } \"]},\"310\":{\"h\":\"步骤2 编写item.lua文件\",\"t\":[\"在 nginx 目录创建文件夹：lua\",\"mkdir lua \",\"在 lua 文件夹下，新建文件：item.lua\",\"touch lua/item.lua \",\"内容如下\",\"-- 返回假数据，这里的 ngx.say() 函数，就是写数据到 Response 中 ngx.say('{\\\"id\\\": 10001, \\\"name\\\" : \\\"Coder Mast\\\"}'); \",\"重新加载配置\",\"nginx -s reload \"]},\"311\":{\"h\":\"OpenResty获取请求参数\",\"t\":[\"OpenResty 提供了各种 API 用来获取不同类型的请求参数：\",\"参数格式\",\"参数示例\",\"参数解析代码示例\",\"路径占位符\",\"/item/1001\",\"请求头\",\"id:1001\",\"Get请求参数\",\"?id=1001\",\"Post表单参数\",\"id=1001\",\"Json参数\",\"{\\\"id\\\":1001}\",\"代码详情\",\"- 路径占位符 # 1. 正则表达式匹配： location ~ /item/(\\\\d+) { content_by_lua_file lua/item.lua; } \",\"-- 2. 匹配到的参数会存入 ngx.var 数组中，可以使用角标获取 lcoal id = ngx.var[1] \",\"请求头\",\"Get请求参数\",\"Post表单参数\",\"Json参数\"]},\"312\":{\"h\":\"封装Http请求工具\"},\"313\":{\"h\":\"向Tomcat发送http请求\"},\"314\":{\"h\":\"根据商品id对Tomcat集群负载均衡\"},\"315\":{\"h\":\"Redis缓存预热\"},\"316\":{\"h\":\"查询Redis\"},\"317\":{\"h\":\"Nginx本地缓存\"},\"318\":{\"h\":\"Redis进阶 - Redis持久化\",\"t\":[\"单点Redis的问题\",\"数据丢失问题：Redis 是内存存储，服务重启可能会丢失数据。通过实现 Redis 数据持久化解决。\",\"并发能力问题：单节点 Redis 并发能力虽然不错，但是也无法满足如 618 这样的高并发场景。搭建主从集群，实现读写分离解决。\",\"故障恢复问题：如果 Redis 宕机，则服务不可用，需要一种自动的故障恢复手段。利用 Redis 哨兵，实现健康检测和自动恢复。\",\"存储能力问题：Redis 基于内存，单点能存储的数据量难以满足海量数据需求。搭建分片集群，利用插槽机制实现动态扩容。\"]},\"319\":{\"h\":\"RDB持久化\",\"t\":[\"RDB 全称为 Redis Database Backup file （Redis 数据备份文件），也被叫做 Redis 数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当 Redis 实例故障重启后，从磁盘读取快照文件，恢复数据。\",\"快照文件称为 RDB 文件，默认是保存在当前运行目录。\",\"save命令：创建 RDB 快照，由 Redis 主进程来执行，会阻塞所有命令。RDB 是需要写入磁盘中，IO 操作较慢。\",\"bgsave命令：开启子进程执行 RDB ，避免主进程受到影响。\",\"Redis 停机时会执行一次 RDB 。\",\"默认情况下会在当前目录生成一个 dump.rdb 的文件，下一次启动 Redis 时，默认会加载这个文件，恢复 Redis 数据。\",\"Redis 内部有触发 RDB 的机制，可以在 redis.conf 文件中找到，格式如下：\",\"save 900 1 // 900 秒内，如果至少有 1 个 key 被修改，则执行 bgsave save 300 10 // 300 秒内，如果至少有 10 个 key 被修改，则执行 bgsave save 60 10000 // 60 秒内，如果至少有 10000 个 key 被修改，则执行 bgsave save \\\"\\\" // 表示禁用 RDB rdbcompression yes // 是否压缩，建议不开启，压缩也会消耗 CPU ，磁盘空间相对廉价 dbfilename dump.rdb // RDB 文件名称 dir ./ // 文件保存的路径目录 \",\"bgsave 开始时会 fork 主进程得到子进程，子进程共享主进程的内存数据。完成 fork 后读取内存数据并写入 RDB 文件。\",\"fork 过程是阻塞的，此时 Redis 无法响应客户端请求。fork 的速度是非常快的，因为 fork 只复制了对应的页表，而不是复制真实的数据，类似于只复制数据的索引。\",\"fork 采用的是 copy-on-write 技术：\",\"当主进程执行读操作时，访问共享内存\",\"当主进程执行写操作时，则会拷贝一份数据，执行写操作。\",\"极端情况\",\"当子进程写新的 RDB 文件时，此时主进程大量修改数据，则需要对数据进行拷贝，当主进程需要对所有的数据都进行修改时，则需要两倍原来的内存，故我们在配置 Redis 服务时，不能将所有的实际内存分配给 Redis ，需要预留一部分缓冲空间。\",\"RDB 方式 bgsave 的流程：\",\"fork 主进程得到一个子进程，共享内存空间\",\"子进程读取内存数据并写入新的 RDB 文件\",\"用新的 RDB 文件替换旧的 RDB 文件\",\"RDB 会在什么时候执行？save 60 1000代表什么含义？\",\"默认是在 Redis 服务停止时执行 RDB。\",\"save 60 10000代表60秒内至少执行 1000 次修改则触发 RDB\",\"RDB 的缺点？\",\"RDB 执行间隔时间长，两次 RDB 之间写入数据有丢失的风险\",\"fork 子进程、压缩、写出 RDB 文件都比较耗时\"]},\"320\":{\"h\":\"AOF持久化\",\"t\":[\"AOF 全称为 Append Only File（追加文件）。Redis 处理的每一个写命令都会记录在 AOF 文件，可以看做是命令日志文件。\",\"AOF 默认是关闭的，需要修改 redis.conf 配置文件来开启 AOF\",\"appendonly yes // 是否开启 AOF 功能，默认是关闭的 appendfilename \\\"appendonly.aof\\\" // AOF 的文件名称 \",\"AOF 的命令记录的频率也可以通过 redis.conf 文件来进行配置：\",\"appendfsync always // 表示每执行一次写命令，立刻记录到 AOF 文件中 appendfsync everysec // 写命令执行完先放入 AOF 缓冲区，然后每隔 1 秒将缓冲区数据写入到 AOF 文件，是默认方案 appendfsync no // 写命令执行完先放入 AOF 缓冲区，由操作系统决定何时将缓冲区内容写回磁盘 \",\"配置项\",\"刷盘时机\",\"优点\",\"缺点\",\"Always\",\"同步刷盘\",\"可靠性高，几乎不丢数据\",\"性能影响大\",\"everysec\",\"每秒刷盘\",\"性能适中\",\"最多丢失1秒数据\",\"no\",\"操作系统控制\",\"性能最好\",\"可靠性差，可能丢失大量数据\",\"AOF 是记录命令，AOF 文件会比 RDB 文件大很多。而且 AOF 会记录对同一个 key 的 多次写操作，但只有最后一次写操作才有意义。通过执行 bgrewriteaof 命令，可以让 AOF 文件执行重写功能，用最少的命令达到相同效果。\",\"Redis 也会在触发阈值时自动去重写 AOF 文件。阈值也可以在 redis.conf 中配置：\",\"auto-aof-rewrite-percentage 100 // AOF 文件比上次文件增长多少百分比，则触发重写 auto-aof-rewrite-min-size 64mb // AOF 文件体积最小多大以上才触发重写 \"]},\"321\":{\"h\":\"RDB与AOF对比\",\"t\":[\"RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用。\",\"持久化方式\",\"数据完整性\",\"文件大小\",\"宕机恢复速度\",\"数据恢复优先级\",\"系统资源占用\",\"使用场景\",\"RDB\",\"定时对整个内存做快照\",\"不完整，两次备份之间会丢失\",\"会有压缩，文件体积小\",\"很快\",\"低，因为数据完整性不如AOF\",\"高，大量CPU和内存消耗\",\"AOF\",\"记录每一次执行的命令\",\"相对完整，取决于刷盘策略\",\"记录命令，文件体积很大\",\"慢\",\"高，因为数据完整性更高\",\"低，主要是磁盘IO资源但AOF重写时会占用大量CPU和内存资源\"]},\"322\":{\"h\":\"Redis进阶 - Redis哨兵\",\"t\":[\"思考\",\"slave 节点宕机恢复以后可以找 master 节点同步数据，那么 master 节点宕机怎么办？\"]},\"323\":{\"h\":\"哨兵的作用和工作原理\"},\"324\":{\"h\":\"哨兵的作用\",\"t\":[\"Redis 提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下：\",\"监控：Sentinel 会不断检查您的 master 和 slave 是否按照预期工作\",\"自动故障恢复：如果 master 故障，Sentinel 会将一个 slave 提升为 master 。当故障实例恢复后也以新的 master 为主\",\"通知：Sentinel 充当 Redis 客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给 Redis 的客户端\"]},\"325\":{\"h\":\"服务状态监控\",\"t\":[\"Sentinel 基于心跳机制监测服务状态，每隔 1 秒向集群的每个实例发送 ping 命令：\",\"主观下线：如果某 Sentinel 节点发现某实例未在规定时间响应，则认为该实例主观下线。\",\"客观下线：若超过指定数量（quorum）的 sentinel 都认为该实例主观下线，则该实例客观下线。quorum 值最好超过 Sentinel 实例数量的一半。\"]},\"326\":{\"h\":\"选举新的master\",\"t\":[\"一旦发现master 故障，sentinel 需要在 slave 中选择一个作为新的 master ，选择依据是这样：\",\"首先会判断 slave 节点与 master 节点断开的时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该 slave 节点\",\"然后判断 slave 节点的 slave-priority值，越小优先级越高，如果是 0 则永不参与选举\",\"如果 slave-prority 一样，则判断 slave 节点的 offset 值，越大则说明数据越新，优先级越高\",\"最后是判断 slave 节点的运行 id 大小，越小优先级越高\"]},\"327\":{\"h\":\"实现故障转移\",\"t\":[\"当选中了其中一个 slave 为新的 master 后（例如slave1），故障转移的步骤如下：\",\"sentinel 给备选的 slave1 节点发送 slaveof no one 命令，让该节点成为 master\",\"sentinel 给所有其他 slave 发送 slaveof 192.168.150.101 7002 命令，让这些 slave 成为新 master 的从节点，开始从新的 master 上同步数据。\",\"最后 sentinel 将故障节点标记为 slave，当故障节点恢复后会自动成为新的 master 的 slave 节点\"]},\"328\":{\"h\":\"小结\",\"t\":[\"Sentinel 的三个作用是什么？\",\"监控\",\"故障转移\",\"通知\",\"Sentinel 如何判断一个 Redis 实例是否健康？\",\"每隔 1 秒发送一次 ping 命令，如果超过一定时间没有相向则认为是主观下线\",\"如果大多数 sentinel 都认为实例主观下线，则判定服务下线\",\"故障转移步骤有哪些？\",\"首先选定一个 slave 作为新的 master，执行 slaveof no one\",\"然后让所有节点都执行 slaveof 新master\",\"修改故障节点配置，添加 slaveof 新master\"]},\"329\":{\"h\":\"搭建哨兵集群\"},\"330\":{\"h\":\"集群结构\",\"t\":[\"这里我们搭建一个三节点形成的Sentinel集群，来监管之前的Redis主从集群。如图：\",\"三个sentinel实例信息如下：\",\"节点\",\"IP\",\"PORT\",\"s1\",\"192.168.150.101\",\"27001\",\"s2\",\"192.168.150.101\",\"27002\",\"s3\",\"192.168.150.101\",\"27003\"]},\"331\":{\"h\":\"准备实例和配置\",\"t\":[\"要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。\",\"我们创建三个文件夹，名字分别叫s1、s2、s3：\",\"# 进入/tmp目录 cd /tmp # 创建目录 mkdir s1 s2 s3 \",\"然后我们在s1目录创建一个sentinel.conf文件，添加下面的内容：\",\"port 27001 sentinel announce-ip 192.168.150.101 sentinel monitor mymaster 192.168.150.101 7001 2 sentinel down-after-milliseconds mymaster 5000 sentinel failover-timeout mymaster 60000 dir \\\"/tmp/s1\\\" \",\"port 27001：是当前sentinel实例的端口\",\"sentinel monitor mymaster 192.168.150.101 7001 2：指定主节点信息 \",\"mymaster：主节点名称，自定义，任意写\",\"192.168.150.101 7001：主节点的ip和端口\",\"2：选举master时的quorum值\",\"然后将s1/sentinel.conf文件拷贝到s2、s3两个目录中（在/tmp目录执行下列命令）：\",\"# 方式一：逐个拷贝 cp s1/sentinel.conf s2 cp s1/sentinel.conf s3 # 方式二：管道组合命令，一键拷贝 echo s2 s3 | xargs -t -n 1 cp s1/sentinel.conf \",\"修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003：\",\"sed -i -e 's/27001/27002/g' -e 's/s1/s2/g' s2/sentinel.conf sed -i -e 's/27001/27003/g' -e 's/s1/s3/g' s3/sentinel.conf \"]},\"332\":{\"h\":\"启动\",\"t\":[\"为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：\",\"# 第1个 redis-sentinel s1/sentinel.conf # 第2个 redis-sentinel s2/sentinel.conf # 第3个 redis-sentinel s3/sentinel.conf \",\"启动后：\"]},\"333\":{\"h\":\"测试\",\"t\":[\"尝试让master节点7001宕机，查看sentinel日志：\",\"查看7003的日志：\",\"查看7002的日志：\"]},\"334\":{\"h\":\"RedisTemplate连接集群\",\"t\":[\"在 Sentinel 集群监管下的 Redis 主从集群，其节点会因为自动故障转移而发生变化，Redis 的客户端必须感知这种变化，及时更新连接信息。Spring 的 RedisTemplate 底层利用 lettuce 实现了节点的感知和自动切换。\",\"引入 pom 文件\",\"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-redis</artifactId> </dependency> \",\"配置文件\",\"spring: redis: sentinel: master: mymaster nodes: - 192.168.127.101:27001 - 192.168.127.101:27002 - 192.168.127.101:27003 \",\"修改配置类，实现读写分离\",\"这个方法写在项目启动类中。\",\"// 常规写法 @Bean public LettuceClientConfigurationBuilderCustomizer lettuceClientConfigurationBuilderCustomizer(){ return clientConfigurationBuilder -> clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED); } // 匿名内部类的简写 @Bean public LettuceClientConfigurationBuilderCustomizer lettuceClientConfigurationBuilderCustomizer(){ @Override public void customize(LettuceClientConfiguration.LettuceClientConfigurationbuilder clientConfigurationBuilder){ clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED); } } \",\"控制器 Controller 类\",\"@RestController public class RedisController { @Autowired private StringRedisTemplate stringRedisTemplate; @GetMapping(\\\"/set/{key}/{value}\\\") public String setKey(@PathVariable(\\\"key\\\") String key, @PathVariable(\\\"value\\\") String value){ stringRedisTemplate.opsForValue().set(key, value); return \\\"success\\\"; } @GetMapping(\\\"/get/{key}\\\") public String getKey(@PathVariable(\\\"key\\\")String key) { String value = stringRedisTemplate.opsForValue().get(key); return value; } } \",\"测试访问\",\"添加：http://localhost:8080/set/name/codermast/\",\"查询：http://localhost:8080/get/name/\"]},\"335\":{\"h\":\"Redis进阶 - 服务端优化\"},\"336\":{\"h\":\"Redis进阶 - Redis分片集群\"},\"337\":{\"h\":\"搭建分片集群\",\"t\":[\"主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：\",\"海量数据存储问题\",\"高并发写的问题\",\"使用分片集群可以解决上述问题，分片集群特征：\",\"集群中有多个 master，每个 master 保存不同数据\",\"每个 master 都可以有多个 slave 节点\",\"master 之间通过 ping 监测彼此健康状态\",\"客户端请求可以访问集群任意节点，最终都会被转发到正确节点\"]},\"338\":{\"h\":\"集群结构\",\"t\":[\"分片集群需要的节点数量较多，这里我们搭建一个最小的分片集群，包含3个master节点，每个master包含一个slave节点，结构如下：\",\"这里我们会在同一台虚拟机中开启6个redis实例，模拟分片集群，信息如下：\",\"IP\",\"PORT\",\"角色\",\"192.168.150.101\",\"7001\",\"master\",\"192.168.150.101\",\"7002\",\"master\",\"192.168.150.101\",\"7003\",\"master\",\"192.168.150.101\",\"8001\",\"slave\",\"192.168.150.101\",\"8002\",\"slave\",\"192.168.150.101\",\"8003\",\"slave\"]},\"339\":{\"h\":\"准备实例和配置\",\"t\":[\"删除之前的7001、7002、7003这几个目录，重新创建出7001、7002、7003、8001、8002、8003目录：\",\"# 进入/tmp目录 cd /tmp # 删除旧的，避免配置干扰 rm -rf 7001 7002 7003 # 创建目录 mkdir 7001 7002 7003 8001 8002 8003 \",\"在/tmp下准备一个新的redis.conf文件，内容如下：\",\"port 6379 # 开启集群功能 cluster-enabled yes # 集群的配置文件名称，不需要我们创建，由redis自己维护 cluster-config-file /tmp/6379/nodes.conf # 节点心跳失败的超时时间 cluster-node-timeout 5000 # 持久化文件存放目录 dir /tmp/6379 # 绑定地址 bind 0.0.0.0 # 让redis后台运行 daemonize yes # 注册的实例ip replica-announce-ip 192.168.150.101 # 保护模式 protected-mode no # 数据库数量 databases 1 # 日志 logfile /tmp/6379/run.log \",\"将这个文件拷贝到每个目录下：\",\"# 进入/tmp目录 cd /tmp # 执行拷贝 echo 7001 7002 7003 8001 8002 8003 | xargs -t -n 1 cp redis.conf \",\"修改每个目录下的redis.conf，将其中的6379修改为与所在目录一致：\",\"# 进入/tmp目录 cd /tmp # 修改配置文件 printf '%s\\\\n' 7001 7002 7003 8001 8002 8003 | xargs -I{} -t sed -i 's/6379/{}/g' {}/redis.conf \"]},\"340\":{\"h\":\"启动\",\"t\":[\"因为已经配置了后台启动模式，所以可以直接启动服务：\",\"# 进入/tmp目录 cd /tmp # 一键启动所有服务 printf '%s\\\\n' 7001 7002 7003 8001 8002 8003 | xargs -I{} -t redis-server {}/redis.conf \",\"通过ps查看状态：\",\"ps -ef | grep redis \",\"发现服务都已经正常启动：\",\"如果要关闭所有进程，可以执行命令：\",\"ps -ef | grep redis | awk '{print $2}' | xargs kill \",\"或者（推荐这种方式）：\",\"printf '%s\\\\n' 7001 7002 7003 8001 8002 8003 | xargs -I{} -t redis-cli -p {} shutdown \"]},\"341\":{\"h\":\"创建集群\",\"t\":[\"虽然服务启动了，但是目前每个服务之间都是独立的，没有任何关联。\",\"我们需要执行命令来创建集群，在Redis5.0之前创建集群比较麻烦，5.0之后集群管理命令都集成到了redis-cli中。\",\"Redis5.0之前\",\"Redis5.0之前集群命令都是用redis安装包下的src/redis-trib.rb来实现的。因为redis-trib.rb是有ruby语言编写的所以需要安装ruby环境。\",\"# 安装依赖 yum -y install zlib ruby rubygems gem install redis \",\"然后通过命令来管理集群：\",\"# 进入redis的src目录 cd /tmp/redis-6.2.4/src # 创建集群 ./redis-trib.rb create --replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003 \",\"Redis5.0以后\",\"我们使用的是Redis6.2.4版本，集群管理以及集成到了redis-cli中，格式如下：\",\"redis-cli --cluster create --cluster-replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003 \",\"命令说明：\",\"redis-cli --cluster或者./redis-trib.rb：代表集群操作命令\",\"create：代表是创建集群\",\"--replicas 1或者--cluster-replicas 1 ：指定集群中每个master的副本个数为1，此时节点总数 ÷ (replicas + 1) 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master\",\"运行后的样子：\",\"这里输入yes，则集群开始创建：\",\"通过命令可以查看集群状态：\",\"redis-cli -p 7001 cluster nodes \"]},\"342\":{\"h\":\"测试\",\"t\":[\"尝试连接7001节点，存储一个数据：\",\"# 连接 redis-cli -p 7001 # 存储数据 set num 123 # 读取数据 get num # 再次存储 set a 1 \",\"结果悲剧了：\",\"集群操作时，需要给redis-cli加上-c参数才可以：\",\"redis-cli -c -p 7001 \",\"这次可以了：\"]},\"343\":{\"h\":\"散列插槽\",\"t\":[\"Redis 会把每一个 master 节点映射到 0~16383 共 16384 个插槽（hash slot）上，查看集群信息时就能看到：\",\"数据 key 不是与节点绑定，而是与插槽绑定。Redis 会根据 key 的有小部分计算插槽值，分两种情况：\",\"key 中包含 {} ，且{}中至少包含 1 个字符，{}中的部分是有效部分\",\"key 中不包含 {}，整个 key 都是有效部分\",\"::: 例如 key 是 num，那么就根据 num 计算，如果是 {itcast}num，则根据 itcast 计算。计算方式是利用 CRC16 算法得到一个 hash 值，然后对 16384 取余，得到的结果就是 slot 值。 :::\",\"Redis如何判断某个 key 应该在哪个实例？\",\"将 16384 个插槽分配到不同的实例\",\"根据 key 的有效部分计算哈希值，对 16384 取余\",\"余数作为插槽，寻找插槽所在实例即可\",\"如何将同一类数据固定的保存在同一个 Redis 实例？\",\"这一类数据使用相同的有效部分，例如 key 都以 { typeid } 为前缀\"]},\"344\":{\"h\":\"集群伸缩\",\"t\":[\"集群伸缩就是集群节点能够动态的增加和减少，并且在集群伸缩的同时，也伴随着槽位及槽位中数据在节点之间的移动。\",\"redis-cli --cluster 提供了很多操作集群的命令，可以通过redis-cli --cluster help指令查看。\",\"向集群中添加一个新 master 节点，并存储 num = 1000 ：\",\"启动一个新的 Redis 实例，端口为 7004\",\"# 创建实例目录 mkdir 7004 # 创建 redis 服务 sed -i s/6379/7004/g 7004/redis.conf # 运行 redis 服务 redis-server 7004/redis.conf \",\"添加 7004 到之前的集群，并作为一个 master 节点\",\"redis-cli --cluster add-node 192.168.150.101:7004 192.168.150.101:7001 \",\"给 7004 节点分配插槽，使得 num 这个 key 可以存储到 7004 实例\",\"# 重新分片 redis-cli --cluster reshard 192.168.150.101:7001 # 移动 3000 个插槽 How many slots do you want to move (from 1 to 16384)? 3000 # 接收插槽的 ID What is the receiving node ID? 「这里输入 7001 的 ID 即可」 # 使用 done 结束 # 是否确认移动 Do you want to proceed with the proposed rehard plan (yes/no)? yes \"]},\"345\":{\"h\":\"故障转移\",\"t\":[\"当集群中有一个 master 宕机会发生什么？\",\"首先是该实例与其他实例失去连接\",\"然后是疑似宕机\",\"最后是确定下线，自动提升一个 slave 为新的 master\",\"这里选取 slave 的方式是根据 offset 偏移量和 id 进行筛选\",\"数据迁移\",\"利用 cluster failover 命令可以手动让集群中的某个 master 宕机，切换到执行 cluster failover 命令的这个 slave 节点，实现无感知的数据迁移。具体的流程如下：\",\"手动的 Failover 支持三种不同模式：\",\"缺省：默认的流程\",\"force：省略的对 offset 的一致性校验\",\"takeover：直接执行第 5 步，忽略数据一致性、忽略 master 状态和其他 master 的意见\"]},\"346\":{\"h\":\"RedisTemplate访问分片集群\",\"t\":[\"RedisTemplate 底层同样基于 lettuce 实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：\",\"引入 redis 的 starter 依赖\",\"配置分片集群地址\",\"配置读写分离\",\"与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下:\",\"spring: redis: cluster: nodes: # 指定分片集群的每一个节点信息 - 192.168.150.101:7001 - 192.168.150.101:7002 - 192.168.150.101:7003 - 192.168.150.101:8001 - 192.168.150.101:8002 - 192.168.150.101:8003 \"]},\"347\":{\"h\":\"Redis客户端 - Jedis连接池\",\"t\":[\"Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们使用Jedis连接池代替Jedis的直接连接方式。\",\"配置Jedis连接池\",\"public class JedisConnectionFactory{ private static final JedisPool jedisPool; static { JedisPoolConfig jedisPollConfig = new JedisPoolConfig(); // 最大连接，这里设置为 8 jedisPollConfig.setMaxTotal(8); // 最大空闲连接，这里设置为 8 jedisPollConfig.setMaxIdle(8); // 最小空闲连接，这里设置为 0 jedisPollConfig.setMaxIdle(0); // 设置最长等待时间，单位 ms jedisPollConfig.setMaxWaitMillis(200); jedisPool = new JedisPool(jedisPoolConfig,\\\"192.168.100.100\\\",6379,1000,\\\"codermast\\\"); } // 获取Jedis对象 public static Jedis getJedis(){ return jedisPool.getResource(); } } \",\"注意\",\"在单线程环境中可以不使用Jedis连接池，但是多线程环境下必须使用Jedis连接池，并且使用Jedis连接池较为可靠，我们不必关注与资源的获取和释放等问题，可以将注意力集中于业务逻辑上。\"]},\"348\":{\"h\":\"Redis客户端 - Jdies快速入门\"},\"349\":{\"h\":\"简介\",\"t\":[\"Jedis is a Java client for Redis designed for performance and ease of use.\",\"Jedis是Redis 的 Java 客户端，专为性能和易用性而设计。\"]},\"350\":{\"h\":\"官方地址\",\"t\":[\"Jedis的官方地址：https://github.com/redis/jedis\"]},\"351\":{\"h\":\"快速入门\",\"t\":[\"新建一个Maven工程并引入以下依赖\",\"<!--引入Jedis依赖--> <dependency> <groupId>redis.clients</groupId> <artifactId>jedis</artifactId> <version>4.2.0</version> </dependency> <!--引入单元测试依赖--> <dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter</artifactId> <version>5.8.2</version> <scope>test</scope> </dependency> \",\"编写测试类并与Redis建立连接\",\"private Jedis jedis; @BeforeEach //被该注解修饰的方法每次执行其他方法前自动执行 void setUp(){ // 1. 获取连接 jedis = new Jedis(\\\"192.168.230.88\\\",6379); // 2. 设置密码 jedis.auth(\\\"codermast\\\"); // 3. 选择库（默认是下标为0的库） jedis.select(0); } \",\"编写一个操作数据的方法（这里以操作String类型为例）\",\"@Test public void testString(){ // 1.往redis中存放一条String类型的数据并获取返回结果 String result = jedis.set(\\\"url\\\", \\\"https://www.codermast.com\\\"); System.out.println(\\\"result = \\\" + result); // 2.从redis中获取一条数据 String url = jedis.get(\\\"url\\\"); System.out.println(\\\"url = \\\" + url); } \",\"最后编写一个释放资源的方法\",\" @AfterEach //被该注解修饰的方法会在每次执行其他方法后执行 void tearDown(){ // 1.如果jedis被使用过，则释放资源 if (jedis != null){ jedis.close(); } } \",\"执行testString()方法后测试结果。\",\"result = OK url = https://www.codermast.com \"]},\"352\":{\"h\":\"Redis客户端 - RedisSerializer\",\"t\":[\"前景回顾\",\"在上一篇中，我们实现了一个简单的案例，操作一个 String 类型的数据，插入了一个 name = codermast 的数据到Redis。\",\"使用redis-cli客户端连接对应的Redis服务器后，按道理来讲get name这个指令的返回结果应该是 codermast\",\"redis-cli客户端查看\",\"返回的结果是无，这是为什么呢？使用可视化工具查看一下，看看到底数据是否存储在Redis服务器中。\",\"使用可视化工具查看\",\"可以明显的看到，所存储的 key 之前加上了一段字符，但是从代码中看，存储的 key 为 \\\"name\\\"，但是实际存储的 key 是 \\\\xac\\\\xed\\\\x00\\\\x05t\\\\x00\\\\x04name，而且里面的 value 也做了同样的处理 \\\\xac\\\\xed\\\\x00\\\\x05t\\\\x00\\\\x09codermast\",\"出现这种现象的原因是什么呢？这是因为 RedisTemplate 在底层将数据序列化处理以后，才存储到 Redis 服务器中。\",\"RedisTemplate 可以接收任意 Object 作为值写入 Redis ，只不过在写入之前会把 Object 序列化成为字节形式，默认是采用 JDK 序列化，得到的结果就如图所示。\",\"缺点\",\"可读性差\",\"资源占用高\",\"既然这样可读性又差，资源占用又高，那么如何解决这些问题呢？我们可以通过自定义 RedisTemplate 序列化的方式来解决。\"]},\"353\":{\"h\":\"编写一个 RedisConfig 配置类\",\"t\":[\"@Configuration public class RedisTemplate{ @Bean public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory){ // 1.创建RedisTemplate对象 RedisTemplate<String ,Object> redisTemplate = new RedisTemplate<>(); // 2.设置连接⼯⼚ redisTemplate.setConnectionFactory(factory); // 3.创建序列化对象 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); // 4.设置 key 和 hashKey 采⽤ String 的序列化⽅式 redisTemplate.setKeySerializer(stringRedisSerializer); redisTemplate.setHashKeySerializer(stringRedisSerializer); // 5.设置 value 和 hashValue 采⽤ json的 序列化⽅式 redisTemplate.setValueSerializer(genericJackson2JsonRedisSerializer); redisTemplate.setHashValueSerializer(genericJackson2JsonRedisSerializer); return redisTemplate; } } \",\"注意\",\"我们自定义的配置类中，使用到了 Jackson 序列化类，所以在使用之前需要导入 jackson-datebind 这个依赖项。\",\"<!-- jackson-databind 依赖 --> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> </dependency> \"]},\"354\":{\"h\":\"自定义序列化方式\",\"t\":[\"自定义的序列化方式也加进去了对引用类型的序列化，我们来实际测试一下。\",\"编写一个 User 类\",\"@Data public User{ Integer age; String name; } \",\"类中属性需要给出 set 和 get方法\",\"将 User 对象存储至 Redis\",\"@Test void testObject(){ User user = new User(); user.setAge(18); user.setName(\\\"codermast\\\"); // 插入一条 Object 类型的数据 redisTemplate.opsForValue().set(\\\"user\\\",user); // 获取一条 Object 类型的数据 User user_coder = (User)redisTemplate.opsForValue().get(\\\"user\\\"); System.out.println(user_coder); } \",\"虽然 JSON 的序列化方式可以满足我们存储对象的需求，为了在反序列化时知道对象的类型，将对象的类路径地址也序列化进 JSON 结果中，存入 Redis ，会带来额外的资源消耗。\",\"针对如图所示的特殊情况，类路径地址比我们真实的数据内容还大，造成了极大的资源浪费。\"]},\"355\":{\"h\":\"优化自定义序列化\",\"t\":[\"为了节省内存空间，通常情况下不会使用 JSON 序列化器来处理 Value ，而是统一使用 String 序列化器，要求只能存储 String 类型的 key 和 value。当要存储 Java 对象时，手动完成对象的序列化和反序列化。\",\"Spring 默认提供了一个 StringRedisTemplate 类，它的 key 和 value 的序列化方式默认就是 String 方式，省去了我们自定义的 RedisTemplate 的过程。\",\"现在在存储数据之前需要进行手动序列化，在获取数据以后，需要手动反序列化对象。\"]},\"356\":{\"h\":\"小结\",\"t\":[\"RedisTemplate 的两种序列化实践方案\",\"方案一 \",\"自定义RedisTemplate\",\"修改RedisTemplate 的序列化器为 GenericJackson2JsonRedisSerializer\",\"方案二 \",\"使用 StringRedisTemplate\",\"写入 Redis 之前，将对象手动序列化为 JSON\",\"读取数据以后，将 JSON 手动反序列化为对象\",\"提示\",\"上述仅说明了操作 String 类型的数据，操作 Hash、List、Set、SortedSet类型时，使用对应的 ops 对象即可操作。\"]},\"357\":{\"h\":\"Redis客户端 - SpringDataRedis\"},\"358\":{\"h\":\"介绍\",\"t\":[\"SpringData 是 Spring 中操作数据的模块，包含对各种数据库的集成，其中对 Redis 的集成模块就叫做 SpringDataRedis，官网地址：https://spring.io/prohects/spring-data-redis\",\"提供了对不同 Redis 客户端的整合 （Lettuce 和 Jedis）\",\"提供了 RedisTemplate 统一 API 来操作Redis\",\"支持 Redis 的发布订阅模型\",\"支持 Redis 哨兵和 Redis 集群\",\"支持基于 Lettuce 的响应式编程\",\"支持基于 JDK、JSON、字符串、Spring对象的数据序列化和反序列化\",\"支持基于 Redis 的 JDKCollection 实现\"]},\"359\":{\"h\":\"操作API\",\"t\":[\"SpringDataRedis 中提供了 RedisTemplate 工具类，其中封装了各种对 Redis 的操作。并且将不同数据类型的操作API封装到了不同的类型中：\",\"API\",\"返回值类型\",\"说明\",\"redisTemplate.opsForValue()\",\"ValueOperations\",\"操作String类型数据\",\"redisTemplate.opsForHash()\",\"HashOperations\",\"操作Hash类型数据\",\"redisTemplate.opsForList()\",\"ListOperations\",\"操作List类型数据\",\"redisTemplate.opsForSet()\",\"SetOperations\",\"操作Set类型数据\",\"redisTemplate.opsForZSet()\",\"ZSetOperations\",\"操作SortedSet类型数据\",\"redisTemplate\",\"通用命令\",\"使用说明\",\"我们在操作对应的 Redis 数据时，根据数据类型的不同获取对应的操作对象，如操作 String 类型时，则调用 redisTemplate.opsForValue() 方法，获取一个 ValueOperations 对象，来操作 String 类型的数据。\"]},\"360\":{\"h\":\"Spring Boot 中使用\",\"t\":[\"引入依赖\",\"<!--Redis依赖--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-redis</artifactId> </dependency> <!--连接池依赖--> <dependency> <groupId>org.apache.commons<groupId> <artifactId>commons-pool2</artifactId> </dependency> \",\"配置文件\",\"spring : redis : host : 192.168.100.100 port : 6379 password : codermast lettuce : pool : max-active : 8 # 最大的连接数 max-idle : 8 # 最大空闲连接 min-idle : 0 # 最小空闲连接 max-wait : 100 # 连接等待时间 \",\"获取 RedisTemplate 对象\",\"@Autowired private RedisTemplate redisTemplate; \",\"在 Spring Boot 框架中，使用自动注入获取对象\",\"编写测试类\",\"@SpringBootTest public class RedisTest { @Autowired private RedisTemplate redisTemplate; @Test void testString(){ // 插入一条 String 类型的数据 redisTemplate.opsForValue().set(\\\"name\\\",\\\"codermast\\\"); // 获取一条 String 类型的数据 Object name = redisTemplate.opsForValue().get(\\\"name\\\"); System.out.println(\\\"我的名字是：\\\" + name); } } \",\"运行查看结果\",\"我的名字是：codermast \"]},\"361\":{\"h\":\"Redis入门 - 基础通用指令\",\"t\":[\"在正式介绍Redis数据结构及其操作指令之前，我们需要先掌握一些最基础的通用指令。\",\"这些都是Redis操作过程中的一些常见指令\",\"指令\",\"描述\",\"keys\",\"查看符合模板的所有key，不建议在⽣产环境设备上使⽤\",\"del\",\"删除⼀个指定的key\",\"esists\",\"判断key是否存在\",\"expire\",\"给⼀个key设置有效期，有效期到期时该key会被⾃动删除\",\"ttl\",\"查看⼀个KEY的剩余有效期\",\"quit\",\"退出\",\"shutdown\",\"关闭服务器\",\"select [0-15]\",\"选择指定的数据库\",\"help指令\",\"可以通过 help [command]可以查看⼀个命令的具体⽤法！\",\"例如查看set指令的帮助文档：help set\"]},\"362\":{\"h\":\"Redis入门 - Redis概念和基础\"},\"363\":{\"h\":\"什么是NoSQL\",\"t\":[\"NoSQL，泛指非关系型的数据库。\",\"NoSQL最常见的解释是 \\\"non-relational\\\"， 很多人也说它是\\\"Not Only SQL\\\"\",\"NoSQL仅仅是一个概念，泛指非关系型的数据库\",\"区别于关系数据库，它们不保证关系数据的ACID特性\",\"NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入\",\"常见的NoSQL数据库有：Redis、MemCache、MongoDB等\"]},\"364\":{\"h\":\"NoSQL与SQL\",\"t\":[\"SQL\",\"NoSQL\",\"数据结构\",\"结构化\",\"非结构化\",\"数据关联\",\"关联\",\"无关联\",\"查询方式\",\"SQL查询\",\"非SQL查询\",\"事务特性\",\"ACID\",\"BASE\",\"存储方式\",\"磁盘\",\"内存\",\"扩展性\",\"垂直\",\"水平\",\"使用场景\",\"1.数据结构固定2.相关业务对数据安全性、一致性要求较高\",\"1.数据结构不固定 2.对一致性、安全性要求不高 3.对性能要求高\",\"NoSQL数据库的常见种类\",\"键值类型（Redis）\",\"文档类型（MongoDB）\",\"列类型（HBase）\",\"Graph类型（Neo4j）\"]},\"365\":{\"h\":\"认识Redis\",\"t\":[\"Redis诞生于2009年，全称为 Remote Dictionary Server，远程字典服务器，是一个基于内存的键值型的NoSQL数据库。\",\"Redis特征\",\"键值型（Key-Value），value支持多种不同的数据结构，功能丰富。\",\"单线程，每个命令具备原子性。Redis6.0开始对网络请求启用多线程，但是对命令的执行依然是单线程。\",\"低延迟，速度快（、IO多路复用、良好的编码）\",\"支持数据持久化\",\"支持主从集群、分片集群\",\"支持多语言客户端（C语言、Java、C++、Python等）\"]},\"366\":{\"h\":\"安装Redis\",\"t\":[\"由于Redis的作者仅编写了Linux环境下的版本，且在生产环境时大多数使用的Linux系统，故我们在Centos操作系统内进行安装。\",\"安装Redis\",\"yum install redis \",\"Redis安装\",\"其他安装\",\"除了上述安装方式以外还有很多安装方式，这里不再赘述。各种环境的安装方式，可以参考Redis官方的安装文档，地址：https://redis.io/docs/getting-started/installation/\"]},\"367\":{\"h\":\"Redis启动的三种方式\"},\"368\":{\"h\":\"前台启动\",\"t\":[\"安装完Redis以后，在任意目录下输入redis-server命令即可启动Redis。\",\"前台启动Redis\",\"前台启动Redis后，就是如上界面，此时命令终端会一直响应Redis服务，而无法进行其他操作，要进行其他指令操作时，则必须关闭Redis服务，很不方便，此时我们可以使用后台启动。\"]},\"369\":{\"h\":\"后台启动\",\"t\":[\"如果要让Redis以后台方式启动，则必须修改Redis配置文件，配置文件所在目录就是Redis安装目录。\",\"修改Redis配置文件redis.conf文件中的配置项。\",\"# 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0 bind 0.0.0.0 # 守护进程，修改为yes后即为后台运行 daemonize yes # 密码，设置后访问Redis必须输入密码，此时密码即为 codermast requirepass codermast \",\"此时启动Redis时需要加上配置文件，即可后台启动redis。\",\"redis-server redis.conf \",\"Redis后台启动\"]},\"370\":{\"h\":\"开机启动\",\"t\":[\"要实现开机启动，需要配置一个系统服务文件\",\"vi /etc/systemd/system/redis.service \",\"将以下内容作为文件内容：\",\"[Unit] Description=redis-server After=network.target [Service] Type=forking ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf PrivateTmp=true [Install] WantedBy=multi-user.target \",\"重载系统服务\",\"systemctl daemon-reload \",\"开启redis开机自启动\",\"systemctl enable redis \",\"操作Redis指令\",\"启动：systemctl start redis\",\"停止：systemctl stop redis\",\"重启：systemctl restart redis\",\"查看状态：systemctl status redis\"]},\"371\":{\"h\":\"Redis客户端\",\"t\":[\"Redis本身仅有一个基于命令行的客户端，但是这种方式在我们使用过程中不太直观，所以市面上就出现了很多的客户端，但主要分为三种类型：命令行客户端、图形化客户端、编程语言客户端。\"]},\"372\":{\"h\":\"命令行客户端\",\"t\":[\"Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：\",\"redis-cli [options] [commonds] \",\"这里options为选项，commonds为命令，加上[]为可选项。这也是一种常见的文档编写规范。\",\"Redis命令行连接\",\"注意\",\"这里要注意的是，在使用redis-cli客户端连接redis服务时，需要保证redis服务是开启的，无论是在远程连接或者本地连接，这是新手阶段容易忽视的一点。\",\"其中常见的options有：\",\"h 127.0.0.1：指定要连接的redis节点的IP地址，默认是127.0.0.1\",\"p 6379：指定要连接的redis节点的端口，默认是6379\",\"a 132537：指定redis的访问密码\",\"其中的commonds就是Redis的操作命令，例如：\",\"ping：与redis服务端做心跳测试，服务端正常会返回pong\",\"不指定commond时，会进入redis-cli的交互控制台。\"]},\"373\":{\"h\":\"图形化客户端\",\"t\":[\"图形化客户端，顾名思义就是通过可视化的软件，来对redis数据库进⾏操作。 图形化界⾯的客户端种类很多，可以选择⾃⼰喜欢的⼀款就可以，这⾥我选择的是Another Redis Desktop Manager这款，⽀持Mac、Linux、Windows系统，更重要的是还免 费。\",\"笔者的电脑系统为macos，故就演示Mac环境下的图形化客户端，windows系统下的客户端种类很多，网络上的资源也很多，这里就不赘述。\",\"Redis图形化客户端-Another redis desktop manager\",\"Github地址：https://github.com/qishibo/AnotherRedisDesktopManager/releases/tag/v1.5.9\",\"Gitee地址：https://gitee.com/qishibo/AnotherRedisDesktopManager/releases/tag/v1.5.8\",\"相关信息\",\"对于Github访问慢的⽤户，可以直接在国内的Gitee中下载安装，⼀般来说两者都没有什么差别，唯⼀的区别就在于Github上的更新⽐较及时。\"]},\"374\":{\"h\":\"编程语言客户端\",\"t\":[\"编程语言客户端也有很多种，如Java语言的Jedis客户端，Go语言的Go-Redis客户端等。\",\"具体的可以参考Redis官方提供的文档，地址：https://redis.io/docs/clients/\",\"几个Java语言的客户端展示。\",\"Java语言的Redis客户端\"]},\"375\":{\"h\":\"Redis入门 - 5种基本数据类型\",\"t\":[\"说明\",\"在我们平常的业务中基本只会使用到Redis的基本数据类型（String、List、Hash、Set、Sorted Set），特殊类型（Geo、Bitmap、Hyperloglog）类型只有在特殊的业务场景下会使用到，通常只需要掌握基本数据类型即可，特殊类型作为了解即可。\"]},\"376\":{\"h\":\"String 字符串\",\"t\":[\"String类型，也就是字符串类型，是Redis中最简单的存储类型。String 类型是二进制安全的。意思是 redis 的 String 可以包含任何数据。比如jpg图片或者序列化的对象。\",\"其value是字符串，不过根据字符串的格式不同，又可以分为3类：\",\"string：普通字符串\",\"int：整数类型，可以做自增、自减操作\",\"float：浮点类型，可以做自增、自减操作\",\"不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.\",\"String类型的常见操作命令：\",\"命令\",\"描述\",\"SET\",\"添加或者修改已经存在的一个String类型的键值对\",\"GET\",\"根据key获取String类型的value\",\"MSET\",\"批量添加多个String类型的键值对\",\"MGET\",\"根据多个key获取多个String类型的value\",\"INCR\",\"让一个整型的key自增1\",\"INCRBY\",\"让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2\",\"INCRBYFLOAT\",\"让一个浮点类型的数字自增并指定步长\",\"SETNX\",\"添加一个String类型的键值对，前提是这个key不存在，否则不执行\",\"SETEX\",\"添加一个String类型的键值对，并且指定有效期\",\"Redis的key中虽然没有目录结构，但是允许有多个单词形成层级结构，多个单词之间用” ：“隔开，一般情况下使用的格式为：项目名:业务名:类型:id。\",\"这个格式并非固定，也可以根据自己的需求来删除或添加词条。\",\"举例说明\",\"例如我们的项目名称叫 myblog ，有user和product两种不同类型的数据，我们可以这样定义key：\",\"user相关的key：myblog:user:1\",\"product相关的key：myblog:product:1\",\"如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储\",\"KEY\",\"VALUE\",\"myblog:user:1\",\"{“id”:1, “name”: “Jack”, “age”: 21}\",\"myblog:product:1\",\"{“id”:1, “name”: “小米11”, “price”: 4999}\"]},\"377\":{\"h\":\"Hash 哈希\",\"t\":[\"Hash类型，也叫散列，又可以成为哈希类型。其value是一个无序字典，类似于Java中的HashMap结构。\",\"Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD\",\"Hash类型的数据\",\"Hash的常见命令有：\",\"命令\",\"描述\",\"HSET key field value\",\"添加或者修改hash类型key的field的值\",\"HGET key field\",\"获取一个hash类型key的field的值\",\"HMSET\",\"hmset 和 hset 效果相同 ，4.0之后hmset可以弃用了\",\"HMGET\",\"批量获取多个hash类型key的field的值\",\"HGETALL\",\"获取一个hash类型的key中的所有的field和value\",\"HKEYS\",\"获取一个hash类型的key中的所有的field\",\"HVALS\",\"获取一个hash类型的key中的所有的value\",\"HINCRBY\",\"让一个hash类型key的字段值自增并指定步长\",\"HSETNX\",\"添加一个hash类型的key的field值，前提是这个field不存在，否则不执行\"]},\"378\":{\"h\":\"List 列表\",\"t\":[\"Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。\",\"特征也与LinkedList类似：\",\"有序\",\"元素可以重复\",\"插入和删除快\",\"查询速度一般\",\"常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等.\",\"命令\",\"描述\",\"LPUSH key element …\",\"向列表左侧插入一个或多个元素\",\"LPOP key\",\"移除并返回列表左侧的第一个元素，没有则返回nil\",\"RPUSH key element …\",\"向列表右侧插入一个或多个元素\",\"RPOP key\",\"移除并返回列表右侧的第一个元素\",\"LRANGE key star end\",\"返回一段角标范围内的所有元素\",\"BLPOP和BRPOP\",\"与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil\",\"双端队列示意图\"]},\"379\":{\"h\":\"Set 集合\",\"t\":[\"Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征\",\"无序\",\"元素不可重复\",\"查找快\",\"支持交集、并集、差集等功能\",\"命令\",\"描述\",\"SADD key member …\",\"向set中添加一个或多个元素\",\"SREM key member …\",\"移除set中的指定元素\",\"SCARD key\",\"返回set中元素的个数\",\"SISMEMBER key member\",\"判断一个元素是否存在于set中\",\"SMEMBERS\",\"获取set中的所有元素\",\"SINTER key1 key2 …\",\"求key1与key2的交集\",\"SDIFF key1 key2 …\",\"求key1与key2的差集\",\"SUNION key1 key2 …\",\"求key1和key2的并集\",\"tip 交集、差集、并集图示\"]},\"380\":{\"h\":\"SortedSet 有序集合\",\"t\":[\"Redis的SortedSet又可以成为Zset，是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。\",\"SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。\",\"SortedSet具备下列特性：\",\"可排序\",\"元素不重复\",\"查询速度快\",\"因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。\",\"SortedSet的常见命令有\",\"命令\",\"描述\",\"ZADD key score member\",\"添加一个或多个元素到sorted set ，如果已经存在则更新其score值\",\"ZREM key member\",\"删除sorted set中的一个指定元素\",\"ZSCORE key member\",\"获取sorted set中的指定元素的score值\",\"ZRANK key member\",\"获取sorted set 中的指定元素的排名\",\"ZCARD key\",\"获取sorted set中的元素个数\",\"ZCOUNT key min max\",\"统计score值在给定范围内的所有元素的个数\",\"ZINCRBY key increment member\",\"让sorted set中的指定元素自增，步长为指定的increment值\",\"ZRANGE key min max\",\"按照score排序后，获取指定排名范围内的元素\",\"ZRANGEBYSCORE key min max\",\"按照score排序后，获取指定score范围内的元素\",\"ZDIFF、ZINTER、ZUNION\",\"求差集、交集、并集\",\"注意\",\"所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可\"]},\"381\":{\"h\":\"Redis入门 - 发布订阅\",\"t\":[\"Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。\",\"此种模式下，消息发布者和订阅者不进行直接通信，发布者客户端向指定的频道（channel） 发布消息，订阅该频道的每个客户端都可以收到该消息，\",\"Redis 客户端可以订阅任意数量的频道。\",\"下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：\",\"当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：\",\"Redis发布订阅命令：\",\"订阅一个或多个频道：subscribe channel1 [channel2 ... ]\",\"退订一个或多个频道：unsubscribe [channel [channel ...]]\",\"订阅给定模式频道：psubscribe pattern [pattern ...]\",\"退订给定模式频道：punsubscribe [pattern [pattern ...]]\",\"发布命令：publish channel message\",\"查看订阅与发布系统状态：pubsub subcommand [argument [argument ...]]\"]},\"382\":{\"h\":\"Redis入门 - Lua脚本\",\"t\":[\"Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。\"]},\"383\":{\"h\":\"语法\",\"t\":[\"Eval 命令的基本语法如下：EVAL script numkeys key [key ...] arg [arg ...]\"]},\"384\":{\"h\":\"脚本命令\",\"t\":[\"执行Lua脚本：EVAL script numkeys key [key ...] arg [arg ...]\",\"将脚本添加到脚本缓存，但不执行：SCRIPT LOAD script\",\"从脚本缓存中移除所有脚本：SCRIPT FLUSH\",\"杀死当前正在运行的 Lua 脚本：SCRIPT KILL\",\"查看指定的脚本是否已经被保存在缓存当中：SCRIPT EXISTS script [script ...]\",\"根据给定的 sha1 校验码，执行缓存在服务器中的脚本：EVALSHA sha1 numkeys key [key ...] arg [arg ...] \"]},\"385\":{\"h\":\"Redis入门 - Redis Stream\",\"t\":[\"Redis Stream 是 Redis 5.0 版本新增加的数据结构。\",\"Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。\",\"简单来说发布订阅 (pub/sub) 可以分发消息，但无法记录历史消息。\",\"而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。\",\"Redis Stream 的结构如下所示，它有一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容：\",\"每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 xadd 指令追加消息时自动创建。\",\"上图解析：\",\"Consumer Group ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer)。\",\"last_delivered_id ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。\",\"pending_ids ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符）。\",\"消息队列相关命令：\",\"XADD - 添加消息到末尾\",\"XTRIM - 对流进行修剪，限制长度\",\"XDEL - 删除消息\",\"XLEN - 获取流包含的元素数量，即消息长度\",\"XRANGE - 获取消息列表，会自动过滤已经删除的消息\",\"XREVRANGE - 反向获取消息列表，ID 从大到小\",\"XREAD - 以阻塞或非阻塞方式获取消息列表\",\"消费者组相关命令：\",\"XGROUP CREATE - 创建消费者组\",\"XREADGROUP GROUP - 读取消费者组中的消息\",\"XACK - 将消息标记为\\\"已处理\\\"\",\"XGROUP SETID - 为消费者组设置新的最后递送消息ID\",\"XGROUP DELCONSUMER - 删除消费者\",\"XGROUP DESTROY - 删除消费者组\",\"XPENDING - 显示待处理消息的相关信息\",\"XCLAIM - 转移消息的归属权\",\"XINFO - 查看流和消费者组的相关信息；\",\"XINFO GROUPS - 打印消费者组的信息；\",\"XINFO STREAM - 打印流信息\"]},\"386\":{\"h\":\"XADD\",\"t\":[\"使用 XADD 向队列添加消息，如果指定的队列不存在，则创建一个队列，XADD 语法格式：\",\"XADD key ID field value [field value ...]\",\"key ：队列名称，如果不存在就创建\",\"ID ：消息 id，我们使用 * 表示由 redis 生成，可以自定义，但是要自己保证递增性。\",\"field value ： 记录。\"]},\"387\":{\"h\":\"XTRIM\",\"t\":[\"使用 XTRIM 对流进行修剪，限制长度， 语法格式：\",\"XTRIM key MAXLEN [~] count\",\"key ：队列名称\",\"MAXLEN ：长度\",\"count ：数量\"]},\"388\":{\"h\":\"XDEL\",\"t\":[\"使用 XDEL 删除消息，语法格式：\",\"XDEL key ID [ID ...]\",\"key：队列名称\",\"ID ：消息 ID\"]},\"389\":{\"h\":\"XLEN\",\"t\":[\"使用 XLEN 获取流包含的元素数量，即消息长度，语法格式：\",\"XLEN key\",\"key：队列名称\"]},\"390\":{\"h\":\"XRANGE\",\"t\":[\"使用 XRANGE 获取消息列表，会自动过滤已经删除的消息 ，语法格式：\",\"XRANGE key start end [COUNT count]\",\"key ：队列名\",\"start ：开始值， - 表示最小值\",\"end ：结束值， + 表示最大值\",\"count ：数量\"]},\"391\":{\"h\":\"XREVRANGE\",\"t\":[\"使用 XREVRANGE 获取消息列表，会自动过滤已经删除的消息 ，语法格式：\",\"XREVRANGE key end start [COUNT count]\",\"key ：队列名\",\"end ：结束值， + 表示最大值\",\"start ：开始值， - 表示最小值\",\"count ：数量\"]},\"392\":{\"h\":\"XREAD\",\"t\":[\"使用 XREAD 以阻塞或非阻塞方式获取消息列表 ，语法格式：\",\"XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]\",\"count ：数量\",\"milliseconds ：可选，阻塞毫秒数，没有设置就是非阻塞模式\",\"key ：队列名\",\"id ：消息 ID\"]},\"393\":{\"h\":\"XGROUP CREATE\",\"t\":[\"使用 XGROUP CREATE 创建消费者组，语法格式：\",\"XGROUP [CREATE key groupname id-or-$] [SETID key groupname id-or-$] [DESTROY key groupname] [DELCONSUMER key groupname consumername]\",\"key ：队列名称，如果不存在就创建\",\"groupname ：组名。\",\"$ ： 表示从尾部开始消费，只接受新消息，当前 Stream 消息会全部忽略。\",\"从头开始消费:\",\"XGROUP CREATE mystream consumer-group-name 0-0 从尾部开始消费:\",\"XGROUP CREATE mystream consumer-group-name $\"]},\"394\":{\"h\":\"XREADGROUP GROUP\",\"t\":[\"使用 XREADGROUP GROUP 读取消费组中的消息，语法格式：\",\"XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]\",\"group ：消费组名\",\"consumer ：消费者名。\",\"count ： 读取数量。\",\"milliseconds ： 阻塞毫秒数。\",\"key ： 队列名。\",\"ID ： 消息 ID。XREADGROUP GROUP consumer-group-name consumer-name COUNT 1 STREAMS mystream >\"]},\"395\":{\"h\":\"Redis入门 - 3种特殊数据类型\",\"t\":[\"说明\",\"在我们平常的业务中基本只会使用到Redis的基本数据类型（String、List、Hash、Set、Sorted Set），特殊类型（Geo、Bitmap、Hyperloglog）类型只有在特殊的业务场景下会使用到，通常只需要掌握基本数据类型即可，特殊类型作为了解即可。\"]},\"396\":{\"h\":\"GEO类型\",\"t\":[\"GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常⻅操作。\",\"geoadd：添加地理位置的坐标。\",\"geopos：获取地理位置的坐标。\",\"geodist：计算两个位置之间的距离。\",\"georadius：根据⽤户给定的经纬度坐标来获取指定范围内的地理位置集合。\",\"georadiusbymember：根据储存在位置集合⾥⾯的某个地点获取指定范围内的地理位置集合。\",\"geohash：返回⼀个或多个位置对象的 geohash 值。\",\"命令\",\"描述\",\"GEOHASH key member [member ...]\",\"返回⼀个或多个位置元素的 Geohash 表示\",\"GEOPOS key member [member ...]\",\"从key⾥返回所有给定位置元素的位置（经度和纬度）\",\"GEODIST key member1 member2 [m|km|ft|mi]\",\"返回两个给定位置之间的距离\",\"GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]\",\"以给定的经纬度为中⼼， 找出某⼀半径内的元素\",\"GEOADD key longitude latitude member [longitude latitude member ...]\",\"将指定的地理空间位置（纬度、经度、名称）添加到指定的key中\",\"GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]\",\"找出位于指定范围内的 元素，中⼼点是由给定的位置元素决定\"]},\"397\":{\"h\":\"Bitmap类型\",\"t\":[\"从本质上来说，bitmap不是⼀种数据类型，本质是字符串key-value，但是其可以对位进⾏操作。也可以将bitmap想象成⼀个只能存储0、1的整型数组，可以随时对任意⼀位进⾏运算。下标在bitmap中成为偏移量。\",\"命令\",\"描述\",\"setbit\",\"设置Bitmaps中某个偏移量的值（0或1）(offset:偏移量从0开始)\",\"getbit\",\"获取Bitmaps中某个偏移量的值（偏移量不存在，也是返回0）\",\"bitcount[start end]\",\"统计字符串被设置为1的bit数。\",\"bitop and(or/not/xor) [key…]\",\"bitop是⼀个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（⾮） 、 xor（异或） 操作并将结果保存在destkey中。\"]},\"398\":{\"h\":\"Hyperloglog类型\",\"t\":[\"Redis HyperLogLog 是⽤来做基数统计的算法，HyperLogLog 的优点是，在输⼊元素的数量或者体积⾮常⾮常⼤时，计算基数所需的空间总是固定 的、并且是很⼩的。\",\"在 Redis ⾥⾯，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对⽐。\",\"但是，因为 HyperLogLog 只会根据输⼊元素来计算基数，⽽不会储存输⼊元素本身，所以HyperLogLog 不能像集合那样，返回输⼊的各个元素。\",\"命令\",\"描述\",\"pfadd <element> [element ...]\",\"将所有元素添加到指定HyperLogLog数据结构中。如果执⾏命令后HLL估计的近似基数发⽣变化，则返回1，否则返回0。\",\"pfcount [key ...]\",\"计算HLL的近似基数，可以计算多个HLL，⽐如⽤HLL存储每天的UV，计算⼀周的UV可以使⽤7天的UV合并计算即可\",\"pfmerge [sourcekey ...]\",\"将⼀个或多个HLL合并后的结果存储在另⼀个HLL中，⽐如每⽉活跃⽤户可以使⽤每天的活跃⽤户来合并计算可得\"]},\"399\":{\"h\":\"Redis入门 - 事务\",\"t\":[\"Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：\",\"批量操作在发送 EXEC 命令前被放入队列缓存。\",\"收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。\",\"在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。\",\"一个事务从开始到执行会经历以下三个阶段：\",\"开始事务。\",\"命令入队。\",\"执行事务。\",\"单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。\",\"事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。\",\"Redis事务命令\",\"开始事务：multi\",\"执行事务：exec\",\"取消事务：discard\",\"监视一个(或多个) key：watch key [key ...]\",\"监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。\",\"取消监视：unwatch\",\"取消 WATCH 命令对所有 key 的监视。\",\"注意\",\"Redis的事务和MySQL的事务是不同的，MySQL的事务要么全部执行，要么全部不执行。而Redis仅仅是一组命令的顺序执行集合，事务不会回滚，也不会随着报错而停止。\"]},\"400\":{\"h\":\"Redis原理 - IO详解\"},\"401\":{\"h\":\"用户空间与内核空间\",\"t\":[\"任何Linux 系统的发行版，其系统内核都是 Linux 。我们的应用都需要通过 Linux 内核与硬件交互。\",\"为了避免用户应用导致冲突甚至内核崩溃，用户应用与内核是分离的：\",\"内存的寻址空间划分为两部分：内核空间、用户空间\",\"32 位的操作系统，寻址地址就为 0 ~ 232\",\"用户空间内只能执行受限的指令（Ring3），而且不能直接调用系统资源，必须通过内核提供的接口访问\",\"内核空间可以执行特权命令（Ring0），调用一切系统资源\",\"当进程运行在用户空间时称为用户态，运行在内核空间时称为内核态。\",\"Linux 系统为了提高 IO 效率，会在用户空间和内核空间都加入缓冲区：\",\"写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备\",\"读数据是，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区\",\"5种IO模型\",\"阻塞 IO（Blocking IO）\",\"非阻塞 IO（Nonblocking IO）\",\"IO 多路复用（IO Multiplexing）\",\"信号驱动 IO（Signal Driven IO）\",\"异步 IO（Asynchronous IO）\"]},\"402\":{\"h\":\"阻塞IO\",\"t\":[\"顾名思义，阻塞 IO 就是在等待数据和拷贝数据到用户空间两个阶段过程中都必须阻塞等待。\",\"用户线程发出 IO 请求\",\"内核会去查看数据是否准备就绪，如果没有准备就绪那么就会一直等待，而用户线程就会处于阻塞状态，用户线程处于阻塞状态\",\"当数据准备就绪以后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除阻塞状态\",\"可以看到，阻塞IO模型中，用户进程在两个阶段都是阻塞状态。\"]},\"403\":{\"h\":\"非阻塞IO\",\"t\":[\"非阻塞 IO 的 recvfrom 操作会立即返回结果，而不是阻塞用户进程。\",\"等待数据阶段，如果数据没有就绪，则立刻返回 EWOULDBLOCK。这个过程用户进程是非阻塞的，但是用户进程会一直发起请求，忙轮训，直到内核处理才开始停止轮训。\",\"数据就绪以后，再将数据从内核中拷贝至用户空间。这个阶段用户进程是阻塞的。\",\"可以看到，非阻塞 IO 模型中，用户进程在第一个阶段是非阻塞的，在第二个阶段是阻塞的。虽然是非阻塞的，但是性能并没有得到提高，而且忙等机制会导致 CPU 空转，CPU 使用率暴增。\"]},\"404\":{\"h\":\"IO多路复用\",\"t\":[\"无论是阻塞 IO 还是非阻塞 IO，用户应用在一阶段都是需要调用 recvfrom 来获取数据，差别在于无数据时的处理方式：\",\"如果调用 recvfrom 时，恰好没有数据，阻塞 IO 会使进程阻塞，非阻塞 IO 会使CPU空转，均无法发挥 CPU 的作用。\",\"如果调用 recvfrom 时，恰好有数据，则用户进程可以直接进入第二阶段，读取并处理数据\",\"比如服务端处理客户端Socket 请求时，在单线程情况下，只能依次处理每一个 Socket，如果正在处理 socket 恰好未就绪（数据不可读或者不可写），线程就会被阻塞，所有其它客户端 socket 都必须等待，性能自然很差。\",\"文件描述符（File Descriptor）：简称FD，是一个从 0 开始递增的无符号整数，用来关联 Linux 中的一个文件。在 Linux 中一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）\",\"IO多路复用：是利用单个线程来同时监听多个 FD ，并在某个 FD 可读、可写时得到通知，从而避免无效的等待，充分利用 CPU 资源。\",\"实现 IO 多路复用的技术有三种方式：\",\"select\",\"poll\",\"epoll\",\"差异：\",\"select 和 poll 只会通知用户进程有FD就绪，但是不确定是那个 FD，需要用户进程逐个遍历 FD 来确认\",\"epoll 会通知用户进程 FD 就绪的同时，把已就绪的 FD 写入用户空间，直接能定位到就绪的 FD\"]},\"405\":{\"h\":\"SELECT\",\"t\":[\"select 是 Linux 中最早的 I/O 多路复用的实现方案：\",\"// 定义类型别名 __fd_mask，本质是 long int typedef long int __fd_mask; /* fd_set 记录要监听的fd集合，及其对应状态 */ typedef struct { // fds_bits是long类型数组，长度为 1024/32 = 32 // 共1024个bit位，每个bit位代表一个fd，0代表未就绪，1代表就绪 __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS]; // ... } fd_set; // select函数，用于监听多个fd的集合 int select( int nfds,// 要监视的fd_set的最大fd + 1 fd_set *readfds,// 要监听读事件的fd集合 fd_set *writefds,// 要监听写事件的fd集合 fd_set *exceptfds, // 要监听异常事件的fd集合 // 超时时间，nulT-永不超时;0-不阻塞等待;大于0-固定等待时间 struct timeval *timeout ); \",\"具体流程如下：\",\"用户空间中创建 fd_set rfds\",\"假如要监听 fd = 1，2，5\",\"用户空间中执行 selec(5 + 1, rfds, null, null, 3)\",\"将用户空间中创建的 fd_set rfds 数组拷贝到内核空间中\",\"内核空间中遍历拷贝后的 fd_set rfds 数组\",\"如果没有就绪，则将该位置的 fd 设置为0。\",\"select模式存在的问题：\",\"需要将整个fd_set从用户空间拷贝到内核空间，select结束还要再次拷贝回用户空间\",\"select无法得知具体是哪个fd就绪，需要遍历fd_set\",\"fd_set监听的fd数量不能超过1024、\"]},\"406\":{\"h\":\"POLL\",\"t\":[\"poll 模式对 select 模式做了简单改进，但是性能提升并不明显，部分关键代码如下：\",\"// pollfd 中的事件类型 #define POLLIN //可读事件 #define POLLOUT //可写事件 #define POLLERR //错误事件 #define POLLNVAL //fd未打开 // pollfd结构 struct pollfd{ int fd; // 要监听的 fd *short int events; // 要监听的事件类型:读、写、异常 short int revents; // 实际发生的事件类型 } // poll函数 int poll( struct pollfd xfds, // pollfd数组，可以自定义大小 nfds_t nfds, // 数组元素个数 int timeout // 超时时间 ); \",\"IO 流程：\",\"创建 pollfd 数组，向其中添加关注的fd 信息，数组大小自定义\",\"调用 poll 函数，将 pollfd 数组拷贝到内核空间，转链表存储，无上限\",\"内核遍历 fd ，判断是否就绪\",\"数据就绪或超时后，拷贝 pollfd 数组到用户空间，返回就绪 fd 数量 n\",\"用户进程判断 n 是否大于 0\",\"大于 0 则遍历 pollfd 数组，找到就绪的 fd\",\"与 SELECT 比较：\",\"select 模式中的 fd_set 大小固定值为 1024 ，而 pollfd 在内核中采用链表，理论上是无限的\",\"监听的 FD 越多，每次遍历消耗的时间也越久，性能反而会下降\"]},\"407\":{\"h\":\"EPOLL\",\"t\":[\"epoll 模式是对 select 和 poll 模式的改进， 提供了三个函数：\",\"struct eventpoll{ //... struct rb_root rbr; // 一颗红黑树，记录要监听的fd struct list_head rdlist; // 一个链表，记录就绪的 FD //... } // 1.会在内核创建eventpolL结构体，返回对应的句柄epfd int epoll create(int size); // 2.将一个FD添加到epol的红黑树中，并设置ep_poli_calLback // calTback触发时，就把对应的FD加入到rdlist这个就绪列表中 int epoll _ctl( int epfd, // epoll实例的句柄 int op, // 要执行的操作，包括：ADD、MOD、DEL int fd, // 要监听的 FD struct epoll_event *event // 要监听的事件类型: 读、写、异常等 ); // 3.检查rdlist列表是否为空，不为空则返回就绪的FD的数量 int epoll wait( int epfd, // eventpoll 实例的句柄 struct epoll_event *events, // 空event 数组，用于接收就绪的 FD int maxevents, // events 数组的最大长度 int timeout // 超时时间，-1永不超时;0不阻塞;大于0为阻塞时间 ); \"]},\"408\":{\"h\":\"事件通知机制\",\"t\":[\"当 FD 有数据可读时，我们调用 epoll_wait 就可以得到通知，但是时间通知的模式有两种：\",\"LevelTriggered：简称 LT。当 FD 有数据可读时，会重复通知多次，直至数据处理完成。是 epoll 的默认模式。\",\"EdgeTriggered：简称 ET。当 FD 有数据可读时，只会通知一次，不管数据是否被处理完成\",\"举个例子\",\"假设一个客户端 Socket 对应的 FD 已经注册到了 epoll 实例中\",\"客户端 Socket 发送了 2kb 的数据\",\"服务端调用 epoll_wait ，得到通知说 FD 就绪\",\"服务端从 FD 读取了 1kb 的数据\",\"回到步骤三（再次调用 epoll_wait ，形成循环）\",\"结论\",\"ET 模式避免了 LT 模式可能出现的惊群现象\",\"ET 模式最好结合非阻塞 IO 读取 FD 数据，相比 LT 会复杂一些\"]},\"409\":{\"h\":\"WEB服务流程\",\"t\":[\"基于 epoll 模式的 web 服务的基本流程图：\"]},\"410\":{\"h\":\"总结\",\"t\":[\"select 模式的存在的三个问题：\",\"能监听的 FD 最大不超过 1024 个\",\"每次 select 都需要把所有要监听的 FD 都拷贝到内核空间\",\"每次都要遍历所有 FD 来判断就绪状态\",\"poll 模式的问题：\",\"poll 利用链表解决了 select 中监听 FD 上限的问题，但是依然要遍历所有的 FD ，如果监听较多，性能会下降\",\"epoll 模式中如何解决这些问题:\",\"基于 epoll 实例中的红黑树保存要监听的 FD ，理论上无上限，而且增删改查效率都非常高，性能不会随监听的 FD 数量增多而产生显著的下降\",\"每个 FD 只需要执行一次 epoll_ctl 添加到红黑树，以后每次 epoll_wait 无需传递任何参数，无需重复拷贝 FD 到内核空间\",\"内核会将就绪的 FD 直接拷贝到用户空间的指定位置，用户进程无需遍历所有 FD 就能知道就绪的 FD 是谁\"]},\"411\":{\"h\":\"信号驱动IO\",\"t\":[\"信号驱动 IO 是与内核建立 SIGIO 的信号关联并设置回调，当内核有 FD 就绪时，会发出 SIGIO 信号通知用户，期间用户应用可以执行其他业务，无需阻塞等待。\",\"当有大量 IO 操作时，信号较多，SIGIO 处理函数不能及时处理可能导致信号队列溢出。\",\"而且内核空间与用户空间的频繁信号交互性能也较低。\"]},\"412\":{\"h\":\"异步IO\",\"t\":[\"异步 IO 的整个过程都是非阻塞的，用户进程调用完异步 API 后就可以去做其他事情，内核等待数据就绪并拷贝到用户空间后才会递交信号，通知用户进程。\",\"在异步 IO 模型中，用户进程在两个阶段都是非阻塞的状态。\",\"异步 IO 模型虽然很简单，但是在高并发的访问下，内核中会处理大量请求，容易导致内核崩溃。\"]},\"413\":{\"h\":\"同步和异步\",\"t\":[\"IO 操作是同步还是异步，关键看数据在内核空间与用户空间的拷贝过程（数据读写的IO操作），也就是阶段二是同步还是异步：\"]},\"414\":{\"h\":\"Redis原理 - 五种数据类型的底层结构关系\"},\"415\":{\"h\":\"字符串对象String\",\"t\":[\"String 是 Redis 中最常见的数据存储类型。\",\"其基本编码方式是 RAW ，基于简单动态字符串（SDS）实现，存储上限为 512 MB。\",\"如果存储的 SDS 长度小于 44 字节，则会采用 EMBSTR 编码，此时 object head 与 SDS 是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高。\",\"如果存储的字符串是整数型，并且大小在 LONG_MAX 范围内，则会采用INT 编码：直接将数据保存在 RedisObject 的 ptr 指针位置（刚好 8 字节），不再需要 SDS 了。\"]},\"416\":{\"h\":\"列表对象List\",\"t\":[\"Redis 的 List 结构类似一个双端链表，可以从首、尾操作列表中的元素：\",\"在 3.2 版本之前，Redis 采用 ZipList 和LinkedList 来实现 List，当元素数量小于512并且元素大小小于 64 字节时，采用 ZipList 编码，超过则采用 LinkedList 编码\",\"在 3.2 版本之后，Redis 统一采用 QuickList 来实现List\"]},\"417\":{\"h\":\"哈希对象Hash\",\"t\":[\"哈希对象的键是一个字符串类型，值是一个键值对集合。\",\"哈希对象的编码可以是 ziplist 或者 hashtable；对应的底层实现有两种, 一种是ziplist, 一种是dict。\",\"哈希结构与 Redis 中的 Zset 非常类似：\",\"都是键值存储\",\"都需求根据键获取值\",\"键必须唯一\",\"因此 Hash 底层采用的编码与 Zset 基本一致，只需要把排序有关的 SkipList 去掉即可：\",\"Hash 结构默认采用了 ZipList 编码，用以节省内存。ZipList 中相邻的两个 entry 分别保存 field 和 value\",\"当数据量较大时 Hash 结构会转换为 HT 编码，也就是 Dict ，触发条件有两个：\",\"ZipList 中的元素数量超过了 hash-max-ziplist-entries（默认512）\",\"ZipList 中的任意 entry 大小超过了 hash-max-ziplist-value（默认64字节）\"]},\"418\":{\"h\":\"集合对象Set\",\"t\":[\"Set 是 Redis 中的单列集合，满足下列特点：\",\"不保证有序\",\"保证元素唯一（可以判断元素是否存在）\",\"求交集、并集、差集\",\"Set 是 Redis 中的集合，不一定确保元素有序，可以满足元素唯一、查询效率要求极高。\",\"为了查询效率和唯一性，set 采用 HT 编码（Dict）。Dict 中的 key 用来存储元素，value 统一为 null\",\"当存储的所有数据都是整数，并且元素数量不超过set-max-intset-entries时，Set 会采用 IntSet 编码，以节省内存。每一次插入数据时都会判断数据是否为整数。\"]},\"419\":{\"h\":\"有序集合对象ZSet\",\"t\":[\"ZSet 也就是 SortedSet ，其中每一个元素都需要指定一个score 值和 member 值。\",\"可以根据score 值排序\",\"member 必须唯一\",\"可以根据 member 查询分数\",\"因此，ZSet 底层数据结构必须满足键值存储、键必须唯一、可排序这几个需求。\",\"SkipList：可以排序，并且可以同时存储 score 和 ele 值（member）。可以实现排序功能\",\"HT(Dict)：可以键值存储，并且可以根据 key 找 value。可以实现快速访问功能\",\"为了同时实现排序和快速访问的功能，实际上的 ZSet 底层同时使用了两种结构，但由于编码方式只能写一种，这里写的是 OBJ_ENCODING_SKIPLIST\",\"当元素数量不多时，HT 和 SkipList 的优势不明显，而且更耗费内存。因此 ZSet 还采用 ZipList 结构来节省内存，不过需要同时满足连个条件：\",\"元素数量小于 zset_max_ziplist_entries，默认值 128\",\"每个元素都小于 zset_max_ziplist_value字节，默认值 64\",\"ZipList 本身没有排序功能，也没有键值对的概念，因此需要有 zset 通过编码实现：\",\"ZipList 是连续内存，因此 score 和 element 是紧挨在一起的两个 entry ，element在前，score 在后。\",\"score 越小越接近队首，score 越大越接近队尾，按照 score 值升序排列\"]},\"420\":{\"h\":\"Redis原理 - 通信协议RESP\"},\"421\":{\"h\":\"RESP协议\",\"t\":[\"Redis 是一个 CS 架构的软件，通信一般分两步（不包括pipeline 和 PubSub）：\",\"客户端（client）向服务端（server）发送一条命令\",\"服务端解析并执行命令，返回响应结果给客户端\",\"因此客户端发送命令的格式、服务端响应结果的格式必须有一个规范，这个规范就是通信协议。\",\"CS架构\",\"CS架构一般指服务器-客户机。 服务器-客户机，即Client-Server(C/S)结构。C/S结构通常采取两层结构。服务器负责数据的管理，客户机负责完成与用户的交互任务。\",\"百度百科-CS架构\",\"而在 Redis 中采用的是 RESP 协议（Redis Sericlization Protocol）协议：\",\"Redis 1.2 版本引入了 RESP 协议\",\"Redis 2.0 版本中成为与 Redis 服务端通信的标准，成为 RESP 2\",\"Resis 6.0 版本中，从 RESP2 升级到了 RESP3 协议，增加了更多数据类型并且支持 6.0 的新特性——客户端缓存\",\"但是目前，默认使用的还是 RESP2 协议，也是我们需要重点掌握的协议。\",\"在 RESP 中，通过首字节的字符来区分不同数据类型，常用的数据类型包括5种：\",\"单行字符串：首字节是 ‘+’，后面跟上单行字符串，以CRLF（\\\"\\\\r\\\\n\\\"）结尾，例如返回“OK”：\\\"+OK\\\\r\\\\n\\\"\",\"错误(Errors)：首字节是 '-'，与单行字符串格式一样，只是字符串是异常信息，例如：\\\"-Error message\\\\r\\\\n\\\"\",\"数值：首字节是 ':' ，后面跟上数字格式的字符串，以 CRLF 结尾。例如：\\\":10\\\\r\\\\n\\\"\",\"多行字符串：首字节是 '$'，表示二进制安全的字符串，最大支持 512 MB \",\"如果大小为0，则代表空字符串：\\\"$0\\\\r\\\\n\\\\r\\\\n\\\"\",\"如果大小为-1，则代表不存在：\\\"$-1\\\\r\\\\n\\\"\",\"这种方式通过记录字符串长度，来达到存储特殊字符的字符串的目的。例如存储 hello字符串，底层存储为：\\\"$5\\\\r\\\\nhello\\\\r\\\\n\\\"\",\"数组：首字节是 '*'，后面跟上数组元素个数，再跟上元素，元素数据类型不限，可以是上述所有类型，还可以是数组。例如：\",\"*4\\\\r\\\\n $3\\\\r\\\\nset\\\\r\\\\n $4\\\\r\\\\nname\\\\r\\\\n $6\\\\r\\\\n小鹏\\\\r\\\\n *2\\\\r\\\\n$3\\\\r\\\\nage\\\\r\\\\n:10\\\\r\\\\n \",\"中文字符，一个占3个字节。\"]},\"422\":{\"h\":\"自定义客户端\",\"t\":[\"基于 Socket 自定义 Redis 客户端。\",\"class MyRedisClient{ static Socket s; static PrintWriter writer; static BufferedReader reader; public static void main(String[] args) { try { // 1.建立连接 String host = \\\"127.0.0.1\\\"; int port = 6379; s = new Socket(host, port); // 2.获取输出流、输入流 writer = new PrintWriter(new OutputStreamWriter(s.getOutputStream(), StandardCharsets.UTF_8)); reader = new BufferedReader(new InputStreamReader(s.getInputStream(), StandardCharsets.UTF_8)); // 3.发出请求 // 3.1.获取授权 auth codermast sendRequest(\\\"auth\\\", \\\"codermast\\\"); Object obj = handleResponse(); System.out.println(\\\"obj = \\\" + obj); // 3.2.set name 小鹏 sendRequest(\\\"set\\\", \\\"name\\\", \\\"小鹏\\\"); // 4.解析响应 obj = handleResponse(); System.out.println(\\\"obj = \\\" + obj); // 3.2.set name 小鹏 sendRequest(\\\"get\\\", \\\"name\\\"); // 4.解析响应 obj = handleResponse(); System.out.println(\\\"obj = \\\" + obj); // 3.2.set name 小鹏 sendRequest(\\\"mget\\\", \\\"name\\\", \\\"num\\\", \\\"msg\\\"); // 4.解析响应 obj = handleResponse(); System.out.println(\\\"obj = \\\" + obj); } catch (IOException e) { e.printStackTrace(); } finally { // 5.释放连接 try { if (reader != null) reader.close(); if (writer != null) writer.close(); if (s != null) s.close(); } catch (IOException e) { e.printStackTrace(); } } } private static Object handleResponse() throws IOException { // 读取首字节 int prefix = reader.read(); // 判断数据类型标示 switch (prefix) { case '+': // 单行字符串，直接读一行 return reader.readLine(); case '-': // 异常，也读一行 throw new RuntimeException(reader.readLine()); case ':': // 数字 return Long.parseLong(reader.readLine()); case '$': // 多行字符串 // 先读长度 int len = Integer.parseInt(reader.readLine()); if (len == -1) { return null; } if (len == 0) { return \\\"\\\"; } // 再读数据,读len个字节。我们假设没有特殊字符，所以读一行（简化） return reader.readLine(); case '*': return readBulkString(); default: throw new RuntimeException(\\\"错误的数据格式！\\\"); } } private static Object readBulkString() throws IOException { // 获取数组大小 int len = Integer.parseInt(reader.readLine()); if (len <= 0) { return null; } // 定义集合，接收多个元素 List<Object> list = new ArrayList<>(len); // 遍历，依次读取每个元素 for (int i = 0; i < len; i++) { list.add(handleResponse()); } return list; } // set name 小鹏 private static void sendRequest(String ... args) { writer.println(\\\"*\\\" + args.length); for (String arg : args) { writer.println(\\\"$\\\" + arg.getBytes(StandardCharsets.UTF_8).length); writer.println(arg); } writer.flush(); } } \"]},\"423\":{\"h\":\"Redis原理 - 数据结构的底层实现\"},\"424\":{\"h\":\"动态字符串SDS\"},\"425\":{\"h\":\"基本概念\",\"t\":[\"Redis 中保存的 Key 是字符串，Value 往往是字符串或者字符串的集合。可见字符串是 Redis 中最常见的一种数据结构。\",\"Redis 是使用 C 语言来编写的，C 语言中也有字符串，但是 Redis 中并没有直接使用 C 语言的字符串，这是因为 C 语言中字符串存在着很多的问题：\",\"获取字符串长度需要进行运算\",\"非二进制安全，不能包含特殊字符\",\"因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。\",\"不可修改，C 语言的字符串实质为字符数组，以\\\\0结尾。\",\"为了解决以上问题，Redis 自己构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称为SDS\"]},\"426\":{\"h\":\"底层实现\",\"t\":[\"SDS 在 Redis 中的实现在 /src/sds.h、/src/sds.c 文件中，具体的核心实现如下：\",\"/* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */ struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; \",\"标识符对应信息\",\"标识信息\",\"对应值\",\"SDS_TYPE_5\",\"0\",\"SDS_TYPE_8\",\"1\",\"SDS_TYPE_16\",\"2\",\"SDS_TYPE_32\",\"3\",\"SDS_TYPE_64\",\"4\",\"例如，一个包含字符串name的sds结构如下：\"]},\"427\":{\"h\":\"内存预分配\",\"t\":[\"SDS 之所以叫做动态字符串，是因为其具备动态扩容的能力，例如一个内容为 “hi” 的 SDS\",\"假如我们要给 SDS 追加一段字符串 “,Amy” ，这里因为空间不够，需要申请新的内存空间：\",\"如果新字符串小于 1M ，则新空间扩展后字符串长度的两倍 + 1\",\"如果新字符串大于 1M ，则新空间为扩展后字符串长度 + 1M + 1。称为内存预分配\",\"优点\",\"获取字符串长度的时间复杂度为 O(1)\",\"支持动态扩容\",\"减少内存分配次数\",\"二进制安全，字符串可存储特殊字符\"]},\"428\":{\"h\":\"SDS小结\",\"t\":[\"Redis的字符串表示为 SDS ，而不是 C 字符串（以\\\\0结尾的char*）， 它是 Redis 底层所使用的字符串表示，它被用在几乎所有的 Redis 模块中。可以看如下对比：\",\"一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）：包括 AOF 模块中的AOF缓冲区以及客户端状态中的输入缓冲区。\"]},\"429\":{\"h\":\"整数集IntSet\"},\"430\":{\"h\":\"基本概念\",\"t\":[\"IntSet 是 Redis 中 Set 集合类型的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。\",\"当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。\",\"为了方便查找，Redis 会将 IntSet 中所有的整数按照升序依次保存在 contents 数组中，结构图如下\",\"现在数组中每个数字都保存在 int16_t 的范围内，因此采用的编码方式为 INTSET_ENC_INT16，每部分占用的字节大小为：\",\"encoding：4 字节\",\"length：4 字节\",\"contents：2 字节 * 3 = 6 字节\",\"共计 4 + 4 + 6 = 16 字节\"]},\"431\":{\"h\":\"底层实现\",\"t\":[\"typedef struct intset { uint32_t encoding; uint32_t length; int8_t contents[]; } intset; \"]},\"432\":{\"h\":\"数组扩容\",\"t\":[\"当在一个 int8 类型的整数集合中添加一个 int16 类型的数据元素，那么整个整数集合中的元素都会升级为 int16 类型，内存不够时还会进行扩容。具体的步骤如下：\",\"根据新元素的数据类型，改变编码方式。按照新的编码方式及元素的个数进行数组扩容\",\"倒序依次将数组中的元素拷贝到扩容后的正确位置。倒序是为了防止正序拷贝时的数据覆盖，不会产生数据丢失。\",\"把待添加的元素放入数组末尾\",\"修改 encoding 信息，并将length + 1，维护好各项属性\",\"底层实现\",\"插入元素\",\"代码详情\",\"/* Insert an integer in the intset */ intset *intsetAdd(intset *is, int64_t value, uint8_t *success) { // 获取当前值编码 uint8_t valenc = _intsetValueEncoding(value); // 要插入的位置 uint32_t pos; if (success) *success = 1; // 判断编码是不是超过了当前 intset 的编码 if (valenc > intrev32ifbe(is->encoding)) { // 超出编码，需要升级 return intsetUpgradeAndAdd(is,value); } else { // 在当前 intset 中查找值与 value 一样的元素的角标 pos if (intsetSearch(is,value,&pos)) { // 如果找到了，则无需插入，直接结束并返回失败 if (success) *success = 0; return is; } // 数组扩容 is = intsetResize(is,intrev32ifbe(is->length)+1); // 移动数组中 pos 之后的元素到 pos + 1，给新元素腾出空间 if (pos < intrev32ifbe(is->length)) intsetMoveTail(is,pos,pos+1); } // 插入新元素 _intsetSet(is,pos,value); is->length = intrev32ifbe(intrev32ifbe(is->length)+1); return is; } \",\"数组扩容\",\"代码详情\",\"/* Upgrades the intset to a larger encoding and inserts the given integer. */ static intset *intsetUpgradeAndAdd(intset *is, int64_t value) { // 当前 intset 编码 uint8_t curenc = intrev32ifbe(is->encoding); // 新编码 uint8_t newenc = _intsetValueEncoding(value); // 元素个数 int length = intrev32ifbe(is->length); // 判断元素是大于 0 还是，小于 0。小于 0 插入队首，大于 0 插入队尾。 int prepend = value < 0 ? 1 : 0; // 重置编码为新编码 is->encoding = intrev32ifbe(newenc); // 重置数组大小 is = intsetResize(is,intrev32ifbe(is->length)+1); // 倒序遍历，逐个搬运元素到新的位置，_intsetGetEncoding按照旧编码方式查找旧元素 while(length--) // _intsetSet按照新编码方式插入新元素 _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc)); // 插入新元素，prepend 决定是插入队首，还是队尾 if (prepend) _intsetSet(is,0,value); else _intsetSet(is,intrev32ifbe(is->length),value); // 修改数组长度 is->length = intrev32ifbe(intrev32ifbe(is->length)+1); return is; } \",\"数组查询\",\"代码详情\",\"/* Search for the position of \\\"value\\\". Return 1 when the value was found and * sets \\\"pos\\\" to the position of the value within the intset. Return 0 when * the value is not present in the intset and sets \\\"pos\\\" to the position * where \\\"value\\\" can be inserted. */ static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) { int min = 0, max = intrev32ifbe(is->length)-1, mid = -1; int64_t cur = -1; /* The value can never be found when the set is empty */ if (intrev32ifbe(is->length) == 0) { if (pos) *pos = 0; return 0; } else { /* Check for the case where we know we cannot find the value, * but do know the insert position. */ if (value > _intsetGet(is,max)) { if (pos) *pos = intrev32ifbe(is->length); return 0; } else if (value < _intsetGet(is,0)) { if (pos) *pos = 0; return 0; } } while(max >= min) { mid = ((unsigned int)min + (unsigned int)max) >> 1; cur = _intsetGet(is,mid); if (value > cur) { min = mid+1; } else if (value < cur) { max = mid-1; } else { break; } } if (value == cur) { if (pos) *pos = mid; return 1; } else { if (pos) *pos = min; return 0; } } \",\"思考\",\"在添加数据时会进行扩容操作，那么在删除数据时会进行缩容操作吗？那么如果删除掉刚加入的int16类型时，会不会做一个降级操作呢？\",\"答案：不会。主要还是减少开销的权衡。\"]},\"433\":{\"h\":\"IntSet小结\",\"t\":[\"IntSet 可以看做是特殊的整数数组，具备一些特点：\",\"Redis 会确保 IntSet 中的元素唯一、有序\",\"具备类型升级机制，可以节省内存空间\",\"底层采用二分查找方式来查询\"]},\"434\":{\"h\":\"字典/哈希表Dict\"},\"435\":{\"h\":\"基本概念\",\"t\":[\"Dict Dict 由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）\",\"哈希算法\",\"Redis 计算哈希值和索引值方法如下：\",\"使用字典设置的哈希函数，计算键 key 的哈希值hash = dict->type->hashFunction(key);\",\"使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值index = hash & dict->ht[x].sizemask;\",\"哈希冲突\",\"哈希冲突（Hash Collision）是指在使用哈希表存储数据时，两个或多个不同的键（Key）被哈希函数映射到同一个位置的情况。这种情况会导致数据的存储和查找变得复杂，因此需要采取一些措施来解决哈希冲突。\",\"Dict 中解决哈希冲的方法是 链地址法。\",\"其他办法\",\"除了链地址法解决哈希冲突以外，还可以使用开放地址法、在哈希法、建立公共溢出区等方法解决。\"]},\"436\":{\"h\":\"底层实现\",\"t\":[\"哈希表\",\"typedef struct dictht{ // entry 数组 // 数组中保存的是指向 entry 的指针 dictEntry **table; // 哈希大小 unsigned long size; // 哈希表大小的掩码，总等于 size - 1 unsigned long sizemask; // entry 个数 unsigned long used; } dictht; \",\"哈希节点\",\"typedef struct dictEntry { void *key; // 键 union { void *val; uint64_t u64; int64_t s64; double d; } v; // 值 // 下一个 Entry 的指针 struct dictEntry *next; } dictEntry; \",\"当我们向 Dict 添加键值对时，Redis 首先根据 key 计算出 hash 值（h），然后利用 h & sizemask 来计算元素应该存储到数组中的哪个索引位置。\",\"字典\",\"typedef struct dict{ // dict 类型，内置不同的 hash 函数 dictType *type; // 私有数组，在做特殊 hash 运算时使用 void *privdata; // 一个Dict包含两个哈希表，其中一个是当前数据，另一个一般是空，rehash时使用 dictht ht[2]; // rehash 的进度，-1 表示未进行 long rehashidx; // rehash是否暂停，1则暂停，0则继续] int16_t pauserehash; }dict; \"]},\"437\":{\"h\":\"扩容收缩\",\"t\":[\"当哈希表保存的键值对太多或者太少时，就要通过 rehash(重新散列）来对哈希表进行相应的扩展或者收缩。\",\"扩容\",\"Dict 中的 HashTable 就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。\",\"Dict在每次新增键值对时都会检查负载因子，满足以下两种情况时会触发哈希表扩容：\",\"哈希表的 LocalFactor >= 1，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程。\",\"哈希表的 LocalFactor > 5，无论是否在执行BGSAVE 命令或者 BGREWRITEAOF 命令。\",\"负载因子\",\"负载因子 = 哈希表已保存节点数量 / 哈希表大小。\",\"收缩\",\"Dict 除了扩容以外，每次删除元素时，也会对负载因子做检查，当 LocalFactor < 0.1 时，会做哈希收缩。\",\"扩容收缩的具体步骤如下：\",\"如果执行扩展操作，会基于原哈希表创建一个大小等于 ht[0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。\",\"重新利用哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。\",\"所有键值对都迁徙完毕后，释放原哈希表的内存空间。\"]},\"438\":{\"h\":\"ReHash\",\"t\":[\"不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的 size 和 sizemask 变化，而 key 的查询与 sizemask 有关。因此必须对哈希表中的每一个 key 重新计算索引，插入新的哈希表，这个过程称为 rehash。具体的步骤如下。\",\"计算新hash表的realesize，值取决于当前要做的是扩容还是收缩： \",\"如果是扩容，则新size为第一个大于等于dict.ht[O].used + 1的 2n\",\"如果是收缩，则新size为第一个大于等于dict.ht[O].used的2n (不得小于4)\",\"按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]\",\"设置dict.rehashidx=0，标示开始rehash\",\"将 dict.ht[O] 中的每一个dictEntry都rehash到dict.ht[1]\",\"将 dict.ht[1] 赋值给dict.ht[O]，给 dict.ht[1] 初始化为空哈希表，释放原来的dict.ht[O]的内存\",\"Dict的 rehash 并不是一次性完成的，如果 Dict 中包含数百万的 entry ，要在一次 rehash 完成，极有可能导致主线程阻塞。因此 Dict 的 rehash 是分多次、渐进式的完成，因此称为渐进式 rehash。\",\"计算新hash表的realesize，值取决于当前要做的是扩容还是收缩：\",\"如果是扩容，则新size为第一个大于等于dict.ht[O].used + 1的 2n\",\"如果是收缩，则新size为第一个大于等于dict.ht[O].used的2n (不得小于4)\",\"按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]\",\"设置dict.rehashidx=0，标示开始rehash\",\"每次执行新增、查询、修改、删除操作时，都检查一下dict.rehashidx是否大于-1，如果是则将dict.ht[0].table[rehashid]的entry链表rehash到dictht[1]，并且将rehashidx++。直至dict.ht[0]的所有数据都rehash到dict.ht[1]\",\"将 dict.ht[1] 赋值给dict.ht[O]，给 dict.ht[1] 初始化为空哈希表，释放原来的dict.ht[O]的内存\",\"将rehashidx赋值为-1，代表rehash结束\",\"在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict,ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空\",\"什么叫渐进式 rehash？\",\"也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成 Redis 一段时间内不能进行别的操作。所以 Redis 采用渐进式 rehash，这样在进行渐进式 rehash 期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行增加操作，一定是在新的哈希表上进行的。\",\"可以简单的理解为慢慢的将旧的哈希表，慢慢迁移到新的哈希表中。\"]},\"439\":{\"h\":\"Dict小结\",\"t\":[\"Dict的结构\",\"类似java的HashTable，底层是数组加链表来解决哈希冲突\",\"Dict包含两个哈希表，ht[0]平常用，ht[1]用来rehash\",\"Dict的伸缩\",\"当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容\",\"当LoadFactor小于0.1时，Dict收缩\",\"扩容大小为第一个大于等于used + 1的2n\",\"收缩大小为第一个大于等于used的2n\",\"Dict采用渐进式rehash，每次访问Dict时执行一次rehash\",\"rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表\"]},\"440\":{\"h\":\"压缩列表ZipList\",\"t\":[\"ZipList 可以看做一种特殊的双端链表，由一系列特殊编码的连续内存块组成。可以在任意一端压入弹出操作，并且该操作的时间复杂度为 O(1)。\"]},\"441\":{\"h\":\"ZipListEntry\",\"t\":[\"ZipList 中的Entry 并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用 16 个字节，浪费内存，而是采用了如下的结构：\",\"为什么ZipList特别省内存\",\"理解了 ZipList 的 Entry 结构，就很容易理解 ZipList 为什么节省内存。\",\"ziplist 节省内存是相对于普通的list来说的，如果是普通的数组，那么它每个元素占用的内存是一样的且取决于最大的那个元素（很明显它是需要预留空间的）\",\"所以 ziplist 在设计时就很容易想到要尽量让每个元素按照实际的内容大小存储，所以增加 encoding 字段，针对不同的 encoding 来细化存储大小\",\"这时候还需要解决的一个问题是遍历元素时如何定位下一个元素呢？在普通数组中每个元素定长，所以不需要考虑这个问题；但是 ziplist 中每个 data 占据的内存不一样，所以为了解决遍历，需要增加记录上一个元素的 length，所以增加了 prelen 字段。\"]},\"442\":{\"h\":\"Encoding编码\",\"t\":[\"ZipListEntry 中的 Encoding 编码分为字符串和整数两种类型：\",\"字符串：Encoding 是以 \\\"00\\\"、\\\"01\\\"、\\\"10\\\" 开头，则 content 为字符串类型\",\"|00pppppp| ：此时encoding长度为1个字节，该字节的后六位表示entry中存储的string长度，因为是6位，所以entry中存储的string长度不能超过63；\",\"|01pppppp|qqqqqqqq| 此时encoding长度为两个字节；此时encoding的后14位用来存储string长度，长度不能超过16383；\",\"|10000000|qqqqqqqq|rrrrrrrr|ssssssss|ttttttt| 此时encoding长度为5个字节，后面的4个字节用来表示encoding中存储的字符串长度，长度不能超过2^32 - 1;\",\"整数：Encoding 是以 \\\"11\\\" 开头，则 content 为整数类型，且 encoding 固定只占用 1 个字节。\",\"11000000：int16_t （2 bytes）\",\"11010000：int32_t （4 bytes）\",\"11100000：int64_t （8 bytes）\",\"11110000：24位有符号整数 （3 bytes）\",\"11111110：8 位有符号整数 （1 bytes）\",\"1111xxxx：直接在 xxxx 位置保存数值，范围从 0001~1101 减 1 后结果为实际值\",\"11111111 ： zlend\"]},\"443\":{\"h\":\"连锁更新问题\",\"t\":[\"ZipListEntry 节点中保存前一个节点的大小长度，前一个节点长度小于254字节，则使用一个字节保存这个长度，如果大于等于254字节，则使用 5 个字节来保存这个长度。那么当一个节点数据发生变化时，恰好从 254 字节以下变到 254 字节以上，那么 previous_entry_length 属性从1个字节变为5个字节，由于 ZipList 中 Entry 节点是连续存在的，则需要将后续的所有节点进行移动。如果后续空间不足，还需要申请新的空间等问题。\",\"ZipList 这种特殊情况下产生的连续多次空间扩展操作称之为 连锁更新 。新增删除都可能导致连锁更新的发生。ZipList 也不预留内存空间, 并且在移除结点后, 也是立即缩容, 这代表每次写操作都会进行内存分配操作.\"]},\"444\":{\"h\":\"ZipList小结\",\"t\":[\"压缩列表ZipList 可以看做一种连续内存空间的“双端链表”。\",\"列表的节点之间并不是通过指针连接的，而是记录上一个节点和本节点长度来寻址，内存占用较低。\",\"如果列表数据较多，导致链表过长，可能会影响查询效率。查询时只能进行遍历，O(n)\",\"增或者删较大数据时有可能发生连续更新问题。\",\"思考\",\"ZipList 虽然节省内存，但是申请内存必须是连续空间，如果内存占用较多，申请内存的效率很低。怎么办？\",\"为了缓解这个问题，我们必须限制 ZipList 的长度和 Entry 大小。\",\"我们要存储大量数据，超出了 ZipList 最佳的上限该怎么办？\",\"我们可以创建多个 ZipList 来分片存储数据。\",\"数据拆分存储以后比较分散，不方便管理和查找，这多个 ZipList 如何建立联系？\",\"Redis3.2版本引入了新的数据结构 QuickList ，它是一个双端链表，只不过链表中的每个节点都是一个 ZipList 。\"]},\"445\":{\"h\":\"快速列表QuickList\"},\"446\":{\"h\":\"基本概念\",\"t\":[\"QuickList 这个结构是 Redis3.2 版本后新加的, 之前的版本是 list(即 LinkedList)， 用于 String 数据类型中。\",\"QuickList 是一种以 ZipList 为结点的双端链表结构。 从宏观上看，QuickList是一个双向链表，从微观上看，QuickList 的每一个节点都是一个 ZipList。\",\"QuickList示意图\"]},\"447\":{\"h\":\"底层实现\",\"t\":[\"quicklistNote\",\"代码详情\",\"typedef struct quicklistNode { struct quicklistNode *prev; struct quicklistNode *next; unsigned char *entry; size_t sz; /* entry size in bytes */ unsigned int count : 16; /* count of items in listpack */ unsigned int encoding : 2; /* RAW==1 or LZF==2 */ unsigned int container : 2; /* PLAIN==1 or PACKED==2 */ unsigned int recompress : 1; /* was this node previous compressed? */ unsigned int attempted_compress : 1; /* node can't compress; too small */ unsigned int dont_compress : 1; /* prevent compression of entry that will be used later */ unsigned int extra : 9; /* more bits to steal for future usage */ } quicklistNode; \",\"quicklistLZF\",\"代码详情\",\"typedef struct quicklistLZF { size_t sz; /* LZF size in bytes*/ char compressed[]; } quicklistLZF; \",\"quicklistBookmark\",\"代码详情\",\"typedef struct quicklistBookmark { quicklistNode *node; char *name; } quicklistBookmark; \",\"quicklist\",\"代码详情\",\"typedef struct quicklist { quicklistNode *head; quicklistNode *tail; unsigned long count; /* total count of all entries in all listpacks */ unsigned long len; /* number of quicklistNodes */ signed int fill : QL_FILL_BITS; /* fill factor for individual nodes */ unsigned int compress : QL_COMP_BITS; /* depth of end nodes not to compress;0=off */ unsigned int bookmark_count: QL_BM_BITS; quicklistBookmark bookmarks[]; } quicklist; \",\"quicklistIter\",\"代码详情\",\"typedef struct quicklistIter { quicklist *quicklist; quicklistNode *current; unsigned char *zi; /* points to the current element */ long offset; /* offset in current listpack */ int direction; } quicklistIter; \",\"quicklistEntry\",\"代码详情\",\"typedef struct quicklistEntry { const quicklist *quicklist; quicklistNode *node; unsigned char *zi; unsigned char *value; long long longval; size_t sz; int offset; } quicklistEntry; \"]},\"448\":{\"h\":\"限制压缩\",\"t\":[\"限制\",\"为了避免 QuickList 中的每一个 ZipList 中 Entry 过多，Redis 提供了一个配置项：list-max-ziplist-size 来限制。\",\"如果值为正，则代表 ZipList 允许 Entry 个数的最大值\",\"如果值为负，则代表 ZipList 的最大内存大小，分为5种情况： \",\"-1 ：每个 ZipList 的内存占用不能超过 4 kb\",\"-2 ：每个 ZipList 的内存占用不能超过 8 kb\",\"-3 ：每个 ZipList 的内存占用不能超过 16 kb\",\"-4 ：每个 ZipList 的内存占用不能超过 32 kb\",\"-5 ：每个 ZipList 的内存占用不能超过 64 kb\",\"默认值为 -2 ，可以使用 config get list-max-ziplist-size命令查看。\",\"压缩\",\"除了控制 ZipList 的大小，QuickList 还可以对节点的 ZipList 做压缩。通过配置项 list-compress-depth 来控制。因为链表一般都是从首尾访问较多，所以首尾是不压缩的。这个参数是控制首尾不压缩的节点个数：\",\"0 ：特殊值，代表不压缩\",\"1 ：标示 QuickList 的首尾各有 1 个节点不压缩，中间节点压缩\",\"2 ：标示 QuickList 的首尾各有 2 个节点不压缩，中间节点压缩\",\"......依次类推\",\"默认值为0，可以使用config list-compress-depth命令查看\"]},\"449\":{\"h\":\"QuickList小结\",\"t\":[\"QuickList 是一个节点为 ZipList 的双端列表\",\"节点采用 ZipList ，解决了传统链表的内存占用问题\",\"控制 ZipList 大小，解决连续内存空间申请效率问题\",\"中间节点可以压缩，进一步节省了内存\"]},\"450\":{\"h\":\"跳表SkipList\",\"t\":[\"对于于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。比如查找12，需要7次查找。为了解决这个问题，我们可以给链表增加多级的索引指针，方便我们快速找到想要的节点。\"]},\"451\":{\"h\":\"基本概念\",\"t\":[\"SkipList （跳表）首先是链表，但是与传统的链表相比有些差异：\",\"SkipList 中的元素按照升序进行排列存储\",\"节点可能包含多个指针，指针的跨度不同，最多支持 32 级指针。\",\"几级指针代表一次横跨几个节点。\",\"SkipList内存结构\"]},\"452\":{\"h\":\"底层实现\",\"t\":[\"zskiplist\",\"typedef struct zskiplist { struct zskiplistNode *header, *tail; unsigned long length; int level; } zskiplist; \",\"zskiplistNode\",\"typedef struct zskiplistNode { sds ele; double score; struct zskiplistNode *backward; struct zskiplistLevel { struct zskiplistNode *forward; unsigned long span; } level[]; } zskiplistNode; \"]},\"453\":{\"h\":\"SkipList小结\",\"t\":[\"跳跃表是一个双向链表，每个节点都包含 score 和 ele 值\",\"节点按照 score 值排序，score 值一样则按照 ele 字典排序\",\"每个节点都可以包含多层指针，层数是 1 到 32 之间的随机数\",\"不同层指针到下一个节点的跨度不同，层级越高，跨度越大\",\"增删改查效率与红黑树基本一致，实现却更简单\"]},\"454\":{\"h\":\"Redis原理 - 内存策略\",\"t\":[\"Redis 本身是一个典型的 key-value 内存存储数据库，因此所有的 key、value 都保存在之前学习过的 Dict 结构中。不过在其 database 结构体中，有两个 Dict ：一个用来记录 key-value；另外一个用来记录 key-TTL\",\"typedef struct redisDb { dict *dict; // 存放所有 key 和 value 的地方 dict *expires; // 存放每一个 key 及其对应的 TTL 存活时间，只包含设置了 TTL 的 key dict *blocking_keys; dict *ready_keys; dict *watched_keys; int id; // Database ID ：0 ~ 15 long long avg_ttl; unsigned long expires_cursor; // expire 检查时在 dict 中抽样的索引位置 list *defrag_later; // 等待碎片整理的 key 列表 } redisDb; \",\"Redis 是如何知道一个 key 是否过期呢？\",\"答：利用两个 Dict 分别记录 key-value 和 key-ttl\",\"是不是 TTL 到期就立刻删除呢？\",\"答：并不是到期立刻删除，而是采用 惰性删除 和 周期删除。\"]},\"455\":{\"h\":\"删除策略\",\"t\":[\"定时删除：TTL 到期后，立刻删除对应的 key\",\"惰性删除：并不是在 TTL 到期后就立刻删除，而是在访问一个 key 的时候，检查该 key 的存活时间，如果已经过期，才执行删除。\",\"周期删除：是通过一个定时任务，周期性的抽样部分过期的 key，然后执行删除。执行周期有两种：\",\"Redis 会设置一个定时任务 serverCron()，按照 server.hz 的频率来执行过期 key 清理，模式为 SLOW，默认为 10\",\"Redis 的每个事情循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST\",\"SLOW模式规则:\",\"执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。\",\"执行清理耗时不超过一次执行周期的25%.\",\"逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期\",\"如果没达到时间上限 (25ms)并且过期key比例大于10%，再进行一次抽样，否则结束\",\"FAST模式规则 (过期key比例小于10%不执行)\",\"执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms\",\"执行清理耗时不超过1ms\",\"逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期\",\"如果没达到时间上限 (1ms)并且过期key比例大于10%，再进行一次抽样，否则结束\"]},\"456\":{\"h\":\"淘汰策略\",\"t\":[\"内存淘汰就是当 Redis 内存使用达到设置的阈值时，Redis 主动挑选部分 key 删除以释放更多的内存的流程。Redis 会在处理客户端命令的方法 processCommand() 中尝试做内存淘汰。\",\"Redis 一共支持 8 种淘汰策略\",\"noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键。\",\"allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键。\",\"volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键。\",\"allkeys-random：加入键的时候如果过限，从所有key随机删除。\",\"volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐。\",\"volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键。\",\"volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键。\",\"allkeys-lfu：从所有键中驱逐使用频率最少的键。\",\"LRU(Least Recently Used)：最少最近使用，用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。\",\"LFU(Least Frequently Used)：最少频率使用，会统计每个 key 的访问频率，值越小淘汰优先级越高。\",\"typedef struct redisObject( unsigned type:4;//对象类型 unsigned encoding:4;// 编码方式 unsigned lru:LRU_BITS; //LRU: 以秒为单位记录最近一次访问时间，长度24bit //LFU: 高16位以分钟为单位记录最近一次访问时间，低8位记录逻辑访问次数 int refcount; // 引用计数，计数为0则可以回收 void *ptr; // 数据指针，指向真实数据 ) robj; \",\"LRU 的访问次数之所以叫做逻辑访问次数，是因为并不是每次 key 被访问都计数，而是通过运算：\",\"生成 0 ~ 1 之间的随机数 R\",\"计算 1 / (旧次数 * lfu_log_factor + 1)，记录为 R，lfu_log_factor 默认为 10\",\"如果 R < P，则计数器 + 1，且最大不超过 255\",\"访问次数会随时间缩减，距离上一次访问时间每隔 lfu_decay_time 分钟（默认 1），计数器 -1\"]},\"457\":{\"h\":\"Redis原理 - Redis网络模型\"},\"458\":{\"h\":\"思考\",\"t\":[\"Redis 到底是单线程还是多线程？\",\"如果仅仅针对 Redis 的核心业务部分（命令处理部分），则是单线程\",\"如果针对 Redis 整体，那么就是多线程\",\"在 Redis 的版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：\",\"Redis v4.0：引入多线程异步处理一些耗时较长的任务，例如异步删除命令 unlike\",\"Redis v6.0：在核心网络模型中引入多线程，进一步提高对多核 CPU 的利用率\",\"为什么Redis要选择单线程?\",\"抛开持久化不谈，Redis是纯内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。\",\"多线程会导致过多的上下文切换，带来不必要的开销\",\"引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣\"]},\"459\":{\"h\":\"网络模型\",\"t\":[\"Redis 通过 IO 多路复用来提高网络性能，并且支持各种不同的多路复用实现，并且将这些实现进行封装，提供了统一的高性能事件库 API 库 AE：\",\"ae_epoll\",\"ae_evport\",\"ae_kqueue\",\"ae_select（通用）\",\"这是 Redis 中四种实现方式，根据不同的操作系统，选择不同的实现。\",\"具体的 API 主要有以下几个：\",\"aeApiCreate：创建多路复用程序，比如 epoll_create\",\"aeApiResize\",\"aeApiFree\",\"aeApiAddEvent：注册 FD ，比如 epoll_ctl\",\"aeApiDelEvent：删除 FD\",\"aeApiPoll：等待 FD 就绪，比如 epoll_wait\",\"aeApiName：select、poll\",\"ae_evport 实现方式中独有的API\",\"aeApiLookupPending\",\"aeApiAssociate\",\"在ae.c 文件中可以选择使用那种实现方式。\"]},\"460\":{\"h\":\"单线程网络模型\",\"t\":[\"Redis 6 以前的网络模型都是单线程的，Redis 单线程网络模型的整个过程：\",\"在 aeApiPoll 时，会判断是客户端可读还是服务端可读，调用不同的处理器\",\"当客户端 Client Socket 发起连接请求时，服务端 Server Socket 可读，触发连接应答处理器 tcpAccepthandler\",\"当客户端 Client Socket 发起命令时，客户端可读，触发命令请求处理器 readQueryFromClient\",\"当客户端可写时，会由命令回复处理器进行处理。\",\"核心\",\"本质上就是 IO 多路复用 + 事件派发 的应用。\",\"server socket 不断接收 client socket 的响应，然后根据事件类型的不同，派发给对应的处理器进行处理。\"]},\"461\":{\"h\":\"多线程网络模型\",\"t\":[\"Redis 6.0 版本中引入了多线程，目的是为了提高 IO 读写效率。因此在 解析客户端命令、 写响应结果 时采用了多线程。核心的命令执行、IO 多路复用模块依然是由主线程执行。\",\"通过对单线程网络模型的分析，主要的性能瓶颈在命令的读写处理和命令的响应输出两个方面。\",\"故Redis 在命令读处理和命令的响应两个部分引入了多线程。\",\"注意\",\"性能的瓶颈一般情况下都是 IO 的影响或者 网络请求 的影响。\"]},\"462\":{\"h\":\"底层实现\",\"t\":[\"main\",\"// server.c int main( int argc, char **argv ){ // ... // 初始化服务 initServer(); // ... // 开始监听事件循环 aeMain(server.el); // ... } \",\"initServer\",\"void initServer(void){ // ... // 内部会调用 aeApiCreate(eventLoop)，类似epoll_create server.el= aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR); //... // 监听TCP端口，创建ServerSocket，并得到FD listenToPort(server.port,&server.ipfd) // ... // 注册 连接处理器，内部会调用 aeApiAddEvent(&server.ipfd)监听FD createSocketAcceptHandler(&server.ipfd，acceptTcpHandler) // 注册 ae_api_poll 前的处理器 aeSetBeforeSleepProc(server.el,beforeSleep); } \",\"aeMain\",\"void aeMain(aeEventloop*eventloop){ eventLoop->stop = 0; // 循环监听事件 while (!eventLoop->stop){ aeProcessEvents( eventLoop， AE_ALL_EVENTS | AE_CALL_BEFORE_SLEEP | AE_CALL_AFTER_SLEEP); } } \",\"aeProcessEvents\",\"int aeProcessEvents(aeEventLoop *eventLoop,int flags){ // ... 调用前置处理器 beforesleep eventLoop->beforesleep(eventLoop); // 等待FD就绪，类似 epoll_wait numevents = aeApiPoll(eventLoop，tvp); for (j = 0; j < numevents; j ++){ // 遍历处理就绪的 FD，调用对应的处理器 } } \",\"acceptTcpHandler\",\"void acceptTcpHandler( ... ){ // ... // 接收 socket 连接，获取 FD fd = accept(s,sa,len); // ... // 创建 connection ，关联 fd connection *conn = connCreateSocket(); conn.fd = fd; // ... // 内部调用 aeApiAddEvent(fd,READABLE) // 监听 socket 的FD读事件，并绑定读处理器readQueryFromClient connSetReadHandler(conn, readQueryFromClient); } \",\"readQueryFromClient\",\"void readQueryFromClient(connection *conn){ // 获取当前客户端，客户端中有缓冲区用来读和写 client *c = connGetPrivateData(conn); // 获取c->querybuf缓冲区大小 long int qblen = sdslen(c->querybuf); // 读取请求数据到 c->querybuf 缓冲区 connRead(c->conn，c->Guerybuf+qblen，readlen); // 解析缓冲区字符串，转为Redis命令参数存入 c->argv 数组 processInputBuffer(c); // ... // 处理 c->argv 中的命令 processCommand(c); } \",\"processCommand\",\"int processCommand(client *c) { // 根据命令名称，寻找命令对应的command，例如 setCommand c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr); // ... // 执行command，得到响应结果，例如ping命令，对应pingCommand c->cmd->proc(c); // 把执行结果写出，例如ping命令，就返回\\\"pong\\\"给cLient // shared.pong是 字符串\\\"pong\\\"的SDS对象 addReply(c, shared.pong); } \",\"addReply\",\"void addReply(client *c，robj *obj) { // 尝试把结果写到 c-buf 客户端写缓存区 if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != C_OK) // 如果c->buf写不下，则写到 c->reply，这是一个链表，容量无上限 _addReplyProtoToList(c,obj->ptr,sdslen(obj->ptr)); // 将客户端添加到server.clients_pending_write这个队列，等待被写出 listAddNodeHead(server.clients_pending_ write,c); } \"]},\"463\":{\"h\":\"Redis原理 - RedisObject对象机制\"},\"464\":{\"h\":\"为什么会设计RedisObject\",\"t\":[\"在 Redis 中，我们的操作都是使用指令进行，而这些的命令中，用于对键处理的命令占据一大部分。有些指令只能针对某些特定的类型，而有些指令却能够针对所有的类型。但是要正确实现这些命令，必须为不同类型的键设置不同的处理方式。比如删除一个列表键和删除一个字符串键的操作过程是不一样的，在底层就需要调用不同的视线方式。\",\"集合类型有字典和整数集合两种不同的底层实现方式，而用户在对集合进行操作时，并不想关心具体的底层实现是什么样的，只要 Redis 能根据自己的指令，完成对应的功能即可，比如对元素进行添加、删除等操作，具体的实现底层对用户来说是透明的，不可见的。\",\"所以 Redis 必须让每个键都带有类型信息, 并且带有其底层的编码方式，拥有这两个信息时，Redis 才能够准确无误的实现用户的指令。那么 RedisObject 对象起码就应该包含3个属性，类型信息、编码方式、实际数据。\"]},\"465\":{\"h\":\"RedisObject\",\"t\":[\"Redis 中的任意数据类型的键和值都会被封装为一个 RedisObject，也叫做 Redis 对象，在/src/server.h文件中实现如下：\",\"typedef struct redisObject { unsigned type:4; unsigned encoding:4; // 共有 11 种编码方式，占据 4 个比特位 unsigned lru:LRU_BITS; /* LRU 表示该对象最后一次被访问的时间，其占用 24 个 bit 位， 便于判断空闲时间太久的key */ int refcount; // 对象引用计数器，计数器为 0 则说明对象无人引用，可以被回收。 void *ptr; // 指针，指向数据的真实存储空间地址。一般为 8 个字节 } robj; \"]},\"466\":{\"h\":\"编码方式\",\"t\":[\"Redis 中会根据存储的数据类型不同，选择不同的编码方式，共包含 11 种不同类型：\",\"编号\",\"编码方式\",\"说明\",\"1\",\"OBJ ENCODING RAW\",\"raw编码动态字符串\",\"2\",\"OBJ ENCODING INT\",\"Long类型的整数的字符串\",\"3\",\"OBJ_ENCODING_HT\",\"hash表(字典dict)\",\"4\",\"OBJ ENCODING ZIPMAP\",\"已废弃\",\"5\",\"OBJ_ENCODING_LINKEDLIST\",\"双端链表\",\"6\",\"OBJ ENCODING ZIPLIST\",\"压缩列表\",\"7\",\"OBJ_ENCODING INTSET\",\"整数集合\",\"8\",\"OBJ ENCODING SKIPLIST\",\"跳表\",\"9\",\"OBJ_ENCODING EMBSTR\",\"embstr的动态字符串\",\"10\",\"OBJ_ENCODING QUICKLIST\",\"快速列表\",\"11\",\"OBJENCODING STREAM\",\"Stream流\"]},\"467\":{\"h\":\"数据类型\",\"t\":[\"Redis 中根据存储的数据类型不同，选择不同的编码方式。每种数据类型使用的编码方式如下：\",\"数据类型\",\"编码方式\",\"编号\",\"说明\",\"OBJ_STRING\",\"int、embstr、raw\",\"0\",\"字符串\",\"OBJ_LIST\",\"LinkedList和ZipList(3.2以前)、QuickList(3.2以后)\",\"1\",\"列表\",\"OBJ_SET\",\"intset、HT\",\"2\",\"集合\",\"OBJ_ZSET\",\"ZipList、HT、SkipList\",\"3\",\"有序集\",\"OBJ_HASH\",\"ZipList、HT\",\"4\",\"哈希表\",\"注意\",\"这里只有 5 种基本类型，而没有提到 3 种特殊类型，是因为这三种特殊类型的底层是使用OBJ_STRING来实现的，并没有新的底层实现方式。\"]},\"468\":{\"h\":\"命令处理\",\"t\":[\"通过前面的描述，Redis 在执行命令时，需要判断所执行的数据类型和编码方式，则 Redis 执行一个处理数据类型命令的时候，Redis 执行以下步骤：\",\"根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL\",\"检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误\",\"根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构\",\"返回数据结构的操作结果作为命令的返回值\",\"比如现在执行LPOP命令：\"]},\"469\":{\"h\":\"对象共享\",\"t\":[\"Redis 一般会把一些常见的值放到一个共享对象中，这样可使程序避免了重复分配的麻烦，也节约了一些CPU时间。\",\"Redis预分配的值对象如下\",\"各种命令的返回值，比如成功时返回的OK，错误时返回的ERROR，命令入队事务时返回的QUEUE，等等\",\"包括0 在内，小于REDIS_SHARED_INTEGERS的所有整数（REDIS_SHARED_INTEGERS的默认值是10000）\",\"注意\",\"共享对象只能被字典和双向链表这类能带有指针的数据结构使用，只有指针才能够指向任意的地址。而整数集合和压缩列表这些只能保存字符串、整数等实际数据的类型，则无法共享。\",\"为什么redis不共享列表对象、哈希对象、集合对象、有序集合对象，只共享字符串对象？\",\"列表对象、哈希对象、集合对象、有序集合对象，本身可以包含字符串对象，复杂度较高。\",\"如果共享对象是保存字符串对象，那么验证操作的复杂度为O(1)\",\"如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)\",\"如果共享对象是包含多个值的对象，其中值本身又是字符串对象，即其它对象中嵌套了字符串对象，比如列表对象、哈希对象，那么验证操作的复杂度将会是O(N的平方)\",\"如果对复杂度较高的对象创建共享对象，需要消耗很大的CPU，用这种消耗去换取内存空间，是不合适的。并且对象的复杂度过高，说明对象的个性较大，共性较少，则使用到该对象的次数和频率都会很低。\"]},\"470\":{\"h\":\"引用计数器\",\"t\":[\"RedisObject 中有 refcount 属性，为对象引用计数器，用于记录对象引用数量。\",\"当计数器为 0 时，则代表该对象没有被引用，则就不会再被使用，那么说明该对象可以被删除销毁。\",\"当新创建一个对象时，它的refcount属性被设置为1。\",\"当对一个对象进行共享时，Redis 将这个对象的 refcount 加一。\",\"当使用完一个对象后，或者消除对一个对象的引用之后，程序将对象的refcount减一。\"]},\"471\":{\"h\":\"前端框架\"},\"472\":{\"h\":\"Java 基础知识\",\"t\":[\"待更新\"]},\"473\":{\"h\":\"ArrayList 源码解析\"},\"474\":{\"h\":\"Java 集合框架\"},\"475\":{\"h\":\"Java 面向对象\",\"t\":[\"待更新\"]},\"476\":{\"h\":\"15.三数之和\"},\"477\":{\"h\":\"题目描述\",\"t\":[\"给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请\",\"你返回所有和为 0 且不重复的三元组。\",\"注意：答案中不可以包含重复的三元组。\",\"示例 1：\",\"输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]]\",\"解释： nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。 nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。 nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。 注意，输出的顺序和三元组的顺序并不重要。 示例 2：\",\"输入：nums = [0,1,1] 输出：[] 解释：唯一可能的三元组和不为 0 。 示例 3：\",\"输入：nums = [0,0,0] 输出：[[0,0,0]] 解释：唯一可能的三元组和为 0 。\",\"提示：\",\"3 <= nums.length <= 3000 -105 <= nums[i] <= 105\"]},\"478\":{\"h\":\"题目地址\",\"t\":[\"Leetcode 15. 三数之和\"]},\"479\":{\"h\":\"解题思路\"},\"480\":{\"h\":\"1.暴力三循环\",\"t\":[\" 第一种方法也是我们能够快速想出来的方法，即使用三个指针i、j、k分别指向三个数，进行遍历，遍历完进行去重操作即可，这里不做过多赘述，主要以第二种方法为主。\"]},\"481\":{\"h\":\"2.固定指针+双循环指针\",\"t\":[\" 我们使用一个固定指针k，指向数组的开头，使其不断自增，小于nums.length - 2，这里需要小于 nums.length - 2，是因为需要保证其指针后最少有一个i指针和j指针的存在。 随后我们使i指针指向k指针的后面一个位置，j指针指向数组末尾。\",\" 判断sum = nums[k] + nums[i] + nums[j] 三者的和：\",\"sum == 0: 这时nums[k],nums[i],nums[j]三个数即为我们所求的三个数，将其插入返回链表中，并且使得i++和j--。\",\" 这里需要说明一下的是，对两个指针的操作是同时的，简单说一下原因： 在k不变的情况下，三者之和为0，那么当i++单独执行后，且不与之前的值重复，则更新后的三者必不可能为0，必大于0，此时则需要将 j--； 反之，若仅仅更新j--，则三者之和必小于0，则下一步必然是更新i++。 综上两种情况，无论我们怎么变化，都是需要同时变更两个指针，即该操作是需要将两者同时进行更新的，仅仅变更一个指针的话，在下一个循环内会变更另外一个指针，则会多循环一次。\",\"sum < 0: 三者之和 < 0，则说明值太小了，需要将小一点的数变大，仅有i++可以实现。\",\"sum > 0: 三者之和 > 0，则说明值太大了，需要将大一点的数变小，仅有j--可以实现。\"]},\"482\":{\"h\":\"代码示例\",\"t\":[\"class Solution { public List<List<Integer>> threeSum(int[] nums) { Arrays.sort(nums); List<List<Integer>> ret = new LinkedList<>(); // 这里让k < nums.length - 2 ，是保证k在i和j之前。 for (int k = 0; k < nums.length - 2; k++) { if (nums[k] > 0) { // 如果连最小的数都是 > 0 ，那么后面的数都是比他大的数，则相加之后必为一个 > 0 的数 break; } if (k > 0 && nums[k] == nums[k - 1]) { continue; } int i = k + 1; int j = nums.length - 1; while (i < j) { // nums[i] == nums[i - 1]时，直接跳过即可，因为结果和nums[i - 1]一致 if (i >= k + 2) { if (nums[i] == nums[i - 1]) { i++; continue; } } // nums[j] == nums[j + 1]时，直接跳过即可，因为结果和nums[j + 1]一致 if (j < nums.length -1) { if (nums[j] == nums[j + 1]) { j--; continue; } } // 判断三者之和是否为0 if (nums[k] + nums[i] + nums[j] == 0) { List<Integer> list = new LinkedList<>(); list.add(nums[k]); list.add(nums[i]); list.add(nums[j]); ret.add(list); // 这里将i和j都进行更新 i++; j--; } else if (nums[k] + nums[i] + nums[j] > 0) { j--; } else { i++; } } } return ret; } } \"]},\"483\":{\"h\":\"1646. 获取生成数组中的最大值\"},\"484\":{\"h\":\"题目介绍\",\"t\":[\"给你一个整数 n 。按下述规则生成一个长度为 n + 1 的数组 nums ：\",\"nums[0] = 0 nums[1] = 1 当 2 <= 2 * i <= n 时，nums[2 * i] = nums[i] 当 2 <= 2 * i + 1 <= n 时，nums[2 * i + 1] = nums[i] + nums[i + 1] 返回生成数组 nums 中的 最大 值。\"]},\"485\":{\"h\":\"题目地址\",\"t\":[\"1646. 获取生成数组中的最大值\"]},\"486\":{\"h\":\"解题思路\",\"t\":[\" 题目中已经给定了nums数组的两个初始值，并且给定了相关的递推公式，我们直接在一层for循环中进行模拟填数，直接将数组的数据填写。\"]},\"487\":{\"h\":\"代码\"},\"488\":{\"h\":\"方法1️⃣：模拟法\",\"t\":[\"public int getMaximumGenerated(int n) { if(n == 0){ return 0; } // 定义所需填充数组 int[] nums = new int[n + 1]; // 初始化默认值 nums[0] = 0; nums[1] = 1; // 记录最大值 int max = nums[0]; // 循环遍历 for (int i = 0;i <= n;i++){ if (2 <= 2 * i && 2 * i <= n){ nums[2 * i] = nums[i]; } if (2 <= 2 * i + 1 && 2 * i + 1 <= n){ nums[2 * i + 1] = nums[i] + nums[i + 1]; } max = Math.max(max,nums[i]); } return max; } \"]},\"489\":{\"h\":\"复杂度分析\",\"t\":[\"时间复杂度：O(n)\",\"空间复杂度：O(n)\"]},\"490\":{\"h\":\"455.分发饼干\"},\"491\":{\"h\":\"题目描述\",\"t\":[\"假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\",\"对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\",\"示例 1:\",\"输入: g = [1,2,3], s = [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。 示例 2:\",\"输入: g = [1,2], s = [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2\"]},\"492\":{\"h\":\"思路分析\",\"t\":[\"题目中的要求是尽可能满足更多的孩子，那么最好的情况就是使用最小的饼干，去尽可能的优先满足胃口较小的孩子。\",\"我们将饼干大小和孩子胃口进行排序。\",\"从最小的饼干开始，判断是否能满足目前尚未满足的胃口最小的孩子，如果可以，则使用该饼干，不能满足时，需要更换更大的饼干。\",\"这里也可以逆向思维，优先用最大的饼干满足胃口最大的孩子，道理是一样的，这里就不做过多赘述。\"]},\"493\":{\"h\":\"题目地址\",\"t\":[\"Leetcode 455.分发饼干\"]},\"494\":{\"h\":\"代码示例\",\"t\":[\"class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int i = 0; int j = 0; int ret = 0; while(i < g.length && j < s.length){ if (s[j] >= g[i]){ i++; ret++; } j++; } return ret; } } \"]},\"495\":{\"h\":\"509. 斐波那契数\"},\"496\":{\"h\":\"题目描述\",\"t\":[\"斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：\",\"F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给定 n ，请计算 F(n) 。\",\"示例 1：\",\"输入：n = 2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1\",\"示例 2： 输入：n = 3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2\",\"示例 3： 输入：n = 4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3\",\"提示： 0 <= n <= 30\"]},\"497\":{\"h\":\"题目地址\",\"t\":[\"LeetCode509. 斐波那契数\"]},\"498\":{\"h\":\"解题思路\",\"t\":[\"在解题之前，我们需要了解什么是斐波那契数列 👉 点我查看\",\"由定义可知，从第三个数开始，其值为前两个数值之和，即F(n) = F(n - 1) + F(n - 2)。并且给定了F(0)和F(1)的初始值，那么我们可以进行分解。\",\"要求F(n) 则需要先求F(n - 1) 和 F(n - 2);\",\"要求F(n - 1) 则需要先求F(n - 1 - 1) 和 F(n - 1 - 2);\",\"...以此类推\",\"要求F(2) 则需要先求F(1) 和 F(0);\",\"此时的F(1) 和 F(0)都是已知条件，则可以求的结果。\"]},\"499\":{\"h\":\"方法1️⃣：递归法\"},\"500\":{\"h\":\"代码Code\",\"t\":[\"// 递归法 public int fib(int n) { // 退出递归的条件 if (n < 2) { return n; } return fib(n - 1) + fib(n - 2); } \"]},\"501\":{\"h\":\"复杂度分析\",\"t\":[\"时间复杂度：O(2 ^ n)。\",\"空间复杂度：O(n)。\"]},\"502\":{\"h\":\"方法2️⃣：动态规划法1：（使用dp数组进行记录）\"},\"503\":{\"h\":\"代码Code\",\"t\":[\"// 动态规划法1：（使用dp数组进行记录） public int fib(int n) { if (n < 2) { return n; } // dp[i] 记录的是 第 i 个斐波那契数 int[] dp = new int[n + 1]; // 数组初始化： dp[0] = 0;dp[1] = 1; dp[0] = 0; dp[1] = 1; // 确定遍历顺序 ： n 从小到大遍历 for (int i = 2; i < dp.length; i++) { // 递推公式 ： dp[i] = dp[i - 1] + dp[i - 2] dp[i] = dp[i - 1] + dp[i - 2]; } // 举例推导dp数组 // 0 1 1 2 3 5 8 13 21 return dp[n]; } \"]},\"504\":{\"h\":\"复杂度分析\",\"t\":[\"时间复杂度：O(n)。\",\"空间复杂度：O(n)。\"]},\"505\":{\"h\":\"方法3️⃣：动态规划法2：（使用dp数组进行记录）\"},\"506\":{\"h\":\"代码Code\",\"t\":[\"// 动态规划法2：仅维护两个需要递推的数值，不需要记录整个dp数组（优化） public int fib(int n) { if (n < 2) { return n; } // 定义 dp 数组 int[] dp = new int[2]; // dp 数组的初始化 // dp[0] = 0; int 数组初始化会将所有的元素默认初始化为 0 dp[1] = 1; // 循环 n - 1 次即可得到第 n 个斐波那契数 for (int i = 0; i < n - 1; i++) { int num = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = num; } return dp[1]; } \"]},\"507\":{\"h\":\"复杂度分析\",\"t\":[\"时间复杂度：O(n)。\",\"空间复杂度：O(1)。\"]},\"508\":{\"h\":\"62.不同路径\"},\"509\":{\"h\":\"题目描述\",\"t\":[\"一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\",\"机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\",\"问总共有多少条不同的路径？\",\"示例 1：\",\"输入：m = 3, n = 7 输出：28 示例 2：\",\"输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。\",\"向右 -> 向下 -> 向下\",\"向下 -> 向下 -> 向右\",\"向下 -> 向右 -> 向下 示例 3：\",\"输入：m = 7, n = 3 输出：28 示例 4：\",\"输入：m = 3, n = 3 输出：6\",\"提示：\",\"1 <= m, n <= 100 题目数据保证答案小于等于 2 * 109\"]},\"510\":{\"h\":\"题目地址\",\"t\":[\"Leetcode 62. 不同路径\"]},\"511\":{\"h\":\"思路解析\",\"t\":[\"首先从题目中可知，机器人仅能向右或者向下移动一个单位，则可以推断到达任何一的网格之中仅有两种方式。 \",\"从上边网格向下移动\",\"从左边网格向右移动\",\"对于所有的网格就只有这两种方式到达，但有的网格只有这两种方式的其中一个，故此需要判断边界条件。 \",\"当走到第一行时，仅能从左边网格向右移动。\",\"当走到第一列时，仅能从上边网格向下移动。\",\"其他网格，既能从上边网格向下移动，又能从左边网格向右移动。\",\"所有网格我们分成了3个类型，当计算移动到一个网格的路径时需要依赖到达上边网格的路径数 ，到达左边网格的路径数这两个数值。\",\"递推公式为：到达当前网格的路径数 = 到达上边网格的路径数 + 到达左边网格的路径数\",\"故此我们从 [0][0] 位置开始循环，可以按行S形遍历，也可以按列S型遍历，注意边界控制即可。\"]},\"512\":{\"h\":\"代码示例\",\"t\":[\"class Solution { public int uniquePaths(int m, int n) { int[][] grid = new int[m][n]; int i = 0; int j = 0; grid[0][0] = 1; while(i < m && j < n){ int left = 0; int up = 0; // 此时必然有上和左 if (i != 0 && j != 0){ left = grid[i][j - 1]; up = grid[i - 1][j]; } // 此时仅有上 if (i != 0 && j == 0){ up = grid[i - 1][j]; } // 此时仅有左 if (i == 0 && j != 0){ left = grid[i][j - 1]; } grid[i][j] = left + up + grid[i][j]; j++; if (j % n == 0){ j = 0; i ++; } } return grid[m -1][n -1]; } } \"]},\"513\":{\"h\":\"6322.检查骑士巡视方案\"},\"514\":{\"h\":\"题目描述\",\"t\":[\"骑士在一张 n x n 的棋盘上巡视。在有效的巡视方案中，骑士会从棋盘的 左上角 出发，并且访问棋盘上的每个格子 恰好一次 。\",\"给你一个 n x n 的整数矩阵 grid ，由范围 [0, n * n - 1] 内的不同整数组成，其中 grid[row][col] 表示单元格 (row, col) 是骑士访问的第 grid[row][col] 个单元格。骑士的行动是从下标 0 开始的。\",\"如果 grid 表示了骑士的有效巡视方案，返回 true；否则返回 false。\",\"注意，骑士行动时可以垂直移动两个格子且水平移动一个格子，或水平移动两个格子且垂直移动一个格子。下图展示了骑士从某个格子出发可能的八种行动路线。\",\"示例 1：\",\"输入：grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]] 输出：true 解释：grid 如上图所示，可以证明这是一个有效的巡视方案。 示例 2：\",\"输入：grid = [[0,3,6],[5,8,1],[2,7,4]] 输出：false 解释：grid 如上图所示，考虑到骑士第 7 次行动后的位置，第 8 次行动是无效的。\",\"提示：\",\"n == grid.length == grid[i].length 3 <= n <= 7 0 <= grid[row][col] < n * n grid 中的所有整数 互不相同\"]},\"515\":{\"h\":\"题目地址\",\"t\":[\"Leetcode 6322. 检查骑士巡视方案\"]},\"516\":{\"h\":\"思路分析\",\"t\":[\"首先要求骑士必须从下标0开始行动，这里需要判断 grid[0][0] == 0，这种情况，我自己在做的时候就忘记了这种情况，导致一个测试用例过不去，很难受。\",\"通过骑士的站位，判断其8个点位中合法点位的值，是否和现在所占据的点位的值是否差1，即判断 grid[i][j] + 1 == 可能的8个点位的值。如果有，则说明可以跳到下一个位置，循环进行，8个点位都没有，则直接跳出循环，即无法巡视完棋盘，返回false。\",\"当点位的值+1，是否和棋盘的长乘宽相等，即 grid[i][j] + 1 == gird.length * grid[0].length ，如果想等则已经巡视完全程，否则会回到步骤二，再进行判断。\"]},\"517\":{\"h\":\"代码示例\",\"t\":[\"public class Solution { public boolean checkValidGrid(int[][] grid) { if (grid[0][0] != 0) { return false; } int[] ret = checkArri(0, 0, grid); while (ret != null) { ret = checkArri(ret[0], ret[1], grid); if (ret == null) { return false; } if (grid[ret[0]][ret[1]] + 1 == grid.length * grid[0].length) { return true; } } return false; } public int[] checkArri(int i, int j, int[][] grid) { int len_i = grid.length; int len_j = grid[0].length; if (i - 1 >= 0 && i - 1 < len_i && j - 2 >= 0 && j - 2 < len_j) { if (grid[i - 1][j - 2] == grid[i][j] + 1) { return new int[]{i - 1, j - 2}; } } if (i - 1 >= 0 && i - 1 < len_i && j + 2 >= 0 && j + 2 < len_j) { if (grid[i - 1][j + 2] == grid[i][j] + 1) { return new int[]{i - 1, j + 2}; } } if (i + 1 >= 0 && i + 1 < len_i && j - 2 >= 0 && j - 2 < len_j) { if (grid[i + 1][j - 2] == grid[i][j] + 1) { return new int[]{i + 1, j - 2}; } } if (i + 1 >= 0 && i + 1 < len_i && j + 2 >= 0 && j + 2 < len_j) { if (grid[i + 1][j + 2] == grid[i][j] + 1) { return new int[]{i + 1, j + 2}; } } if (i - 2 >= 0 && i - 2 < len_i && j - 1 >= 0 && j - 1 < len_j) { if (grid[i - 2][j - 1] == grid[i][j] + 1) { return new int[]{i - 2, j - 1}; } } if (i - 2 >= 0 && i - 2 < len_i && j + 1 >= 0 && j + 1 < len_j) { if (grid[i - 2][j + 1] == grid[i][j] + 1) { return new int[]{i - 2, j + 1}; } } if (i + 2 >= 0 && i + 2 < len_i && j - 1 >= 0 && j - 1 < len_j) { if (grid[i + 2][j - 1] == grid[i][j] + 1) { return new int[]{i + 2, j - 1}; } } if (i + 2 >= 0 && i + 2 < len_i && j + 1 >= 0 && j + 1 < len_j) { if (grid[i + 2][j + 1] == grid[i][j] + 1) { return new int[]{i + 2, j + 1}; } } return null; } } \"]},\"518\":{\"h\":\"70. 爬楼梯\"},\"519\":{\"h\":\"题目描述\",\"t\":[\"假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\",\"每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\",\"示例 1：\",\"输入：n = 2 输出：2 解释：有两种方法可以爬到楼顶。\",\"1 阶 + 1 阶\",\"2 阶 示例 2：\",\"输入：n = 3 输出：3 解释：有三种方法可以爬到楼顶。\",\"1 阶 + 1 阶 + 1 阶\",\"1 阶 + 2 阶\",\"2 阶 + 1 阶\",\"提示：\",\"1 <= n <= 45\"]},\"520\":{\"h\":\"题目地址\",\"t\":[\"Leetcode 70.爬楼梯\"]},\"521\":{\"h\":\"解题思路\",\"t\":[\" 爬到第⼀层楼梯有⼀种⽅法，爬到⼆层楼梯有两种⽅法。 那么第⼀层楼梯再跨两步就到第三层 ，第⼆层楼梯再跨⼀步就到第三层。 所以到第三层楼梯的状态可以由第⼆层楼梯 和 到第⼀层楼梯状态推导出来，那么就可以想到动态规划了。\",\"爬上 n-1 阶楼梯的方法数量。因为再爬1阶就能到第n阶\",\"爬上 n−2 阶楼梯的方法数量，因为再爬2阶就能到第n阶\",\" 要求F(n) 则需要先求F(n - 1) 和 F(n - 2);\",\" 要求F(n - 1) 则需要先求F(n - 1 - 1) 和 F(n - 1 - 2);\",\" ...以此类推\",\" 要求F(3) 则需要先求F(2) 和 F(1);\",\" 此时的F(2) 和 F(1)都是已知条件，则可以求的结果。\"]},\"522\":{\"h\":\"方法1️⃣：递归法\"},\"523\":{\"h\":\"代码Code\",\"t\":[\"// 递归法 public int climbStairs(int n) { if (n < 3) { return n; } return climbStairs(n - 1) + climbStairs(n - 2); } \"]},\"524\":{\"h\":\"复杂度分析\",\"t\":[\"时间复杂度：O(2 ^ n)。\",\"空间复杂度：O(n)。\"]},\"525\":{\"h\":\"方法2️⃣：动态规划法1：（使用dp数组进行记录）\"},\"526\":{\"h\":\"代码Code\",\"t\":[\"// 动态规划法1： public int climbStairs(int n) { if (n < 2) { return n; } // 定义 dp 数组 int[] dp = new int[n + 1]; // 初始化 dp 数组中的初始值 dp[1] = 1; dp[2] = 2; // 开始循环遍历 for (int i = 3; i < dp.length; i++) { // 递推公式 dp[i] = dp[i - 1] + dp[i - 2]; } // 得到返回值 return dp[n]; } \"]},\"527\":{\"h\":\"复杂度分析\",\"t\":[\"时间复杂度：O(n)。\",\"空间复杂度：O(n)。\"]},\"528\":{\"h\":\"方法3️⃣：动态规划法2：（使用dp数组进行记录）\"},\"529\":{\"h\":\"代码Code\",\"t\":[\"// 动态规划法2：仅保存需要进行递推的两个值 public int climbStairs2(int n) { if (n < 3) { return n; } // 定义 dp 数组 int[] dp = new int[2]; // 初始化 dp 数组中的初始值 dp[0] = 1; dp[1] = 2; // 开始循环遍历 // 循环 1 次 得到第 3 个值 // 循环 n - 2 次 得到第 n 个值 for (int i = 0; i < n - 2; i++) { int num = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = num; } // 得到返回值 return dp[1]; } \"]},\"530\":{\"h\":\"复杂度分析\",\"t\":[\"时间复杂度：O(n)。\",\"空间复杂度：O(1)。\"]},\"531\":{\"h\":\"746. 使用最小花费爬楼梯\"},\"532\":{\"h\":\"题目描述\",\"t\":[\"给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\",\"你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。\",\"请你计算并返回达到楼梯顶部的最低花费。\",\"示例 1：\",\"输入：cost = [10,15,20] 输出：15 解释：你将从下标为 1 的台阶开始。\",\"支付 15 ，向上爬两个台阶，到达楼梯顶部。 总花费为 15 。 示例 2：\",\"输入：cost = [1,100,1,1,1,100,1,1,100,1] 输出：6 解释：你将从下标为 0 的台阶开始。\",\"支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。\",\"支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。\",\"支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。\",\"支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。\",\"支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。\",\"支付 1 ，向上爬一个台阶，到达楼梯顶部。 总花费为 6 。\",\"提示：\",\"2 <= cost.length <= 1000 0 <= cost[i] <= 999\"]},\"533\":{\"h\":\"题目地址\",\"t\":[\"Leetcode 746. 使用最小花费爬楼梯\"]},\"534\":{\"h\":\"解题思路\",\"t\":[\" 由题目可得，我们需要得到到达楼梯顶部的时候，所需要支付的最小体力花费。我们在支付完对应的花费后，可以选择向上两个台阶或者一个台阶。\",\" 此时的最优解即这两个台阶中的一个最小值，此时到达该阶梯的最小花费即为上一步的最小花费加上此步骤的最优解即最小花费。\",\" 递推公式有两种：\",\"dp[i] = Math.min(dp[i - 1],dp[i - 2]) + cost[i];\",\"dp[i] = Math.min(dp[i - 1] + cost[i - 1],dp[i - 2] + cost[i - 2]);\",\" 在递推公式中，我们需要知道dp[i - 1] 和 dp[i - 2]两个的数值，即该阶梯前两个阶梯的最小花费。 即此时 i 最小等于 2 ，那么就需要进行第一个和第二个阶梯的初始化。 dp[0] = cost[0];\",\" dp[1] = cost[1];\",\" dp[2] = Math.min(dp[0],dp[1]) + cost[2];\",\" ......\",\" dp[i - 1] = Math.min(dp[i - 2],dp[i - 3]) + cost[i - 1];\",\" dp[i] = Math.min(dp[i - 1],dp[i - 2]) + cost[i];\",\"注意\",\"需要注意的是：此时的dp[dp.length - 1]即dp数组的最后一个数并不一定是最小的花费，因为我们一次可以跨一个台阶或者两个台阶，即最小值为Math.min(dp[dp.length - 1], dp[dp.length - 2])\"]},\"535\":{\"h\":\"代码实现\"},\"536\":{\"h\":\"方法1：动态规划\",\"t\":[\"// 动态规划法1：使用dp数组记录每一步所需要花费的最小体力 public int minCostClimbingStairs(int[] cost) { if (cost.length == 1) { return cost[0]; } // 定义 dp 数组 int[] dp = new int[cost.length]; // 初始化 dp 数组 dp[0] = cost[0]; dp[1] = cost[1]; // 递推公式 ： dp[i] = Math.min(dp[i - 1],dp[i - 2]) + cost[i]; // dp[i] : 到达第 i 个阶梯所的最小花费 for (int i = 2; i < dp.length; i++) { dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]; } return Math.min(dp[dp.length - 1], dp[dp.length - 2]); } \"]},\"537\":{\"h\":\"复杂度分析：\",\"t\":[\"时间复杂度：O(n)\",\"空间复杂度：O(n)\"]},\"538\":{\"h\":\"方法2：动态规划(优化版)\",\"t\":[\"// 动态规划法2：将dp数组进行优化 public int minCostClimbingStairs2(int[] cost) { if (cost.length == 1) { return cost[0]; } // 定义 dp 数组 int[] dp = new int[2]; // 初始化 dp 数组 dp[0] = cost[0]; dp[1] = cost[1]; // 递推公式 ： dp[1] = Math.min(num,dp[0]) + cost[i]; // dp[i] : 到达第 i 个阶梯所的最小花费 for (int i = 2; i < cost.length; i++) { int num = dp[0]; dp[0] = dp[1]; dp[1] = Math.min(num, dp[0]) + cost[i]; } return Math.min(dp[0], dp[1]); } \"]},\"539\":{\"h\":\"复杂度分析：\",\"t\":[\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"540\":{\"h\":\"88.合并两个有序数组\"},\"541\":{\"h\":\"题目介绍\",\"t\":[\"给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\",\"请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\",\"注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\",\"示例 1：\",\"输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2：\",\"输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 解释：需要合并 [1] 和 [] 。 合并结果是 [1] 。 示例 3：\",\"输入：nums1 = [0], m = 0, nums2 = [1], n = 1 输出：[1] 解释：需要合并的数组是 [] 和 [1] 。 合并结果是 [1] 。 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。\",\"提示：\",\"nums1.length == m + n nums2.length == n 0 <= m, n <= 200 1 <= m + n <= 200 -109 <= nums1[i], nums2[j] <= 109\",\"进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？\"]},\"542\":{\"h\":\"题目地址\",\"t\":[\"https://leetcode.cn/problems/merge-sorted-array\"]},\"543\":{\"h\":\"题解\",\"t\":[\"解法1：合并后排序\",\"class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { for(int i = m;i<nums1.length;i++){ nums1[i] = nums2[i - m]; } Arrays.sort(nums1); } } \",\"解法2：正向双指针\",\"class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int i = 0; int j = 0; int[] arr = new int[m + n]; int index = 0; while (i < m || j < n){ if (i == m){ arr[index] = nums2[j]; j ++; index ++; continue; } if(j == n){ arr[index] = nums1[i]; i ++; index ++; continue; } if (nums1[i] < nums2[j]){ arr[index] = nums1[i]; i ++; index ++; }else { arr[index] = nums2[j]; j ++; index ++; } } for (int k = 0; k < nums1.length; k++) { nums1[k] = arr[k]; } } } \",\"解法3：逆向双指针\",\"class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int i = m - 1; int j = n - 1; int index = m + n - 1; while (i >= 0 || j >= 0) { if (i < 0){ nums1[index] = nums2[j]; index --; j --; continue; } if (j < 0){ nums1[index] = nums1[i]; index --; i --; continue; } if (nums1[i] > nums2[j]){ nums1[index] = nums1[i]; index --; i --; }else { nums1[index] = nums2[j]; index --; j --; } } } } \"]},\"544\":{\"h\":\"Leetcode 题解\"},\"545\":{\"h\":\"Spring\"},\"546\":{\"h\":\"参考资料\",\"t\":[\"尚硅谷Spring6视频教程\",\"视频地址\",\"https://www.bilibili.com/video/BV1kR4y1b7Qc\",\"笔记资料\",\"百度网盘\",\"链接: https://pan.baidu.com/s/1OXIMGcfgFg34mkMuVX19ow?pwd=45nc\\n提取码: 45nc\"]},\"547\":{\"h\":\"SpringBoot 全栈指南\"},\"548\":{\"h\":\"章节分布\",\"t\":[\"SpringBoot3 核心特性\",\"SpringBoot3 场景实战\",\"响应式编程全套\"]},\"549\":{\"h\":\"参考资料\",\"t\":[\"视频资料 : 尚硅谷SpringBoot3零基础教程，springboot入门到实战\",\"笔记资料 : https://www.yuque.com/leifengyang/springboot3/\",\"代码仓库 : https://gitee.com/leifengyang/spring-boot-3/\"]},\"550\":{\"h\":\"Stata 分析工具\"},\"551\":{\"h\":\"Stata 常见指令\"},\"552\":{\"h\":\"1.输入数据\",\"t\":[\"input x y ... ... ... end \"]},\"553\":{\"h\":\"回归命令\",\"t\":[\"线性OLS回归 reg\",\"regress y x1 x2 \"]},\"554\":{\"h\":\"第六章 应用层\"},\"555\":{\"h\":\"第一章 计算机网络体系结构\"},\"556\":{\"h\":\"2 计算机网络的分类\"},\"557\":{\"h\":\"2.1 按分布范围分类\",\"t\":[\"广域网（WAN） 广域网的任务时容果\",\"城域网（MAN）\",\"局域网（LAN）\",\"个人区域网（PAN）\",\"注意\",\"若中央处理器之间的距离非常近（如仅1m的数量级或甚至更小），则一般称为多处理器系统，而不称为计算机网络。\"]},\"558\":{\"h\":\"2.2 按传输技术分类\"},\"559\":{\"h\":\"2.3 按拓扑结构分类\"},\"560\":{\"h\":\"2.4 按使用者分类\"},\"561\":{\"h\":\"2.5 按交换技术分类\"},\"562\":{\"h\":\"2.6 按传输介质分类\"},\"563\":{\"h\":\"1 计算机网络的概念、组成和功能\"},\"564\":{\"h\":\"1.1 计算机网络的概念\",\"t\":[\"一般认为，计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。\"]},\"565\":{\"h\":\"1.1.1 广义观点\",\"t\":[\"只要是能实现远程信息处理的系统或者能进一步达到资源共享的系统，都是计算机网络。\"]},\"566\":{\"h\":\"1.1.2 资源共享观点\",\"t\":[\"计算机网络是“以能够相互共享资源的方式互联起来的自治计算机系统的集合”。\",\"1. 目的——资源共享 2. 组成单元——分布在不同地理位置的多台独立的“自治计算机” 3. 网络中的计算机必须遵循的统一规则——网络协议 \"]},\"567\":{\"h\":\"1.1.3 用户透明性观点\",\"t\":[\"存在一个能为用户自动管理资源的网络操作系统，它能够调用用户所需要的资源，而整个网络就像一个大的计算机系统一样对用户是透明的，即用户不可见的。用户使用网络就像使用一台单一的超级计算机，无需了解网络的存在、资源的位置信息。\"]},\"568\":{\"h\":\"1.2 计算机网络的组成\"},\"569\":{\"h\":\"1.2.1 从组成部分上看\",\"t\":[\"从组成部分上看，一个完整的计算机网络主要由硬件、软件、协议三大部分组成，缺一不可。\",\"硬件主要由主机（也称端系统）、通信链路（如双绞线、光纤）、交换设备（如路由器、交换机等）和通信处理机（如网卡）等组成。\",\"软件主要由各种实现资源共享的软件和方便用户使用的各种工具软件（如操作系统、邮件收发程序、FTP程序、聊天程序等）。软件部分多属于应用层。\",\"协议是计算机网络的核心，如同交通规则制约汽车驾驶一样，协议规定了网络传输数据时所遵循的规范。\"]},\"570\":{\"h\":\"1.2.2 从工作方式上看\",\"t\":[\"从工作方式上看，计算机网络可以分为边缘部分和核心部分。\",\"边缘部分由所有连接到因特网上、供用户直接使用的主机组成，用来进行通信和资源共享；\",\"核心部分由大量的网络和连接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。\",\"边缘部分和核心部分\"]},\"571\":{\"h\":\"1.2.3 从功能组成上看\",\"t\":[\"从功能组成上看，计算机网络可以分为通信子网和资源子网。\",\"通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和储存的能力，实现联网计算机之间的数据通信。\",\"资源子网是实现资源共享功能的设备及其软件的集合，向网络用户提供共享其他计算机上的硬件资源、软件资源和数据资源的服务。\"]},\"572\":{\"h\":\"1.3 计算机网络的功能\"},\"573\":{\"h\":\"1.3.1 数据通信\",\"t\":[\"它是计算机网络最基本和最重要的功能用来实现联网计算机之间各种信息的传输，并将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理。\",\"例如\",\"例如：文件传输、电子邮件等应用。\"]},\"574\":{\"h\":\"1.3.2 资源共享\",\"t\":[\"资源共享可以是软件共享、数据共享，也可以是硬件共享。\",\"它使计算机网络中的资源互通有无、分工协作，从而极大地提高硬件资源、软件资源、数据资源的利用率。\"]},\"575\":{\"h\":\"1.3.3 分布式处理\",\"t\":[\"当计算机网络中的某个计算机系统负荷过重时，可以将其处理的某个复杂任务分配给网络中的其他计算机系统，从而利用空闲计算机资源以提高整个系统的利用率。\"]},\"576\":{\"h\":\"1.3.4 提高可靠性\",\"t\":[\"计算机网络中的各台计算机可以通过网络互为替代机。\"]},\"577\":{\"h\":\"1.3.5 负载均衡\",\"t\":[\"将工作任务均衡地分配给计算机网络中的各台计算机。\",\"除此以外\",\"除以上的几大主要功能外，计算机网络还可以实现电子化办公与服务、远程教育、娱乐等功能，满足了社会的需要，方便了人们学习、工作和生活，具有巨大的经济效益。\"]},\"578\":{\"h\":\"第三章 数据链路层\"},\"579\":{\"h\":\"第四章 网络层\"},\"580\":{\"h\":\"第二章 物理层\"},\"581\":{\"h\":\"第五章 传输层\"},\"582\":{\"h\":\"Vue3 框架\"},\"583\":{\"h\":\"Computer\"}},\"dirtCount\":0,\"index\":[[\"框架\",{\"0\":{\"582\":1}}],[\"框架中\",{\"1\":{\"360\":1}}],[\"传输层\",{\"0\":{\"581\":1}}],[\"传统的缓存策略一般是请求到达\",{\"1\":{\"279\":1}}],[\"传统缓存的问题\",{\"1\":{\"279\":1}}],[\"物理层\",{\"0\":{\"580\":1}}],[\"娱乐等功能\",{\"1\":{\"577\":1}}],[\"远程教育\",{\"1\":{\"577\":1}}],[\"远程字典服务器\",{\"1\":{\"365\":1}}],[\"除以上的几大主要功能外\",{\"1\":{\"577\":1}}],[\"除此以外\",{\"1\":{\"577\":1}}],[\"除了控制\",{\"1\":{\"448\":1}}],[\"除了扩容以外\",{\"1\":{\"437\":1}}],[\"除了链地址法解决哈希冲突以外\",{\"1\":{\"435\":1}}],[\"除了保存数据库中的字符串值以外\",{\"1\":{\"428\":1}}],[\"除了上述安装方式以外还有很多安装方式\",{\"1\":{\"366\":1}}],[\"除了参考视频教程外\",{\"1\":{\"171\":1}}],[\"除了传统的计算机资源\",{\"1\":{\"136\":1}}],[\"电子邮件等应用\",{\"1\":{\"573\":1}}],[\"边缘部分和核心部分\",{\"1\":{\"570\":1}}],[\"边缘部分由所有连接到因特网上\",{\"1\":{\"570\":1}}],[\"供用户直接使用的主机组成\",{\"1\":{\"570\":1}}],[\"聊天程序等\",{\"1\":{\"569\":1}}],[\"邮件收发程序\",{\"1\":{\"569\":1}}],[\"交换\",{\"1\":{\"571\":1}}],[\"交换机等\",{\"1\":{\"569\":1}}],[\"交换设备\",{\"1\":{\"569\":1}}],[\"交集\",{\"1\":{\"379\":1,\"380\":1,\"397\":1}}],[\"光纤\",{\"1\":{\"569\":1}}],[\"硬件主要由主机\",{\"1\":{\"569\":1}}],[\"硬件设备等\",{\"1\":{\"404\":1}}],[\"软件资源\",{\"1\":{\"574\":1}}],[\"软件资源和数据资源的服务\",{\"1\":{\"571\":1}}],[\"软件部分多属于应用层\",{\"1\":{\"569\":1}}],[\"软件主要由各种实现资源共享的软件和方便用户使用的各种工具软件\",{\"1\":{\"569\":1}}],[\"软件\",{\"1\":{\"569\":1}}],[\"软件工程\",{\"1\":{\"130\":3}}],[\"广义观点\",{\"0\":{\"565\":1}}],[\"广域网的任务时容果\",{\"1\":{\"557\":1}}],[\"广域网\",{\"1\":{\"557\":1}}],[\"组成单元\",{\"1\":{\"566\":1}}],[\"组成和功能\",{\"0\":{\"563\":1}}],[\"组名\",{\"1\":{\"393\":1}}],[\"局域网\",{\"1\":{\"557\":1}}],[\"局部变量的范围是在其内声明的begin\",{\"1\":{\"244\":1}}],[\"局部变量是根据需要定义的在局部生效的变量\",{\"1\":{\"244\":1}}],[\"局部变量\",{\"0\":{\"244\":1}}],[\"城域网\",{\"1\":{\"557\":1}}],[\"尚硅谷springboot3零基础教程\",{\"1\":{\"549\":1}}],[\"尚硅谷spring6视频教程\",{\"1\":{\"546\":1}}],[\"章节分布\",{\"0\":{\"548\":1}}],[\"百度网盘\",{\"1\":{\"546\":1}}],[\"百度百科\",{\"1\":{\"421\":1}}],[\"笔记资料\",{\"1\":{\"546\":1,\"549\":1}}],[\"笔者的电脑系统为macos\",{\"1\":{\"373\":1}}],[\"逆向双指针\",{\"1\":{\"543\":1}}],[\"逆向建立单链表\",{\"1\":{\"37\":1}}],[\"支付\",{\"1\":{\"532\":7}}],[\"支持动态扩容\",{\"1\":{\"427\":1}}],[\"支持交集\",{\"1\":{\"379\":1}}],[\"支持多语言客户端\",{\"1\":{\"365\":1}}],[\"支持主从集群\",{\"1\":{\"365\":1}}],[\"支持数据持久化\",{\"1\":{\"365\":1}}],[\"支持基于\",{\"1\":{\"358\":3}}],[\"支持三种不同模式\",{\"1\":{\"345\":1}}],[\"支持的各种\",{\"1\":{\"304\":1}}],[\"支持外键\",{\"1\":{\"236\":1}}],[\"支持外键foreign\",{\"1\":{\"234\":1}}],[\"支持\",{\"1\":{\"236\":8,\"358\":2}}],[\"支持hash索引\",{\"1\":{\"236\":1}}],[\"支持hash索引的是memory引擎\",{\"1\":{\"121\":1}}],[\"支持表锁\",{\"1\":{\"235\":1}}],[\"支持事务\",{\"1\":{\"234\":1,\"237\":1}}],[\"爬上\",{\"1\":{\"521\":2}}],[\"爬到⼆层楼梯有两种⽅法\",{\"1\":{\"521\":1}}],[\"爬到第⼀层楼梯有⼀种⽅法\",{\"1\":{\"521\":1}}],[\"爬楼梯\",{\"0\":{\"518\":1},\"1\":{\"520\":1}}],[\"阶楼梯的方法数量\",{\"1\":{\"521\":2}}],[\"阶\",{\"1\":{\"519\":10}}],[\"阶你才能到达楼顶\",{\"1\":{\"519\":1}}],[\"互不相同\",{\"1\":{\"514\":1}}],[\"互斥锁\",{\"1\":{\"272\":2}}],[\"互斥\",{\"1\":{\"145\":1}}],[\"考虑到骑士第\",{\"1\":{\"514\":1}}],[\"考虑针对于查询字段建立索引时\",{\"1\":{\"133\":1}}],[\"出发\",{\"1\":{\"514\":1}}],[\"出现这种现象的原因是什么呢\",{\"1\":{\"352\":1}}],[\"出现范围查\",{\"1\":{\"129\":1}}],[\"骑士行动时可以垂直移动两个格子且水平移动一个格子\",{\"1\":{\"514\":1}}],[\"骑士的行动是从下标\",{\"1\":{\"514\":1}}],[\"骑士会从棋盘的\",{\"1\":{\"514\":1}}],[\"骑士在一张\",{\"1\":{\"514\":1}}],[\"条路径可以到达右下角\",{\"1\":{\"509\":1}}],[\"条件处理程序handler可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤\",{\"1\":{\"253\":1}}],[\"条件处理程序\",{\"0\":{\"253\":1}}],[\"条件2\",{\"1\":{\"245\":1}}],[\"条件1\",{\"1\":{\"245\":1}}],[\"条件查询\",{\"0\":{\"187\":1},\"1\":{\"185\":1}}],[\"条件\",{\"0\":{\"290\":1},\"1\":{\"181\":1,\"182\":1,\"187\":1,\"249\":1}}],[\"条件列表\",{\"1\":{\"94\":1,\"96\":1,\"184\":1,\"187\":1,\"190\":1,\"193\":1,\"229\":1}}],[\"条件约束\",{\"1\":{\"47\":1}}],[\"问总共有多少条不同的路径\",{\"1\":{\"509\":1}}],[\"问题\",{\"1\":{\"258\":1,\"272\":1}}],[\"机器人仅能向右或者向下移动一个单位\",{\"1\":{\"511\":1}}],[\"机器人试图达到网格的右下角\",{\"1\":{\"509\":1}}],[\"机器人每次只能向下或者向右移动一步\",{\"1\":{\"509\":1}}],[\"机制来实现主从集群的自动故障恢复\",{\"1\":{\"324\":1}}],[\"起始点在下图中标记为\",{\"1\":{\"509\":1}}],[\"起始索引可以省略\",{\"1\":{\"192\":1}}],[\"起始索引从0开始\",{\"1\":{\"192\":1}}],[\"起始索引\",{\"1\":{\"192\":2}}],[\"网格的左上角\",{\"1\":{\"509\":1}}],[\"网络层\",{\"0\":{\"579\":1}}],[\"网络协议\",{\"1\":{\"566\":1}}],[\"网络中的计算机必须遵循的统一规则\",{\"1\":{\"566\":1}}],[\"网络请求\",{\"1\":{\"461\":1}}],[\"网络模型\",{\"0\":{\"459\":1}}],[\"网络上的资源也很多\",{\"1\":{\"373\":1}}],[\"递推公式有两种\",{\"1\":{\"534\":1}}],[\"递推公式为\",{\"1\":{\"511\":1}}],[\"递推公式\",{\"1\":{\"503\":1,\"526\":1,\"536\":1,\"538\":1}}],[\"递归法\",{\"0\":{\"499\":1,\"522\":1},\"1\":{\"500\":1,\"523\":1}}],[\"动态规划\",{\"0\":{\"536\":1,\"538\":1}}],[\"动态规划法2\",{\"0\":{\"505\":1,\"528\":1},\"1\":{\"506\":1,\"529\":1,\"538\":1}}],[\"动态规划法1\",{\"0\":{\"502\":1,\"525\":1},\"1\":{\"503\":1,\"526\":1,\"536\":1}}],[\"动态字符串sds\",{\"0\":{\"424\":1}}],[\"^\",{\"1\":{\"501\":1,\"524\":1}}],[\"点我查看\",{\"1\":{\"498\":1}}],[\"👉\",{\"1\":{\"498\":1}}],[\"斐波那契数列\",{\"1\":{\"496\":1}}],[\"斐波那契数\",{\"0\":{\"495\":1},\"1\":{\"496\":1,\"497\":1}}],[\"道理是一样的\",{\"1\":{\"492\":1}}],[\"思路解析\",{\"0\":{\"511\":1}}],[\"思路分析\",{\"0\":{\"492\":1,\"516\":1}}],[\"思考题\",{\"0\":{\"126\":1},\"1\":{\"122\":1}}],[\"思考\",{\"0\":{\"122\":1,\"458\":1},\"1\":{\"322\":1,\"432\":1,\"444\":1}}],[\"想要给你的孩子们一些小饼干\",{\"1\":{\"491\":1}}],[\"综上两种情况\",{\"1\":{\"481\":1}}],[\"综上所述\",{\"1\":{\"17\":1}}],[\"暴力三循环\",{\"0\":{\"480\":1}}],[\"示例\",{\"1\":{\"477\":3,\"491\":2,\"496\":3,\"509\":4,\"514\":2,\"519\":2,\"532\":2,\"541\":3}}],[\"题目数据保证答案小于等于\",{\"1\":{\"509\":1}}],[\"题目中的要求是尽可能满足更多的孩子\",{\"1\":{\"492\":1}}],[\"题目中已经给定了nums数组的两个初始值\",{\"1\":{\"486\":1}}],[\"题目介绍\",{\"0\":{\"484\":1,\"541\":1}}],[\"题目地址\",{\"0\":{\"478\":1,\"485\":1,\"493\":1,\"497\":1,\"510\":1,\"515\":1,\"520\":1,\"533\":1,\"542\":1}}],[\"题目描述\",{\"0\":{\"477\":1,\"491\":1,\"496\":1,\"509\":1,\"514\":1,\"519\":1,\"532\":1}}],[\"题解\",{\"0\":{\"9\":1,\"543\":1,\"544\":1}}],[\"面向对象\",{\"0\":{\"475\":1}}],[\"源码解析\",{\"0\":{\"473\":1}}],[\"程序将对象的refcount减一\",{\"1\":{\"470\":1}}],[\"复杂度分析\",{\"0\":{\"489\":1,\"501\":1,\"504\":1,\"507\":1,\"524\":1,\"527\":1,\"530\":1,\"537\":1,\"539\":1}}],[\"复杂度较高\",{\"1\":{\"469\":1}}],[\"复用\",{\"1\":{\"239\":1}}],[\"各种命令的返回值\",{\"1\":{\"469\":1}}],[\"各种环境的安装方式\",{\"1\":{\"366\":1}}],[\"种特殊类型\",{\"1\":{\"467\":1}}],[\"种基本类型\",{\"1\":{\"467\":1}}],[\"种不同类型\",{\"1\":{\"466\":1}}],[\"种编码方式\",{\"1\":{\"465\":1}}],[\"种淘汰策略\",{\"1\":{\"276\":1,\"456\":1}}],[\"拥有这两个信息时\",{\"1\":{\"464\":1}}],[\"容量无上限\",{\"1\":{\"462\":1}}],[\"容易导致内核崩溃\",{\"1\":{\"412\":1}}],[\"派发给对应的处理器进行处理\",{\"1\":{\"460\":1}}],[\"核心部分由大量的网络和连接这些网络的路由器组成\",{\"1\":{\"570\":1}}],[\"核心特性\",{\"1\":{\"548\":1}}],[\"核心的命令执行\",{\"1\":{\"461\":1}}],[\"核心\",{\"1\":{\"460\":1}}],[\"核心后台线程\",{\"1\":{\"73\":1}}],[\"带来不必要的开销\",{\"1\":{\"458\":1}}],[\"带来巨大压力\",{\"1\":{\"271\":1}}],[\"抛开持久化不谈\",{\"1\":{\"458\":1}}],[\"距离上一次访问时间每隔\",{\"1\":{\"456\":1}}],[\"距离查询\",{\"1\":{\"396\":1}}],[\"淘汰策略\",{\"0\":{\"456\":1}}],[\"抽取20个key判断是否过期\",{\"1\":{\"455\":2}}],[\"抽象数据组织及与之相关的操作\",{\"1\":{\"32\":1}}],[\"抽象数据类型\",{\"1\":{\"32\":1}}],[\"抽象为计算三维体积\",{\"1\":{\"28\":1}}],[\"清理\",{\"1\":{\"455\":1}}],[\"清空本地数据\",{\"1\":{\"300\":1}}],[\"周期性的抽样部分过期的\",{\"1\":{\"455\":1}}],[\"周期删除\",{\"1\":{\"454\":1,\"455\":1}}],[\"立刻删除对应的\",{\"1\":{\"455\":1}}],[\"立刻记录到\",{\"1\":{\"320\":1}}],[\"惰性删除\",{\"1\":{\"454\":1,\"455\":1}}],[\"答\",{\"1\":{\"454\":2}}],[\"答案中不可以包含重复的三元组\",{\"1\":{\"477\":1}}],[\"答案\",{\"1\":{\"126\":2,\"432\":1}}],[\"另有两个整数\",{\"1\":{\"541\":1}}],[\"另外一个用来记录\",{\"1\":{\"454\":1}}],[\"另一个一般是空\",{\"1\":{\"436\":1}}],[\"跨度越大\",{\"1\":{\"453\":1}}],[\"层级越高\",{\"1\":{\"453\":1}}],[\"层级较深\",{\"1\":{\"116\":1,\"117\":1}}],[\"层数是\",{\"1\":{\"453\":1}}],[\"跳跃表是一个双向链表\",{\"1\":{\"453\":1}}],[\"跳表\",{\"1\":{\"451\":1,\"466\":1}}],[\"跳表skiplist\",{\"0\":{\"450\":1}}],[\"级指针\",{\"1\":{\"451\":1}}],[\"级别开启profiling\",{\"1\":{\"228\":1}}],[\"过期key比例小于10\",{\"1\":{\"455\":1}}],[\"过多\",{\"1\":{\"448\":1}}],[\"过程是阻塞的\",{\"1\":{\"319\":1}}],[\"过程\",{\"1\":{\"231\":1}}],[\"怎么办\",{\"1\":{\"444\":1}}],[\"申请内存的效率很低\",{\"1\":{\"444\":1}}],[\"申请内存时只需要调用一次内存分配函数\",{\"1\":{\"415\":1}}],[\"连锁更新\",{\"1\":{\"443\":1}}],[\"连锁更新问题\",{\"0\":{\"443\":1}}],[\"连接处理器\",{\"1\":{\"462\":1}}],[\"连接等待时间\",{\"1\":{\"360\":1}}],[\"连接池依赖\",{\"1\":{\"360\":1}}],[\"连接池大小\",{\"1\":{\"307\":1}}],[\"连接redis失败\",{\"1\":{\"307\":1}}],[\"连接的空闲时间\",{\"1\":{\"307\":1}}],[\"连接\",{\"1\":{\"297\":3,\"342\":1,\"462\":1}}],[\"连接层处于mysql体系结构中的最上层\",{\"1\":{\"231\":1}}],[\"连接层\",{\"1\":{\"231\":1}}],[\"连接条件\",{\"1\":{\"94\":1,\"95\":2}}],[\"连接释放报文段也要占用一个序号\",{\"1\":{\"17\":1}}],[\"连接释放报文段也要消耗一个序号\",{\"1\":{\"17\":1}}],[\"连接过程更加复杂\",{\"1\":{\"16\":1}}],[\"连接关闭\",{\"1\":{\"15\":1}}],[\"理解了\",{\"1\":{\"441\":1}}],[\"理论上无上限\",{\"1\":{\"410\":1}}],[\"理论上是无限的\",{\"1\":{\"406\":1}}],[\"理论上讲dml数据操作语言\",{\"1\":{\"179\":1}}],[\"势必会造成\",{\"1\":{\"438\":1}}],[\"渐进式完成的\",{\"1\":{\"438\":1}}],[\"渐进式的完成\",{\"1\":{\"438\":1}}],[\"极有可能导致主线程阻塞\",{\"1\":{\"438\":1}}],[\"极端情况\",{\"1\":{\"319\":1}}],[\"变化\",{\"1\":{\"438\":1}}],[\"变量类型就是数据库字段类型\",{\"1\":{\"244\":1}}],[\"变量类型\",{\"1\":{\"244\":1}}],[\"变量名\",{\"1\":{\"243\":1,\"244\":4}}],[\"变量\",{\"0\":{\"241\":1,\"288\":1},\"1\":{\"252\":2}}],[\"负载均衡\",{\"0\":{\"577\":1}}],[\"负载因子\",{\"1\":{\"437\":2}}],[\"负责将写缓冲区内容刷新到磁盘\",{\"1\":{\"73\":1}}],[\"负责将日志缓冲区刷新到磁盘\",{\"1\":{\"73\":1}}],[\"负责写操作\",{\"1\":{\"73\":1}}],[\"负责读操作\",{\"1\":{\"73\":1}}],[\"必大于0\",{\"1\":{\"481\":1}}],[\"必然要引入线程锁这样的安全手段\",{\"1\":{\"458\":1}}],[\"必然导致哈希冲突增多\",{\"1\":{\"437\":1}}],[\"必定会创建新的哈希表\",{\"1\":{\"438\":1}}],[\"必须让每个键都带有类型信息\",{\"1\":{\"464\":1}}],[\"必须为不同类型的键设置不同的处理方式\",{\"1\":{\"464\":1}}],[\"必须唯一\",{\"1\":{\"419\":1}}],[\"必须通过内核提供的接口访问\",{\"1\":{\"401\":1}}],[\"必须想\",{\"1\":{\"300\":1}}],[\"必须准备三份不同的配置文件和目录\",{\"1\":{\"295\":1,\"331\":1}}],[\"必须使得所有的数据都保持一致状态\",{\"1\":{\"257\":1}}],[\"必须使所有的数据都保持一致性\",{\"1\":{\"74\":1}}],[\"必须用在循环中\",{\"1\":{\"251\":2}}],[\"必须有\",{\"1\":{\"124\":1}}],[\"扩容大小为第一个大于等于used\",{\"1\":{\"439\":1}}],[\"扩容\",{\"1\":{\"437\":1}}],[\"扩容收缩的具体步骤如下\",{\"1\":{\"437\":1}}],[\"扩容收缩\",{\"0\":{\"437\":1}}],[\"扩展性\",{\"1\":{\"364\":1}}],[\"扩展性极高的动态\",{\"1\":{\"304\":1}}],[\"扩展模块提供了\",{\"1\":{\"281\":1}}],[\"私有数组\",{\"1\":{\"436\":1}}],[\"决定是插入队首\",{\"1\":{\"432\":1}}],[\"决定循环的终止条件\",{\"1\":{\"289\":1}}],[\"倒序遍历\",{\"1\":{\"432\":1}}],[\"倒序是为了防止正序拷贝时的数据覆盖\",{\"1\":{\"432\":1}}],[\"倒序依次将数组中的元素拷贝到扩容后的正确位置\",{\"1\":{\"432\":1}}],[\"依次类推\",{\"1\":{\"448\":1}}],[\"依次查找并执行\",{\"1\":{\"438\":1}}],[\"依次读取每个元素\",{\"1\":{\"422\":1}}],[\"依赖\",{\"1\":{\"346\":1,\"353\":1}}],[\"遍历完进行去重操作即可\",{\"1\":{\"480\":1}}],[\"遍历处理就绪的\",{\"1\":{\"462\":1}}],[\"遍历\",{\"1\":{\"422\":1}}],[\"升级到了\",{\"1\":{\"421\":1}}],[\"升序\",{\"1\":{\"191\":1}}],[\"协议规定了网络传输数据时所遵循的规范\",{\"1\":{\"569\":1}}],[\"协议是计算机网络的核心\",{\"1\":{\"569\":1}}],[\"协议三大部分组成\",{\"1\":{\"569\":1}}],[\"协议\",{\"1\":{\"421\":5}}],[\"协助\",{\"1\":{\"73\":1}}],[\"超出了\",{\"1\":{\"444\":1}}],[\"超出编码\",{\"1\":{\"432\":1}}],[\"超过则采用\",{\"1\":{\"416\":1}}],[\"超时时间\",{\"1\":{\"405\":1,\"406\":1,\"407\":1}}],[\"超时剔除\",{\"1\":{\"274\":1}}],[\"尾操作列表中的元素\",{\"1\":{\"416\":1}}],[\"尾插法建立单链表\",{\"1\":{\"37\":1}}],[\"了\",{\"1\":{\"415\":1}}],[\"刚好\",{\"1\":{\"415\":1}}],[\"范围从\",{\"1\":{\"442\":1}}],[\"范围内\",{\"1\":{\"415\":1}}],[\"范围查询右侧的列索引失效\",{\"1\":{\"129\":1}}],[\"范围查询\",{\"1\":{\"129\":1,\"396\":1}}],[\"期间\",{\"1\":{\"438\":1}}],[\"期间用户应用可以执行其他业务\",{\"1\":{\"411\":1}}],[\"期间的命令记录在\",{\"1\":{\"300\":1}}],[\"形成的序列称为\",{\"1\":{\"496\":1}}],[\"形成循环\",{\"1\":{\"408\":1}}],[\"形成一个单向链表\",{\"1\":{\"119\":1}}],[\"形成一个新的查询结果集\",{\"1\":{\"97\":1}}],[\"事件派发\",{\"1\":{\"460\":1}}],[\"事件通知机制\",{\"0\":{\"408\":1}}],[\"事务不会回滚\",{\"1\":{\"399\":1}}],[\"事务可以理解为一个打包的批量执行脚本\",{\"1\":{\"399\":1}}],[\"事务可以一次执行多个命令\",{\"1\":{\"399\":1}}],[\"事务中任意命令执行失败\",{\"1\":{\"399\":1}}],[\"事务并发问题\",{\"0\":{\"258\":1}}],[\"事务一旦提交或者回滚\",{\"1\":{\"257\":1}}],[\"事务一旦提交或回滚\",{\"1\":{\"74\":1}}],[\"事务的执行并不是原子性的\",{\"1\":{\"399\":1}}],[\"事务的隔离级别越高\",{\"1\":{\"259\":1}}],[\"事务的隔离级别\",{\"0\":{\"259\":1}}],[\"事务的acid特性\",{\"1\":{\"257\":1}}],[\"事务的四大特性\",{\"0\":{\"257\":1}}],[\"事务操作\",{\"0\":{\"256\":1}}],[\"事务会把所有的操作作为一个整体一起向系统提交或者撤销操作请求\",{\"1\":{\"255\":1}}],[\"事务会把所有的操作作为一个整体向系统提交或撤销操作请求\",{\"1\":{\"74\":1}}],[\"事务安全\",{\"1\":{\"236\":1}}],[\"事务\",{\"0\":{\"255\":1,\"399\":1},\"1\":{\"170\":1,\"262\":1}}],[\"事务提交时\",{\"1\":{\"76\":1}}],[\"事务完成时\",{\"1\":{\"74\":1,\"257\":1}}],[\"事务是不可分割的最小操作单元\",{\"1\":{\"74\":1,\"257\":1}}],[\"事务是一组操作的集合\",{\"1\":{\"74\":1,\"255\":1}}],[\"事务特性\",{\"1\":{\"74\":1,\"364\":1}}],[\"事务原理\",{\"0\":{\"74\":1}}],[\"拷贝\",{\"1\":{\"406\":1}}],[\"拷贝配置文件到每个实例目录\",{\"1\":{\"295\":1}}],[\"流程\",{\"1\":{\"406\":1}}],[\"流程函数也是很常用的一类函数\",{\"1\":{\"56\":1}}],[\"流程函数\",{\"0\":{\"56\":1}}],[\"错误时返回的error\",{\"1\":{\"469\":1}}],[\"错误的数据格式\",{\"1\":{\"422\":1}}],[\"错误\",{\"1\":{\"421\":1}}],[\"错误事件\",{\"1\":{\"406\":1}}],[\"错误等情况\",{\"1\":{\"3\":1}}],[\"部分关键代码如下\",{\"1\":{\"406\":1}}],[\"部分内置函数的执行\",{\"1\":{\"231\":1}}],[\"固定指针+双循环指针\",{\"0\":{\"481\":1}}],[\"固定只占用\",{\"1\":{\"442\":1}}],[\"固定等待时间\",{\"1\":{\"405\":1}}],[\"固定16k\",{\"1\":{\"204\":1}}],[\"固定1m\",{\"1\":{\"204\":1}}],[\"永不超时\",{\"1\":{\"405\":1}}],[\"永久生效\",{\"1\":{\"297\":1}}],[\"恰好一次\",{\"1\":{\"514\":1}}],[\"恰好从\",{\"1\":{\"443\":1}}],[\"恰好未就绪\",{\"1\":{\"404\":1}}],[\"恰好有数据\",{\"1\":{\"404\":1}}],[\"恰好没有数据\",{\"1\":{\"404\":1}}],[\"均无法发挥\",{\"1\":{\"404\":1}}],[\"忙轮训\",{\"1\":{\"403\":1}}],[\"顾名思义\",{\"1\":{\"402\":1}}],[\"顾名思义就是通过可视化的软件\",{\"1\":{\"373\":1}}],[\"信号较多\",{\"1\":{\"411\":1}}],[\"信号通知用户\",{\"1\":{\"411\":1}}],[\"信号驱动io\",{\"0\":{\"411\":1}}],[\"信号驱动\",{\"1\":{\"401\":1,\"411\":1}}],[\"信息\",{\"1\":{\"406\":1,\"432\":1}}],[\"信息如下\",{\"1\":{\"294\":1,\"338\":1}}],[\"寻找命令对应的command\",{\"1\":{\"462\":1}}],[\"寻找插槽所在实例即可\",{\"1\":{\"343\":1}}],[\"寻址地址就为\",{\"1\":{\"401\":1}}],[\"位置开始循环\",{\"1\":{\"511\":1}}],[\"位置保存数值\",{\"1\":{\"442\":1}}],[\"位\",{\"1\":{\"465\":1}}],[\"位有符号整数\",{\"1\":{\"442\":1}}],[\"位的操作系统\",{\"1\":{\"401\":1}}],[\"位序是从\",{\"1\":{\"36\":2}}],[\"任何linux\",{\"1\":{\"401\":1}}],[\"任意一个消费者读取了消息都会使游标\",{\"1\":{\"385\":1}}],[\"任意写\",{\"1\":{\"331\":1}}],[\"⽐如每⽉活跃⽤户可以使⽤每天的活跃⽤户来合并计算可得\",{\"1\":{\"398\":1}}],[\"⽐如⽤hll存储每天的uv\",{\"1\":{\"398\":1}}],[\"⽽不会储存输⼊元素本身\",{\"1\":{\"398\":1}}],[\"键\",{\"1\":{\"436\":1}}],[\"键必须唯一\",{\"1\":{\"417\":1,\"419\":1}}],[\"键只需要花费\",{\"1\":{\"398\":1}}],[\"键值型\",{\"1\":{\"365\":1}}],[\"键值类型\",{\"1\":{\"364\":1}}],[\"键值设计\",{\"0\":{\"284\":1},\"1\":{\"264\":1}}],[\"键值\",{\"1\":{\"109\":1}}],[\"⾥⾯\",{\"1\":{\"398\":1}}],[\"异常等\",{\"1\":{\"407\":1}}],[\"异常\",{\"1\":{\"406\":1,\"422\":1}}],[\"异步io\",{\"0\":{\"412\":1}}],[\"异步\",{\"1\":{\"401\":1,\"412\":2}}],[\"异步加载的方式也可供选择\",{\"1\":{\"281\":1}}],[\"异或\",{\"1\":{\"397\":1}}],[\"⾮\",{\"1\":{\"397\":1}}],[\"纬度\",{\"1\":{\"396\":1}}],[\"找\",{\"1\":{\"419\":1}}],[\"找出位于指定范围内的\",{\"1\":{\"396\":1}}],[\"找出某⼀半径内的元素\",{\"1\":{\"396\":1}}],[\"找到就绪的\",{\"1\":{\"406\":1}}],[\"找到记录值的id\",{\"1\":{\"125\":1}}],[\"找到\",{\"1\":{\"21\":1,\"22\":1,\"23\":1,\"24\":1}}],[\"经度\",{\"1\":{\"396\":1}}],[\"经度和纬度\",{\"1\":{\"396\":1}}],[\"经纬度hash等常⻅操作\",{\"1\":{\"396\":1}}],[\"经常被用来实现排行榜这样的功能\",{\"1\":{\"380\":1}}],[\"经常查阅菜鸟教程编写的\",{\"1\":{\"266\":1}}],[\"地理信息的缩写\",{\"1\":{\"396\":1}}],[\"地址\",{\"1\":{\"33\":1,\"280\":1,\"366\":1,\"374\":1}}],[\"阻塞io模型中\",{\"1\":{\"402\":1}}],[\"阻塞io\",{\"0\":{\"402\":1}}],[\"阻塞\",{\"1\":{\"401\":1,\"402\":1,\"404\":1}}],[\"阻塞毫秒数\",{\"1\":{\"392\":1,\"394\":1}}],[\"阻止其他事务获得相同数据集的共享锁和排他锁\",{\"1\":{\"147\":1}}],[\"阻止其他事务获得相同数据集的排他锁\",{\"1\":{\"147\":1}}],[\"队列名\",{\"1\":{\"390\":1,\"391\":1,\"392\":1,\"394\":1}}],[\"队列名称\",{\"1\":{\"386\":1,\"387\":1,\"388\":1,\"389\":1,\"393\":1}}],[\"队列的定义\",{\"1\":{\"32\":1}}],[\"打印流信息\",{\"1\":{\"385\":1}}],[\"打印消费者组的信息\",{\"1\":{\"385\":1}}],[\"打开配置文件\",{\"1\":{\"305\":1}}],[\"打开游标\",{\"1\":{\"252\":1}}],[\"转为redis命令参数存入\",{\"1\":{\"462\":1}}],[\"转链表存储\",{\"1\":{\"406\":1}}],[\"转移消息的归属权\",{\"1\":{\"385\":1}}],[\"转变为established\",{\"1\":{\"15\":1}}],[\"反向获取消息列表\",{\"1\":{\"385\":1}}],[\"反之\",{\"1\":{\"76\":1,\"481\":1}}],[\"往往是字符串或者字符串的集合\",{\"1\":{\"425\":1}}],[\"往前移动\",{\"1\":{\"385\":1}}],[\"往redis中存放一条string类型的数据并获取返回结果\",{\"1\":{\"351\":1}}],[\"消费者名\",{\"1\":{\"394\":1}}],[\"消费者组相关命令\",{\"1\":{\"385\":1}}],[\"消费者\",{\"1\":{\"385\":1}}],[\"消费组名\",{\"1\":{\"394\":1}}],[\"消费组\",{\"1\":{\"385\":1}}],[\"消息会全部忽略\",{\"1\":{\"393\":1}}],[\"消息\",{\"1\":{\"386\":1,\"388\":1,\"392\":1,\"394\":1}}],[\"消息队列相关命令\",{\"1\":{\"385\":1}}],[\"消息就会被丢弃\",{\"1\":{\"385\":1}}],[\"消息发布者和订阅者不进行直接通信\",{\"1\":{\"381\":1}}],[\"校验码\",{\"1\":{\"384\":1}}],[\"校对规则名\",{\"1\":{\"177\":1}}],[\"杀死当前正在运行的\",{\"1\":{\"384\":1}}],[\"环境\",{\"1\":{\"382\":1}}],[\"脚本\",{\"1\":{\"384\":1}}],[\"脚本命令\",{\"0\":{\"384\":1}}],[\"脚本使用\",{\"1\":{\"382\":1}}],[\"脚本语言调动\",{\"1\":{\"304\":1}}],[\"退订给定模式频道\",{\"1\":{\"381\":1}}],[\"退订一个或多个频道\",{\"1\":{\"381\":1}}],[\"退出递归的条件\",{\"1\":{\"500\":1}}],[\"退出\",{\"1\":{\"361\":1}}],[\"退出指定标记的循环体\",{\"1\":{\"251\":1}}],[\"退出循环\",{\"1\":{\"251\":1}}],[\"订阅给定模式频道\",{\"1\":{\"381\":1}}],[\"订阅一个或多个频道\",{\"1\":{\"381\":1}}],[\"订阅该频道的每个客户端都可以收到该消息\",{\"1\":{\"381\":1}}],[\"订阅者\",{\"1\":{\"381\":1}}],[\"此种模式下\",{\"1\":{\"381\":1}}],[\"此时到达该阶梯的最小花费即为上一步的最小花费加上此步骤的最优解即最小花费\",{\"1\":{\"534\":1}}],[\"此时的dp\",{\"1\":{\"534\":1}}],[\"此时的最优解即这两个台阶中的一个最小值\",{\"1\":{\"534\":1}}],[\"此时的f\",{\"1\":{\"498\":1,\"521\":1}}],[\"此时仅有左\",{\"1\":{\"512\":1}}],[\"此时仅有上\",{\"1\":{\"512\":1}}],[\"此时仅仅只有客户端向服务端方向的连接断开\",{\"1\":{\"17\":1}}],[\"此时必然有上和左\",{\"1\":{\"512\":1}}],[\"此时encoding的后14位用来存储string长度\",{\"1\":{\"442\":1}}],[\"此时encoding长度为5个字节\",{\"1\":{\"442\":1}}],[\"此时encoding长度为两个字节\",{\"1\":{\"442\":1}}],[\"此时encoding长度为1个字节\",{\"1\":{\"442\":1}}],[\"此时启动redis时需要加上配置文件\",{\"1\":{\"369\":1}}],[\"此时密码即为\",{\"1\":{\"369\":1}}],[\"此时我们可以使用后台启动\",{\"1\":{\"368\":1}}],[\"此时命令终端会一直响应redis服务\",{\"1\":{\"368\":1}}],[\"此时节点总数\",{\"1\":{\"341\":1}}],[\"此时主进程大量修改数据\",{\"1\":{\"319\":1}}],[\"此时事务执行完毕时\",{\"1\":{\"256\":1}}],[\"此时查询的代价就比较大\",{\"1\":{\"217\":1}}],[\"此时需要注意联合索引在创建时的规则\",{\"1\":{\"211\":1}}],[\"此时则需要将\",{\"1\":{\"481\":1}}],[\"此时则完成了数据的插入\",{\"1\":{\"205\":1}}],[\"此时则在undo\",{\"1\":{\"84\":1}}],[\"此时页内的数据是有序的\",{\"1\":{\"205\":1}}],[\"此时可以使用mysql提供的load指令进行插入\",{\"1\":{\"202\":1}}],[\"此时可以只将字符串的一部分前缀\",{\"1\":{\"132\":1}}],[\"此时还需要通过id值在聚集索引中查询\",{\"1\":{\"126\":1}}],[\"此时就产生了哈希碰撞\",{\"1\":{\"121\":1}}],[\"此时\",{\"1\":{\"22\":1,\"319\":1,\"415\":1}}],[\"此时tcp连接还未释放\",{\"1\":{\"17\":1}}],[\"此时将服务端到客户端方向的连接断开\",{\"1\":{\"17\":1}}],[\"此时由客户端发送连接释放报文段\",{\"1\":{\"17\":1}}],[\"此时服务端从syn\",{\"1\":{\"15\":1}}],[\"此时服务端从listen\",{\"1\":{\"15\":1}}],[\"此时连接建立\",{\"1\":{\"15\":1}}],[\"此时发送报文段的同时为该tcp连接分配对应的缓存和变量\",{\"1\":{\"15\":1}}],[\"此时报文段的ack位置为1\",{\"1\":{\"15\":1}}],[\"此时客户端从syn\",{\"1\":{\"15\":1}}],[\"此时客户端接受到服务端发来的确认报文段\",{\"1\":{\"15\":1}}],[\"此时客户端由closed\",{\"1\":{\"15\":1}}],[\"此时同意进行连接时\",{\"1\":{\"15\":1}}],[\"接收\",{\"1\":{\"462\":1}}],[\"接收多个元素\",{\"1\":{\"422\":1}}],[\"接收消息\",{\"1\":{\"381\":1}}],[\"接收插槽的\",{\"1\":{\"344\":1}}],[\"移除set中的指定元素\",{\"1\":{\"379\":1}}],[\"移除并返回列表右侧的第一个元素\",{\"1\":{\"378\":1}}],[\"移除并返回列表左侧的第一个元素\",{\"1\":{\"378\":1}}],[\"移动数组中\",{\"1\":{\"432\":1}}],[\"移动\",{\"1\":{\"344\":1}}],[\"评论列表等\",{\"1\":{\"378\":1}}],[\"朋友圈点赞列表\",{\"1\":{\"378\":1}}],[\"项目名\",{\"1\":{\"376\":1}}],[\"隔开\",{\"1\":{\"376\":1}}],[\"隔离级别\",{\"1\":{\"259\":1}}],[\"隔离性\",{\"1\":{\"74\":1,\"86\":1,\"257\":1}}],[\"浮点类型\",{\"1\":{\"376\":1}}],[\"整体\",{\"1\":{\"458\":1}}],[\"整数等实际数据的类型\",{\"1\":{\"469\":1}}],[\"整数集合\",{\"1\":{\"466\":1}}],[\"整数集intset\",{\"0\":{\"429\":1}}],[\"整数\",{\"1\":{\"442\":1}}],[\"整数类型\",{\"1\":{\"376\":1}}],[\"整个\",{\"1\":{\"343\":1}}],[\"普通字符串\",{\"1\":{\"376\":1}}],[\"意思是\",{\"1\":{\"376\":1}}],[\"意向排他锁\",{\"1\":{\"145\":1}}],[\"意向共享锁\",{\"1\":{\"145\":1}}],[\"意向锁之间不会互斥\",{\"1\":{\"145\":1}}],[\"意向锁\",{\"0\":{\"145\":1},\"1\":{\"142\":1}}],[\"几级指针代表一次横跨几个节点\",{\"1\":{\"451\":1}}],[\"几千万甚至几亿\",{\"1\":{\"438\":1}}],[\"几个java语言的客户端展示\",{\"1\":{\"374\":1}}],[\"几乎不丢数据\",{\"1\":{\"320\":1}}],[\"唯⼀的区别就在于github上的更新⽐较及时\",{\"1\":{\"373\":1}}],[\"唯一可能的三元组和为\",{\"1\":{\"477\":1}}],[\"唯一可能的三元组和不为\",{\"1\":{\"477\":1}}],[\"唯一索引的选择性是1\",{\"1\":{\"132\":1}}],[\"唯一索引\",{\"1\":{\"124\":2}}],[\"唯一约束\",{\"1\":{\"47\":1}}],[\"⼀般来说两者都没有什么差别\",{\"1\":{\"373\":1}}],[\"qblen\",{\"1\":{\"462\":1}}],[\"ql\",{\"1\":{\"447\":3}}],[\"qishibo\",{\"1\":{\"373\":2}}],[\"quicklist小结\",{\"0\":{\"449\":1}}],[\"quicklistentry\",{\"1\":{\"447\":3}}],[\"quicklistiter\",{\"1\":{\"447\":3}}],[\"quicklistbookmark\",{\"1\":{\"447\":4}}],[\"quicklistlzf\",{\"1\":{\"447\":3}}],[\"quicklistnodes\",{\"1\":{\"447\":1}}],[\"quicklistnode\",{\"1\":{\"447\":9}}],[\"quicklistnote\",{\"1\":{\"447\":1}}],[\"quicklist示意图\",{\"1\":{\"446\":1}}],[\"quicklist是一个双向链表\",{\"1\":{\"446\":1}}],[\"quicklist\",{\"1\":{\"416\":1,\"444\":1,\"446\":3,\"447\":7,\"448\":4,\"449\":1,\"466\":1,\"467\":1}}],[\"quit\",{\"1\":{\"361\":1}}],[\"queue\",{\"1\":{\"385\":1}}],[\"query\",{\"1\":{\"104\":1,\"174\":1,\"227\":3,\"228\":4}}],[\"quorum\",{\"1\":{\"325\":2}}],[\"费\",{\"1\":{\"373\":1}}],[\"⽀持mac\",{\"1\":{\"373\":1}}],[\"守护进程\",{\"1\":{\"369\":1}}],[\"生产环境不要设置为0\",{\"1\":{\"369\":1}}],[\"生成\",{\"1\":{\"386\":1,\"456\":1}}],[\"生成readview的时机不同\",{\"1\":{\"86\":1}}],[\"生成一条记录版本链条\",{\"1\":{\"84\":1}}],[\"生成新结点\",{\"1\":{\"37\":1}}],[\"良好的编码\",{\"1\":{\"365\":1}}],[\"速度快\",{\"1\":{\"365\":1}}],[\"速度更快\",{\"1\":{\"280\":1}}],[\"认识redis\",{\"0\":{\"365\":1}}],[\"水平\",{\"1\":{\"364\":1}}],[\"垂直\",{\"1\":{\"364\":1}}],[\"泛指非关系型的数据库\",{\"1\":{\"363\":2}}],[\"泛型for循环\",{\"1\":{\"289\":1}}],[\"统计字符串被设置为1的bit数\",{\"1\":{\"397\":1}}],[\"统计score值在给定范围内的所有元素的个数\",{\"1\":{\"380\":1}}],[\"统计数量\",{\"1\":{\"189\":1}}],[\"统一为\",{\"1\":{\"418\":1}}],[\"统一采用\",{\"1\":{\"416\":1}}],[\"统一\",{\"1\":{\"358\":1}}],[\"省去了我们自定义的\",{\"1\":{\"355\":1}}],[\"省略的对\",{\"1\":{\"345\":1}}],[\"针对不同的\",{\"1\":{\"441\":1}}],[\"针对如图所示的特殊情况\",{\"1\":{\"354\":1}}],[\"针对于常作为查询条件\",{\"1\":{\"134\":1}}],[\"针对于数据量较大\",{\"1\":{\"134\":1}}],[\"针对于表中主键创建的索引\",{\"1\":{\"124\":1}}],[\"针对于非唯一的二级索引页\",{\"1\":{\"62\":1}}],[\"采用渐进式\",{\"1\":{\"438\":1}}],[\"采用\",{\"1\":{\"416\":2,\"418\":1}}],[\"采用的是\",{\"1\":{\"319\":1}}],[\"采⽤\",{\"1\":{\"353\":2}}],[\"既能从上边网格向下移动\",{\"1\":{\"511\":1}}],[\"既可以支持正向检索和也可以支持反向检索\",{\"1\":{\"378\":1}}],[\"既可以作为输入参数\",{\"1\":{\"246\":1}}],[\"既然这样可读性又差\",{\"1\":{\"352\":1}}],[\"资源子网是实现资源共享功能的设备及其软件的集合\",{\"1\":{\"571\":1}}],[\"资源的位置信息\",{\"1\":{\"567\":1}}],[\"资源共享可以是软件共享\",{\"1\":{\"574\":1}}],[\"资源共享\",{\"0\":{\"574\":1},\"1\":{\"566\":1}}],[\"资源共享观点\",{\"0\":{\"566\":1}}],[\"资源\",{\"1\":{\"404\":1}}],[\"资源占用又高\",{\"1\":{\"352\":1}}],[\"资源占用高\",{\"1\":{\"352\":1}}],[\"资料\",{\"1\":{\"291\":1}}],[\"序列化器\",{\"1\":{\"355\":1}}],[\"序列化器来处理\",{\"1\":{\"355\":1}}],[\"序列化类\",{\"1\":{\"353\":1}}],[\"序列化⽅式\",{\"1\":{\"353\":1}}],[\"序列化的方式来解决\",{\"1\":{\"352\":1}}],[\"序列化\",{\"1\":{\"352\":1}}],[\"序列化成为字节形式\",{\"1\":{\"352\":1}}],[\"序号seq\",{\"1\":{\"17\":1}}],[\"序号seq=\",{\"1\":{\"17\":1}}],[\"官方地址\",{\"0\":{\"350\":1}}],[\"官网地址\",{\"1\":{\"358\":1}}],[\"官网\",{\"1\":{\"286\":1}}],[\"专为性能和易用性而设计\",{\"1\":{\"349\":1}}],[\"忽略\",{\"1\":{\"345\":1}}],[\"忽略数据一致性\",{\"1\":{\"345\":1}}],[\"忽略索引\",{\"1\":{\"130\":1}}],[\"步长为指定的increment值\",{\"1\":{\"380\":1}}],[\"步\",{\"1\":{\"345\":1}}],[\"步骤2\",{\"0\":{\"310\":1}}],[\"步骤1\",{\"0\":{\"309\":1}}],[\"缺一不可\",{\"1\":{\"569\":1}}],[\"缺省\",{\"1\":{\"345\":1}}],[\"缺点\",{\"1\":{\"114\":1,\"116\":1,\"117\":1,\"234\":1,\"270\":2,\"272\":1,\"280\":2,\"320\":1,\"352\":1}}],[\"手动反序列化为对象\",{\"1\":{\"356\":1}}],[\"手动完成对象的序列化和反序列化\",{\"1\":{\"355\":1}}],[\"手动的\",{\"1\":{\"345\":1}}],[\"手动提交事务\",{\"0\":{\"200\":1}}],[\"切换到执行\",{\"1\":{\"345\":1}}],[\"端口为\",{\"1\":{\"344\":1}}],[\"余数作为插槽\",{\"1\":{\"343\":1}}],[\"取消\",{\"1\":{\"399\":1}}],[\"取消监视\",{\"1\":{\"399\":1}}],[\"取消事务\",{\"1\":{\"399\":1}}],[\"取余\",{\"1\":{\"343\":2}}],[\"取决于刷盘策略\",{\"1\":{\"321\":1}}],[\"散列插槽\",{\"0\":{\"343\":1}}],[\"散列存储\",{\"1\":{\"33\":2}}],[\"尝试把结果写到\",{\"1\":{\"462\":1}}],[\"尝试连接7001节点\",{\"1\":{\"342\":1}}],[\"尝试让master节点7001宕机\",{\"1\":{\"333\":1}}],[\"÷\",{\"1\":{\"341\":1}}],[\"zlend\",{\"1\":{\"442\":1}}],[\"zlib\",{\"1\":{\"341\":1}}],[\"zipmap\",{\"1\":{\"466\":1}}],[\"ziplist小结\",{\"0\":{\"444\":1}}],[\"ziplistentry\",{\"0\":{\"441\":1},\"1\":{\"442\":1,\"443\":1}}],[\"ziplist\",{\"1\":{\"416\":2,\"417\":7,\"419\":5,\"440\":1,\"441\":6,\"443\":3,\"444\":6,\"446\":2,\"448\":12,\"449\":3,\"466\":1,\"467\":2}}],[\"zi\",{\"1\":{\"447\":2}}],[\"zinter\",{\"1\":{\"380\":1}}],[\"zincrby\",{\"1\":{\"380\":1}}],[\"zunion\",{\"1\":{\"380\":1}}],[\"zdiff\",{\"1\":{\"380\":1}}],[\"zcount\",{\"1\":{\"380\":1}}],[\"zcard\",{\"1\":{\"380\":1}}],[\"zrangebyscore\",{\"1\":{\"380\":1}}],[\"zrange\",{\"1\":{\"380\":1}}],[\"zrank\",{\"1\":{\"380\":1}}],[\"zrem\",{\"1\":{\"380\":1}}],[\"zskiplistlevel\",{\"1\":{\"452\":1}}],[\"zskiplistnode\",{\"1\":{\"452\":6}}],[\"zskiplist\",{\"1\":{\"452\":3}}],[\"zset\",{\"1\":{\"417\":2,\"419\":7,\"467\":1}}],[\"zsetoperations\",{\"1\":{\"359\":1}}],[\"zscore\",{\"1\":{\"380\":1}}],[\"zadd\",{\"1\":{\"380\":1}}],[\"zh\",{\"1\":{\"281\":1}}],[\"推荐这种方式\",{\"1\":{\"340\":1}}],[\"绑定地址\",{\"1\":{\"339\":1}}],[\"海量数据存储问题\",{\"1\":{\"337\":1}}],[\"控制和管理\",{\"1\":{\"573\":1}}],[\"控制和储存的能力\",{\"1\":{\"571\":1}}],[\"控制\",{\"1\":{\"449\":1}}],[\"控制器\",{\"1\":{\"334\":1}}],[\"控制数据库的访问权限\",{\"1\":{\"194\":1}}],[\"控制数据表的访问权限\",{\"1\":{\"174\":1}}],[\"匿名内部类的简写\",{\"1\":{\"334\":1}}],[\"引用计数器\",{\"0\":{\"470\":1}}],[\"引用计数\",{\"1\":{\"456\":1}}],[\"引入多线程会面临线程安全问题\",{\"1\":{\"458\":1}}],[\"引入多线程异步处理一些耗时较长的任务\",{\"1\":{\"458\":1}}],[\"引入依赖\",{\"1\":{\"360\":1}}],[\"引入单元测试依赖\",{\"1\":{\"351\":1}}],[\"引入jedis依赖\",{\"1\":{\"351\":1}}],[\"引入\",{\"1\":{\"334\":1,\"346\":1}}],[\"引擎层处于mysql体系结构中的第三层\",{\"1\":{\"231\":1}}],[\"引擎层\",{\"1\":{\"231\":1}}],[\"引擎并不会把全部字段取出来\",{\"1\":{\"221\":1}}],[\"及其对应的\",{\"1\":{\"454\":1}}],[\"及其对应状态\",{\"1\":{\"405\":1}}],[\"及时更新连接信息\",{\"1\":{\"334\":1}}],[\"及排他锁\",{\"1\":{\"145\":1}}],[\"让sorted\",{\"1\":{\"380\":1}}],[\"让一个hash类型key的字段值自增并指定步长\",{\"1\":{\"377\":1}}],[\"让一个浮点类型的数字自增并指定步长\",{\"1\":{\"376\":1}}],[\"让一个整型的key自增并指定步长\",{\"1\":{\"376\":1}}],[\"让一个整型的key自增1\",{\"1\":{\"376\":1}}],[\"让num值自增2\",{\"1\":{\"376\":1}}],[\"让redis后台运行\",{\"1\":{\"339\":1}}],[\"让这些\",{\"1\":{\"327\":1}}],[\"让该节点成为\",{\"1\":{\"327\":1}}],[\"让服务端的资源白白浪费\",{\"1\":{\"16\":1}}],[\"越大越接近队尾\",{\"1\":{\"419\":1}}],[\"越大则说明数据越新\",{\"1\":{\"326\":1}}],[\"越小越接近队首\",{\"1\":{\"419\":1}}],[\"越小优先级越高\",{\"1\":{\"326\":2}}],[\"越多\",{\"1\":{\"406\":1}}],[\"越先执行\",{\"1\":{\"229\":1}}],[\"选举master时的quorum值\",{\"1\":{\"331\":1}}],[\"选举新的master\",{\"0\":{\"326\":1}}],[\"选择合适的操作函数来处理底层的数据结构\",{\"1\":{\"468\":1}}],[\"选择不同的编码方式\",{\"1\":{\"466\":1,\"467\":1}}],[\"选择不同的实现\",{\"1\":{\"459\":1}}],[\"选择指定的数据库\",{\"1\":{\"361\":1}}],[\"选择库\",{\"1\":{\"351\":1}}],[\"选择依据是这样\",{\"1\":{\"326\":1}}],[\"选择使用auto\",{\"1\":{\"207\":1}}],[\"客户机负责完成与用户的交互任务\",{\"1\":{\"421\":1}}],[\"客户机\",{\"1\":{\"421\":2}}],[\"客户端写缓存区\",{\"1\":{\"462\":1}}],[\"客户端中有缓冲区用来读和写\",{\"1\":{\"462\":1}}],[\"客户端可读\",{\"1\":{\"460\":1}}],[\"客户端可以订阅任意数量的频道\",{\"1\":{\"381\":1}}],[\"客户端缓存\",{\"1\":{\"421\":1}}],[\"客户端的整合\",{\"1\":{\"358\":1}}],[\"客户端的服务发现来源\",{\"1\":{\"324\":1}}],[\"客户端\",{\"1\":{\"349\":1,\"408\":1,\"421\":1,\"422\":1}}],[\"客户端请求可以访问集群任意节点\",{\"1\":{\"337\":1}}],[\"客户端请求\",{\"1\":{\"304\":1}}],[\"客户端连接服务端时\",{\"1\":{\"202\":1}}],[\"客户端断开连接\",{\"1\":{\"143\":1}}],[\"客户端才进入连接关闭状态\",{\"1\":{\"17\":1}}],[\"客户端收到来自服务端的连接释放报文段\",{\"1\":{\"17\":1}}],[\"客户端也可以接受到数据\",{\"1\":{\"17\":1}}],[\"客户端久久未收到来自服务端的确认报文段\",{\"1\":{\"16\":1}}],[\"客户端向服务端发起连接请求\",{\"1\":{\"15\":1}}],[\"客观下线\",{\"1\":{\"325\":1}}],[\"充当\",{\"1\":{\"324\":1}}],[\"充分利用\",{\"1\":{\"304\":1,\"404\":1}}],[\"监视一个\",{\"1\":{\"399\":2}}],[\"监测彼此健康状态\",{\"1\":{\"337\":1}}],[\"监控\",{\"1\":{\"324\":1,\"328\":1}}],[\"监听fd\",{\"1\":{\"462\":1}}],[\"监听tcp端口\",{\"1\":{\"462\":1}}],[\"监听的\",{\"1\":{\"406\":1}}],[\"监听\",{\"1\":{\"15\":1,\"462\":1}}],[\"慢慢迁移到新的哈希表中\",{\"1\":{\"438\":1}}],[\"慢\",{\"1\":{\"321\":1}}],[\"慢查询日志主要就是为了记录那些查询时间较长的sql语句\",{\"1\":{\"227\":1}}],[\"慢查询日志记录了所有执行时间超过指定参数\",{\"1\":{\"227\":1}}],[\"慢查询日志\",{\"0\":{\"227\":1}}],[\"很难受\",{\"1\":{\"516\":1}}],[\"很明显它是需要预留空间的\",{\"1\":{\"441\":1}}],[\"很不方便\",{\"1\":{\"368\":1}}],[\"很多人也说它是\",{\"1\":{\"363\":1}}],[\"很多数据都查不到从而查数据库\",{\"1\":{\"272\":1}}],[\"很快\",{\"1\":{\"321\":1}}],[\"定时删除\",{\"1\":{\"455\":1}}],[\"定时对整个内存做快照\",{\"1\":{\"321\":1}}],[\"定义\",{\"1\":{\"506\":1,\"526\":1,\"529\":1,\"536\":1,\"538\":1}}],[\"定义所需填充数组\",{\"1\":{\"488\":1}}],[\"定义集合\",{\"1\":{\"422\":1}}],[\"定义类型别名\",{\"1\":{\"405\":1}}],[\"定义了一套操作关系型数据库的统一标准\",{\"1\":{\"104\":1}}],[\"定义单链表节点类型\",{\"1\":{\"37\":1}}],[\"定义线性表的最大容量\",{\"1\":{\"36\":1}}],[\"阈值也可以在\",{\"1\":{\"320\":1}}],[\"刷盘时机\",{\"1\":{\"320\":1}}],[\"刷新脏页到磁盘的线程\",{\"1\":{\"73\":1}}],[\"追加一段字符串\",{\"1\":{\"427\":1}}],[\"追加文件\",{\"1\":{\"320\":1}}],[\"追究源头\",{\"1\":{\"3\":1}}],[\"技术\",{\"1\":{\"319\":1}}],[\"磁盘\",{\"1\":{\"364\":1}}],[\"磁盘空间相对廉价\",{\"1\":{\"319\":1}}],[\"磁盘结构\",{\"0\":{\"65\":1},\"1\":{\"65\":1}}],[\"压缩列表\",{\"1\":{\"466\":1}}],[\"压缩列表ziplist\",{\"0\":{\"440\":1},\"1\":{\"444\":1}}],[\"压缩\",{\"1\":{\"319\":1,\"448\":1}}],[\"压缩也会消耗\",{\"1\":{\"319\":1}}],[\"压力\",{\"1\":{\"279\":1,\"301\":1}}],[\"停机时会执行一次\",{\"1\":{\"319\":1}}],[\"停止\",{\"1\":{\"306\":1,\"370\":1}}],[\"恢复\",{\"1\":{\"319\":1}}],[\"恢复数据\",{\"1\":{\"319\":1}}],[\"恢复原始配置\",{\"1\":{\"295\":1}}],[\"搭建哨兵集群\",{\"0\":{\"329\":1}}],[\"搭建分片集群\",{\"0\":{\"337\":1},\"1\":{\"318\":1}}],[\"搭建主从集群\",{\"1\":{\"318\":1}}],[\"搭建主从架构\",{\"0\":{\"293\":1}}],[\"哨兵和\",{\"1\":{\"358\":1}}],[\"哨兵的结构和作用如下\",{\"1\":{\"324\":1}}],[\"哨兵的作用\",{\"0\":{\"324\":1}}],[\"哨兵的作用和工作原理\",{\"0\":{\"323\":1}}],[\"哨兵\",{\"1\":{\"318\":1}}],[\"宕机等\",{\"1\":{\"385\":1}}],[\"宕机会发生什么\",{\"1\":{\"345\":1}}],[\"宕机恢复速度\",{\"1\":{\"321\":1}}],[\"宕机\",{\"1\":{\"318\":1,\"345\":1}}],[\"宕机时尽快实现故障恢复\",{\"1\":{\"301\":1}}],[\"故此我们从\",{\"1\":{\"511\":1}}],[\"故此需要判断边界条件\",{\"1\":{\"511\":1}}],[\"故此所有的知识点也仅代表了当前时刻自己对知识的掌握\",{\"1\":{\"1\":1}}],[\"故redis\",{\"1\":{\"461\":1}}],[\"故就演示mac环境下的图形化客户端\",{\"1\":{\"373\":1}}],[\"故我们在centos操作系统内进行安装\",{\"1\":{\"366\":1}}],[\"故我们在配置\",{\"1\":{\"319\":1}}],[\"故障转移步骤有哪些\",{\"1\":{\"328\":1}}],[\"故障转移\",{\"0\":{\"345\":1},\"1\":{\"328\":1}}],[\"故障转移的步骤如下\",{\"1\":{\"327\":1}}],[\"故障\",{\"1\":{\"324\":1,\"326\":1}}],[\"故障恢复问题\",{\"1\":{\"318\":1}}],[\"~\",{\"1\":{\"311\":1,\"387\":1,\"401\":1,\"454\":1,\"456\":1}}],[\"正向双指针\",{\"1\":{\"543\":1}}],[\"正则表达式匹配\",{\"1\":{\"311\":1}}],[\"正确\",{\"1\":{\"3\":1}}],[\"路径占位符\",{\"1\":{\"311\":2}}],[\"响应式编程全套\",{\"1\":{\"548\":1}}],[\"响应数据由\",{\"1\":{\"309\":1}}],[\"响应类型\",{\"1\":{\"309\":1}}],[\"拦截\",{\"1\":{\"308\":1}}],[\"得到第\",{\"1\":{\"529\":2}}],[\"得到返回值\",{\"1\":{\"526\":1,\"529\":1}}],[\"得到响应结果\",{\"1\":{\"462\":1}}],[\"得到通知说\",{\"1\":{\"408\":1}}],[\"得到的结果就如图所示\",{\"1\":{\"352\":1}}],[\"得到的结果就是\",{\"1\":{\"343\":1}}],[\"得到的就是master的数量\",{\"1\":{\"341\":1}}],[\"得到的数据为空处理\",{\"1\":{\"307\":1}}],[\"得到数据的记录值\",{\"1\":{\"125\":1}}],[\"放入redis连接池失败\",{\"1\":{\"307\":1}}],[\"放一个数字\",{\"1\":{\"221\":1}}],[\"释放原来的dict\",{\"1\":{\"438\":2}}],[\"释放原哈希表的内存空间\",{\"1\":{\"437\":1}}],[\"释放连接\",{\"1\":{\"422\":1}}],[\"释放redis连接api\",{\"1\":{\"307\":1}}],[\"释放锁\",{\"1\":{\"143\":1,\"272\":1}}],[\"看看到底数据是否存储在redis服务器中\",{\"1\":{\"352\":1}}],[\"看看是否可以将两个页合并以优化空间使用\",{\"1\":{\"206\":1}}],[\"看到里面的nginx目录了吗\",{\"1\":{\"305\":1}}],[\"仓库\",{\"1\":{\"305\":1}}],[\"你将从下标为\",{\"1\":{\"532\":2}}],[\"你可以设计实现一个时间复杂度为\",{\"1\":{\"541\":1}}],[\"你可以选择从下标为\",{\"1\":{\"532\":1}}],[\"你可以在你的\",{\"1\":{\"305\":1}}],[\"你拥有的饼干数量和尺寸都足以让所有孩子满足\",{\"1\":{\"491\":1}}],[\"你有多少种不同的方法可以爬到楼顶呢\",{\"1\":{\"519\":1}}],[\"你有两个孩子和三块小饼干\",{\"1\":{\"491\":1}}],[\"你有三个孩子和两块小饼干\",{\"1\":{\"491\":1}}],[\"你只能让胃口值是1的孩子满足\",{\"1\":{\"491\":1}}],[\"你的目标是尽可能满足越多数量的孩子\",{\"1\":{\"491\":1}}],[\"你返回所有和为\",{\"1\":{\"477\":1}}],[\"你就可以使用下面这个命令来设定缓存的大小了\",{\"1\":{\"273\":1}}],[\"甚至于对远程后端诸如\",{\"1\":{\"304\":1}}],[\"乃至\",{\"1\":{\"304\":1}}],[\"团队自主开发\",{\"1\":{\"304\":1}}],[\"库\",{\"1\":{\"304\":1,\"459\":1}}],[\"平常用\",{\"1\":{\"439\":1}}],[\"平台\",{\"1\":{\"304\":1}}],[\"平均值\",{\"1\":{\"189\":1}}],[\"平均情况\",{\"1\":{\"36\":3}}],[\"安装完redis以后\",{\"1\":{\"368\":1}}],[\"安装redis\",{\"0\":{\"366\":1},\"1\":{\"366\":1}}],[\"安装依赖\",{\"1\":{\"341\":1}}],[\"安装opm工具\",{\"1\":{\"305\":1}}],[\"安装openresty仓库\",{\"1\":{\"305\":1}}],[\"安装openresty\",{\"0\":{\"304\":1},\"1\":{\"305\":1}}],[\"安装开发库\",{\"1\":{\"305\":1}}],[\"安装\",{\"0\":{\"305\":1}}],[\"安全性要求不高\",{\"1\":{\"364\":1}}],[\"安全\",{\"1\":{\"167\":1}}],[\"什么叫渐进式\",{\"1\":{\"438\":1}}],[\"什么是nosql\",{\"0\":{\"363\":1}}],[\"什么是tcp连接\",{\"0\":{\"14\":1}}],[\"什么时候执行增量同步\",{\"1\":{\"302\":1}}],[\"什么时候执行全量同步\",{\"1\":{\"302\":1}}],[\"上限的问题\",{\"1\":{\"410\":1}}],[\"上图解析\",{\"1\":{\"385\":1}}],[\"上图为innodb的内存架构\",{\"1\":{\"60\":1}}],[\"上述仅说明了操作\",{\"1\":{\"356\":1}}],[\"上\",{\"1\":{\"343\":1}}],[\"上同步数据\",{\"1\":{\"327\":1}}],[\"上的\",{\"1\":{\"301\":1}}],[\"限制\",{\"1\":{\"448\":1}}],[\"限制压缩\",{\"0\":{\"448\":1}}],[\"限制长度\",{\"1\":{\"385\":1,\"387\":1}}],[\"限制一个\",{\"1\":{\"301\":1}}],[\"限制该字段的数据不能为null\",{\"1\":{\"47\":1}}],[\"适当提高\",{\"1\":{\"301\":1}}],[\"适配器\",{\"1\":{\"281\":1}}],[\"启用无磁盘复制\",{\"1\":{\"301\":1}}],[\"启动一个新的\",{\"1\":{\"344\":1}}],[\"启动后\",{\"1\":{\"332\":1}}],[\"启动nginx\",{\"1\":{\"306\":1}}],[\"启动和运行\",{\"0\":{\"306\":1}}],[\"启动命令\",{\"1\":{\"296\":1,\"332\":1}}],[\"启动\",{\"0\":{\"296\":1,\"332\":1,\"340\":1},\"1\":{\"370\":1}}],[\"断开时间过久\",{\"1\":{\"301\":1}}],[\"断电问题的影响\",{\"1\":{\"236\":1}}],[\"冲去后同步\",{\"1\":{\"301\":1}}],[\"收缩大小为第一个大于等于used的2n\",{\"1\":{\"439\":1}}],[\"收缩\",{\"1\":{\"437\":1}}],[\"收到\",{\"1\":{\"399\":1}}],[\"收到接受的命令\",{\"1\":{\"300\":1}}],[\"收费\",{\"1\":{\"106\":1}}],[\"拒绝增量同步\",{\"1\":{\"300\":1}}],[\"偏移量不存在\",{\"1\":{\"397\":1}}],[\"偏移量从0开始\",{\"1\":{\"397\":1}}],[\"偏移量和\",{\"1\":{\"345\":1}}],[\"偏移量\",{\"1\":{\"300\":1}}],[\"节省内存是相对于普通的list来说的\",{\"1\":{\"441\":1}}],[\"节省存储空间\",{\"1\":{\"134\":1}}],[\"节点按照\",{\"1\":{\"453\":1}}],[\"节点可能包含多个指针\",{\"1\":{\"451\":1}}],[\"节点采用\",{\"1\":{\"449\":1}}],[\"节点是连续存在的\",{\"1\":{\"443\":1}}],[\"节点中保存前一个节点的大小长度\",{\"1\":{\"443\":1}}],[\"节点分配插槽\",{\"1\":{\"344\":1}}],[\"节点映射到\",{\"1\":{\"343\":1}}],[\"节点心跳失败的超时时间\",{\"1\":{\"339\":1}}],[\"节点发送\",{\"1\":{\"327\":1}}],[\"节点发现某实例未在规定时间响应\",{\"1\":{\"325\":1}}],[\"节点\",{\"1\":{\"326\":1,\"327\":1,\"330\":1,\"337\":1,\"344\":2,\"345\":1}}],[\"节点与\",{\"1\":{\"326\":1}}],[\"节点宕机怎么办\",{\"1\":{\"322\":1}}],[\"节点宕机恢复以后可以找\",{\"1\":{\"322\":1}}],[\"节点同步数据\",{\"1\":{\"322\":1}}],[\"节点断开的时间长短\",{\"1\":{\"326\":1}}],[\"节点断开又恢复\",{\"1\":{\"302\":1}}],[\"节点断开时间太久\",{\"1\":{\"302\":1}}],[\"节点时\",{\"1\":{\"302\":1}}],[\"节点第一次连接\",{\"1\":{\"302\":1}}],[\"节点数量\",{\"1\":{\"301\":1}}],[\"节点判断\",{\"1\":{\"300\":1}}],[\"节点请求增量同步\",{\"1\":{\"300\":1}}],[\"节点的运行\",{\"1\":{\"326\":1}}],[\"节点的\",{\"1\":{\"300\":1,\"326\":2}}],[\"测试访问\",{\"1\":{\"334\":1}}],[\"测试\",{\"0\":{\"298\":1,\"333\":1,\"342\":1}}],[\"现在数组中每个数字都保存在\",{\"1\":{\"430\":1}}],[\"现在在存储数据之前需要进行手动序列化\",{\"1\":{\"355\":1}}],[\"现在三个实例还没有任何关系\",{\"1\":{\"297\":1}}],[\"现在触发器还只支持行级触发\",{\"1\":{\"153\":1}}],[\"逐个遍历db中的bucket\",{\"1\":{\"455\":2}}],[\"逐个遍历db\",{\"1\":{\"455\":2}}],[\"逐个搬运元素到新的位置\",{\"1\":{\"432\":1}}],[\"逐个发送给\",{\"1\":{\"302\":1}}],[\"逐个拷贝\",{\"1\":{\"295\":1,\"331\":1}}],[\"逐一执行\",{\"1\":{\"295\":1}}],[\"格式如下\",{\"1\":{\"295\":1,\"319\":1,\"341\":1}}],[\"格式统一\",{\"1\":{\"108\":1}}],[\"虚拟机本身有多个ip\",{\"1\":{\"295\":1}}],[\"虚拟机的任意目录下\",{\"1\":{\"287\":1}}],[\"管道组合命令\",{\"1\":{\"295\":1,\"331\":1}}],[\"配置类\",{\"0\":{\"353\":1}}],[\"配置jedis连接池\",{\"1\":{\"347\":1}}],[\"配置读写分离\",{\"1\":{\"346\":1}}],[\"配置分片集群地址\",{\"1\":{\"346\":1}}],[\"配置项\",{\"1\":{\"320\":1}}],[\"配置文件所在目录就是redis安装目录\",{\"1\":{\"369\":1}}],[\"配置文件所在目录也就是工作目录\",{\"1\":{\"295\":1,\"331\":1}}],[\"配置文件\",{\"1\":{\"334\":1,\"360\":1}}],[\"配置文件来开启\",{\"1\":{\"320\":1}}],[\"配置nginx的环境变量\",{\"1\":{\"305\":1}}],[\"配置完毕以后\",{\"1\":{\"227\":1}}],[\"准备实例和配置\",{\"0\":{\"295\":1,\"331\":1,\"339\":1}}],[\"角色\",{\"1\":{\"294\":1,\"338\":1}}],[\"角标访问\",{\"1\":{\"288\":1}}],[\"模式为fast\",{\"1\":{\"455\":1}}],[\"模式为\",{\"1\":{\"455\":1}}],[\"模式中如何解决这些问题\",{\"1\":{\"410\":1}}],[\"模式中的\",{\"1\":{\"406\":1}}],[\"模式的问题\",{\"1\":{\"410\":1}}],[\"模式的存在的三个问题\",{\"1\":{\"410\":1}}],[\"模式的\",{\"1\":{\"409\":1}}],[\"模式的改进\",{\"1\":{\"407\":1}}],[\"模式最好结合非阻塞\",{\"1\":{\"408\":1}}],[\"模式可能出现的惊群现象\",{\"1\":{\"408\":1}}],[\"模式避免了\",{\"1\":{\"408\":1}}],[\"模式是对\",{\"1\":{\"407\":1}}],[\"模式做了简单改进\",{\"1\":{\"406\":1}}],[\"模式对\",{\"1\":{\"406\":1}}],[\"模拟法\",{\"0\":{\"488\":1}}],[\"模拟分片集群\",{\"1\":{\"338\":1}}],[\"模拟主从集群\",{\"1\":{\"294\":1}}],[\"模型虽然很简单\",{\"1\":{\"412\":1}}],[\"模型中\",{\"1\":{\"403\":1,\"412\":1}}],[\"模型\",{\"1\":{\"304\":1}}],[\"模块中的aof缓冲区以及客户端状态中的输入缓冲区\",{\"1\":{\"428\":1}}],[\"模块中\",{\"1\":{\"428\":1}}],[\"模块支持\",{\"1\":{\"309\":1}}],[\"模块\",{\"1\":{\"304\":2,\"307\":1,\"309\":2}}],[\"模糊匹配\",{\"1\":{\"187\":1}}],[\"模糊查询\",{\"1\":{\"129\":1}}],[\"共性较少\",{\"1\":{\"469\":1}}],[\"共包含\",{\"1\":{\"466\":1}}],[\"共包含三个节点\",{\"1\":{\"294\":1}}],[\"共有\",{\"1\":{\"465\":1}}],[\"共计\",{\"1\":{\"430\":1}}],[\"共1024个bit位\",{\"1\":{\"405\":1}}],[\"共\",{\"1\":{\"343\":1}}],[\"共享对象只能被字典和双向链表这类能带有指针的数据结构使用\",{\"1\":{\"469\":1}}],[\"共享内存空间\",{\"1\":{\"319\":1}}],[\"共享字典\",{\"1\":{\"307\":1}}],[\"共享\",{\"1\":{\"144\":1}}],[\"共享锁\",{\"1\":{\"80\":1,\"147\":1}}],[\"版本后新加的\",{\"1\":{\"446\":1}}],[\"版本中引入了多线程\",{\"1\":{\"461\":1}}],[\"版本中\",{\"1\":{\"421\":1}}],[\"版本中成为与\",{\"1\":{\"421\":1}}],[\"版本引入了\",{\"1\":{\"421\":1}}],[\"版本之后\",{\"1\":{\"416\":1}}],[\"版本之前\",{\"1\":{\"416\":1}}],[\"版本新增加的数据结构\",{\"1\":{\"385\":1}}],[\"版本通过内嵌支持\",{\"1\":{\"382\":1}}],[\"版本以后被称为\",{\"1\":{\"293\":1}}],[\"版本链数据访问规则\",{\"0\":{\"86\":1}}],[\"版本链\",{\"0\":{\"84\":1}}],[\"布尔表达式为\",{\"1\":{\"290\":2}}],[\"布尔表达式\",{\"1\":{\"290\":1}}],[\"布隆过滤\",{\"1\":{\"270\":1}}],[\"之所以叫做动态字符串\",{\"1\":{\"427\":1}}],[\"之前的版本是\",{\"1\":{\"446\":1}}],[\"之前加上了一段字符\",{\"1\":{\"352\":1}}],[\"之前\",{\"1\":{\"304\":1,\"356\":1}}],[\"之后的元素到\",{\"1\":{\"432\":1}}],[\"之后的命令给\",{\"1\":{\"302\":1}}],[\"之后的代码会被执行\",{\"1\":{\"290\":1}}],[\"之间的随机数\",{\"1\":{\"453\":1,\"456\":1}}],[\"之间的关系\",{\"1\":{\"381\":1}}],[\"之间的同步\",{\"1\":{\"300\":1}}],[\"之间通过\",{\"1\":{\"337\":1}}],[\"之间写入数据有丢失的风险\",{\"1\":{\"319\":1}}],[\"之间相差的天数\",{\"1\":{\"55\":1}}],[\"紧跟在\",{\"1\":{\"290\":1}}],[\"构造表达式\",{\"1\":{\"288\":1}}],[\"构造一个空的线性表\",{\"1\":{\"35\":1}}],[\"里面的元素\",{\"1\":{\"425\":1}}],[\"里面可以缓存磁盘上经常操作的真实数据\",{\"1\":{\"61\":1}}],[\"里\",{\"1\":{\"288\":1}}],[\"初识\",{\"0\":{\"286\":1}}],[\"初始大小为16mb\",{\"1\":{\"69\":1}}],[\"初始化\",{\"1\":{\"526\":1,\"529\":1,\"536\":1,\"538\":1}}],[\"初始化默认值\",{\"1\":{\"488\":1}}],[\"初始化服务\",{\"1\":{\"462\":1}}],[\"初始化为空哈希表\",{\"1\":{\"438\":2}}],[\"初始化为空链表\",{\"1\":{\"37\":1}}],[\"初始化表\",{\"1\":{\"35\":1}}],[\"规则选择\",{\"1\":{\"283\":1}}],[\"规范了基于\",{\"1\":{\"281\":1}}],[\"原文地址\",{\"1\":{\"281\":1}}],[\"原子性\",{\"1\":{\"74\":1,\"86\":1,\"257\":1}}],[\"原子类型\",{\"1\":{\"32\":1}}],[\"持久化文件存放目录\",{\"1\":{\"339\":1}}],[\"持久化方式\",{\"1\":{\"321\":1}}],[\"持久性\",{\"1\":{\"74\":1,\"86\":1,\"257\":1}}],[\"持续计算缓存的访问统计指标\",{\"1\":{\"281\":1}}],[\"或下标为\",{\"1\":{\"532\":1}}],[\"或\",{\"1\":{\"519\":1}}],[\"或水平移动两个格子且垂直移动一个格子\",{\"1\":{\"514\":1}}],[\"或这些\",{\"1\":{\"399\":1}}],[\"或多个\",{\"1\":{\"399\":2}}],[\"或移除\",{\"1\":{\"281\":1}}],[\"或者消除对一个对象的引用之后\",{\"1\":{\"470\":1}}],[\"或者slaveof\",{\"1\":{\"297\":1}}],[\"或者一键修改\",{\"1\":{\"295\":1}}],[\"或者在空闲时间完成对失效数据的驱逐\",{\"1\":{\"283\":1}}],[\"或者有些sql本应该很快执行完毕\",{\"1\":{\"227\":1}}],[\"或者\",{\"1\":{\"166\":1,\"173\":1,\"187\":4,\"229\":2,\"256\":1,\"288\":1,\"340\":1,\"417\":1,\"437\":1}}],[\"或者四次\",{\"0\":{\"16\":1}}],[\"驱逐\",{\"1\":{\"281\":1}}],[\"直至dict\",{\"1\":{\"438\":1}}],[\"直至数据处理完成\",{\"1\":{\"408\":1}}],[\"直到内核处理才开始停止轮训\",{\"1\":{\"403\":1}}],[\"直到它们被从缓存当中手动移除\",{\"1\":{\"281\":1}}],[\"直接将数组的数据填写\",{\"1\":{\"486\":1}}],[\"直接将数据保存在\",{\"1\":{\"415\":1}}],[\"直接跳过即可\",{\"1\":{\"482\":2}}],[\"直接结束并返回失败\",{\"1\":{\"432\":1}}],[\"直接读一行\",{\"1\":{\"422\":1}}],[\"直接拷贝到用户空间的指定位置\",{\"1\":{\"410\":1}}],[\"直接能定位到就绪的\",{\"1\":{\"404\":1}}],[\"直接执行第\",{\"1\":{\"345\":1}}],[\"直接进入下一次循环\",{\"1\":{\"251\":2}}],[\"直接进行函数的调用即可\",{\"1\":{\"239\":1}}],[\"直接进行查询即可\",{\"1\":{\"210\":1}}],[\"直接在\",{\"1\":{\"442\":1}}],[\"直接在select语句之前加上关键字\",{\"1\":{\"229\":1}}],[\"直接在mysql官方网站\",{\"1\":{\"105\":1}}],[\"直接按行进行累加\",{\"1\":{\"221\":3}}],[\"直接使用索引对相关的信息进行查询\",{\"1\":{\"213\":1}}],[\"直接简写为limit\",{\"1\":{\"192\":1}}],[\"场景实战\",{\"1\":{\"548\":1}}],[\"场景\",{\"1\":{\"280\":2}}],[\"处理函数不能及时处理可能导致信号队列溢出\",{\"1\":{\"411\":1}}],[\"处理的每一个写命令都会记录在\",{\"1\":{\"320\":1}}],[\"处理后返回数据\",{\"1\":{\"308\":1}}],[\"处理\",{\"1\":{\"279\":1,\"462\":1}}],[\"处放入\",{\"1\":{\"36\":1}}],[\"请你\",{\"1\":{\"541\":1}}],[\"请你计算并返回达到楼梯顶部的最低花费\",{\"1\":{\"532\":1}}],[\"请计算\",{\"1\":{\"496\":1}}],[\"请\",{\"1\":{\"477\":1}}],[\"请求时\",{\"1\":{\"404\":1}}],[\"请求头\",{\"1\":{\"311\":2}}],[\"请求\",{\"1\":{\"308\":1,\"402\":1}}],[\"请求要经过\",{\"1\":{\"279\":1}}],[\"请在创建表时使用not\",{\"1\":{\"134\":1}}],[\"店铺详情查询的缓存\",{\"1\":{\"274\":1}}],[\"店铺类型的查询缓存\",{\"1\":{\"274\":1}}],[\"好\",{\"1\":{\"274\":1}}],[\"差异\",{\"1\":{\"404\":1}}],[\"差别在于无数据时的处理方式\",{\"1\":{\"404\":1}}],[\"差集\",{\"1\":{\"379\":1,\"418\":1}}],[\"差集等功能\",{\"1\":{\"379\":1}}],[\"差\",{\"1\":{\"274\":1}}],[\"编号\",{\"1\":{\"466\":1,\"467\":1}}],[\"编码方式\",{\"0\":{\"466\":1},\"1\":{\"456\":1,\"464\":1,\"466\":1,\"467\":1}}],[\"编码分为字符串和整数两种类型\",{\"1\":{\"442\":1}}],[\"编码\",{\"1\":{\"415\":2,\"416\":2,\"417\":2,\"418\":2,\"432\":1}}],[\"编程语言客户端也有很多种\",{\"1\":{\"374\":1}}],[\"编程语言客户端\",{\"0\":{\"374\":1},\"1\":{\"371\":1}}],[\"编程语言中的函数\",{\"1\":{\"239\":1}}],[\"编写测试类\",{\"1\":{\"360\":1}}],[\"编写测试类并与redis建立连接\",{\"1\":{\"351\":1}}],[\"编写一个\",{\"0\":{\"353\":1},\"1\":{\"354\":1}}],[\"编写一个操作数据的方法\",{\"1\":{\"351\":1}}],[\"编写item\",{\"0\":{\"310\":1}}],[\"编写的函数\",{\"1\":{\"288\":1}}],[\"编写业务逻辑\",{\"1\":{\"274\":1}}],[\"下图展示了骑士从某个格子出发可能的八种行动路线\",{\"1\":{\"514\":1}}],[\"下图展示了频道\",{\"1\":{\"381\":1}}],[\"下一个\",{\"1\":{\"436\":1}}],[\"下一次启动\",{\"1\":{\"319\":1}}],[\"下标在bitmap中成为偏移量\",{\"1\":{\"397\":1}}],[\"下次查询时更新缓存\",{\"1\":{\"274\":2}}],[\"下面\",{\"1\":{\"309\":2}}],[\"下面是\",{\"1\":{\"288\":1}}],[\"下面是innodb架构图\",{\"1\":{\"59\":1}}],[\"下面我们来具体举例说明\",{\"1\":{\"21\":1}}],[\"兼顾访问性能和内存空间开销\",{\"1\":{\"273\":1}}],[\"兼容和互斥\",{\"1\":{\"147\":1}}],[\"兼容\",{\"1\":{\"145\":1}}],[\"到第⼀层楼梯状态推导出来\",{\"1\":{\"521\":1}}],[\"到达第\",{\"1\":{\"536\":1,\"538\":1}}],[\"到达下标为\",{\"1\":{\"532\":5}}],[\"到达楼梯顶部\",{\"1\":{\"532\":2}}],[\"到达左边网格的路径数\",{\"1\":{\"511\":1}}],[\"到达左边网格的路径数这两个数值\",{\"1\":{\"511\":1}}],[\"到达上边网格的路径数\",{\"1\":{\"511\":1}}],[\"到达当前网格的路径数\",{\"1\":{\"511\":1}}],[\"到底是单线程还是多线程\",{\"1\":{\"458\":1}}],[\"到期后就立刻删除\",{\"1\":{\"455\":1}}],[\"到期后\",{\"1\":{\"455\":1}}],[\"到期后自动删除缓存\",{\"1\":{\"274\":1}}],[\"到期就立刻删除呢\",{\"1\":{\"454\":1}}],[\"到内核空间\",{\"1\":{\"410\":1}}],[\"到之前的集群\",{\"1\":{\"344\":1}}],[\"到\",{\"1\":{\"273\":1,\"302\":2,\"453\":1,\"541\":1}}],[\"我自己在做的时候就忘记了这种情况\",{\"1\":{\"516\":1}}],[\"我的名字是\",{\"1\":{\"360\":2}}],[\"我会建议把缓存容量设置为总数据量的\",{\"1\":{\"273\":1}}],[\"我们直接在一层for循环中进行模拟填数\",{\"1\":{\"486\":1}}],[\"我们的操作都是使用指令进行\",{\"1\":{\"464\":1}}],[\"我们的应用都需要通过\",{\"1\":{\"401\":1}}],[\"我们要存储大量数据\",{\"1\":{\"444\":1}}],[\"我们必须限制\",{\"1\":{\"444\":1}}],[\"我们假设没有特殊字符\",{\"1\":{\"422\":1}}],[\"我们调用\",{\"1\":{\"408\":1}}],[\"我们使用一个固定指针k\",{\"1\":{\"481\":1}}],[\"我们使用\",{\"1\":{\"386\":1}}],[\"我们使用的是redis6\",{\"1\":{\"341\":1}}],[\"我们来实际测试一下\",{\"1\":{\"354\":1}}],[\"我们自定义的配置类中\",{\"1\":{\"353\":1}}],[\"我们实现了一个简单的案例\",{\"1\":{\"352\":1}}],[\"我们不必关注与资源的获取和释放等问题\",{\"1\":{\"347\":1}}],[\"我们打开3个ssh窗口\",{\"1\":{\"296\":1,\"332\":1}}],[\"我们一键完成修改\",{\"1\":{\"295\":1}}],[\"我们创建三个文件夹\",{\"1\":{\"295\":1,\"331\":1}}],[\"我们搭建的主从集群结构如图\",{\"1\":{\"294\":1}}],[\"我们把缓存分为两类\",{\"1\":{\"280\":1}}],[\"我们能够找到查询时间较低的sql\",{\"1\":{\"227\":1}}],[\"我们将饼干大小和孩子胃口进行排序\",{\"1\":{\"492\":1}}],[\"我们将这种页面分裂的现象\",{\"1\":{\"205\":1}}],[\"我们将其抽取出来\",{\"1\":{\"179\":1}}],[\"我们分别从\",{\"1\":{\"205\":1}}],[\"我们可以将这个饼干\",{\"1\":{\"491\":1}}],[\"我们可以给链表增加多级的索引指针\",{\"1\":{\"450\":1}}],[\"我们可以创建多个\",{\"1\":{\"444\":1}}],[\"我们可以这样定义key\",{\"1\":{\"376\":1}}],[\"我们可以通过自定义\",{\"1\":{\"352\":1}}],[\"我们可以根据这个数据来判断我们主要对那些操作进行优化\",{\"1\":{\"226\":1}}],[\"我们可以直接按照表的操作来操作视图\",{\"1\":{\"163\":1}}],[\"我们可以使用new和old两个关键字来调用执行后和执行前的数据\",{\"1\":{\"159\":1}}],[\"我们可以在备份时加上参数\",{\"1\":{\"140\":1}}],[\"我们可以在缓冲池中进行合并处理\",{\"1\":{\"62\":1}}],[\"我们在支付完对应的花费后\",{\"1\":{\"534\":1}}],[\"我们在操作对应的\",{\"1\":{\"359\":1}}],[\"我们在使用redis时\",{\"1\":{\"220\":1}}],[\"我们在使用的时候可以直接使用别名进行子查询\",{\"1\":{\"162\":1}}],[\"我们在下一章节的主键优化里详细说明\",{\"1\":{\"201\":1}}],[\"我们在对数据的查询时\",{\"1\":{\"125\":1}}],[\"我们在连接查询的时候\",{\"1\":{\"93\":1}}],[\"我们需要知道dp\",{\"1\":{\"534\":1}}],[\"我们需要得到到达楼梯顶部的时候\",{\"1\":{\"534\":1}}],[\"我们需要先掌握一些最基础的通用指令\",{\"1\":{\"361\":1}}],[\"我们需要执行命令来创建集群\",{\"1\":{\"341\":1}}],[\"我们需要了解什么是斐波那契数列\",{\"1\":{\"498\":1}}],[\"我们需要了解它是干什么的\",{\"1\":{\"304\":1}}],[\"我们需要了解到需要多表查询的场景\",{\"1\":{\"89\":1}}],[\"我们需要在redis\",{\"1\":{\"295\":1}}],[\"我们需要明确一些基本概念\",{\"1\":{\"104\":1}}],[\"我们首先需要了解一个简单的概念\",{\"1\":{\"93\":1}}],[\"我们就称为删除\",{\"1\":{\"50\":1}}],[\"我们根据方法论的步骤进行解答\",{\"1\":{\"23\":1}}],[\"我们根据方法论\",{\"1\":{\"22\":1}}],[\"我们知道tcp连接是可靠的\",{\"1\":{\"16\":1}}],[\"被访问都计数\",{\"1\":{\"456\":1}}],[\"被访问完以后\",{\"1\":{\"273\":1}}],[\"被哈希函数映射到同一个位置的情况\",{\"1\":{\"435\":1}}],[\"被其他命令所改动\",{\"1\":{\"399\":1}}],[\"被该注解修饰的方法会在每次执行其他方法后执行\",{\"1\":{\"351\":1}}],[\"被该注解修饰的方法每次执行其他方法前自动执行\",{\"1\":{\"351\":1}}],[\"被修改\",{\"1\":{\"319\":3}}],[\"被反复执行的程序被称为循环体\",{\"1\":{\"289\":1}}],[\"被使用过的page\",{\"1\":{\"61\":1}}],[\"被使用的page\",{\"1\":{\"61\":1}}],[\"突然失效\",{\"1\":{\"272\":1}}],[\"利用两个\",{\"1\":{\"454\":1}}],[\"利用链表解决了\",{\"1\":{\"410\":1}}],[\"利用插槽机制实现动态扩容\",{\"1\":{\"318\":1}}],[\"利用redis\",{\"1\":{\"298\":3}}],[\"利用\",{\"1\":{\"271\":1,\"274\":1,\"283\":1,\"318\":1,\"345\":1}}],[\"增删改查效率与红黑树基本一致\",{\"1\":{\"453\":1}}],[\"增或者删较大数据时有可能发生连续更新问题\",{\"1\":{\"444\":1}}],[\"增加了更多数据类型并且支持\",{\"1\":{\"421\":1}}],[\"增加日志缓冲区的大小可以节省磁盘io\",{\"1\":{\"63\":1}}],[\"增量同步\",{\"0\":{\"301\":1},\"1\":{\"302\":1}}],[\"增强id的复杂度\",{\"1\":{\"270\":1}}],[\"额外的内存消耗\",{\"1\":{\"270\":1}}],[\"造成了极大的资源浪费\",{\"1\":{\"354\":1}}],[\"造成资源的浪费\",{\"1\":{\"270\":1}}],[\"造成的影响\",{\"1\":{\"223\":1}}],[\"频繁请求\",{\"1\":{\"270\":1}}],[\"代码仓库\",{\"1\":{\"549\":1}}],[\"代码实现\",{\"0\":{\"535\":1}}],[\"代码code\",{\"0\":{\"500\":1,\"503\":1,\"506\":1,\"523\":1,\"526\":1,\"529\":1}}],[\"代码\",{\"0\":{\"487\":1}}],[\"代码示例\",{\"0\":{\"482\":1,\"494\":1,\"512\":1,\"517\":1}}],[\"代码详情\",{\"1\":{\"311\":1,\"432\":3,\"447\":6}}],[\"代码维护成本\",{\"1\":{\"269\":1}}],[\"代表不压缩\",{\"1\":{\"448\":1}}],[\"代表rehash结束\",{\"1\":{\"438\":1}}],[\"代表是创建集群\",{\"1\":{\"341\":1}}],[\"代表集群操作命令\",{\"1\":{\"341\":1}}],[\"代表所有\",{\"1\":{\"196\":1}}],[\"代表可选参数\",{\"1\":{\"177\":1}}],[\"代表的是当前的事务id\",{\"1\":{\"86\":1}}],[\"黑马程序员\",{\"1\":{\"266\":1}}],[\"博主在学习redis数据库时参考的了黑马程序员出品的\",{\"1\":{\"266\":1}}],[\"博主在学习mysql数据库时参考的了黑马程序员出品的\",{\"1\":{\"171\":1}}],[\"博主在使用redis数据库时\",{\"1\":{\"266\":1}}],[\"菜鸟教程\",{\"1\":{\"266\":1}}],[\"五种数据类型的底层结构关系\",{\"0\":{\"414\":1},\"1\":{\"265\":1}}],[\"集中式完成的\",{\"1\":{\"438\":1}}],[\"集群\",{\"1\":{\"358\":1}}],[\"集群伸缩就是集群节点能够动态的增加和减少\",{\"1\":{\"344\":1}}],[\"集群伸缩\",{\"0\":{\"344\":1}}],[\"集群操作时\",{\"1\":{\"342\":1}}],[\"集群管理以及集成到了redis\",{\"1\":{\"341\":1}}],[\"集群的配置文件名称\",{\"1\":{\"339\":1}}],[\"集群中有多个\",{\"1\":{\"337\":1}}],[\"集群监管下的\",{\"1\":{\"334\":1}}],[\"集群结构\",{\"0\":{\"294\":1,\"330\":1,\"338\":1}}],[\"集群提高服务的可用性\",{\"1\":{\"271\":1}}],[\"集群最佳实践\",{\"0\":{\"278\":1},\"1\":{\"264\":1}}],[\"集合框架\",{\"0\":{\"474\":1}}],[\"集合对象\",{\"1\":{\"469\":2}}],[\"集合对象set\",{\"0\":{\"418\":1}}],[\"集合类型有字典和整数集合两种不同的底层实现方式\",{\"1\":{\"464\":1}}],[\"集合类型的一种实现方式\",{\"1\":{\"430\":1}}],[\"集合\",{\"0\":{\"379\":1},\"1\":{\"33\":1,\"467\":1}}],[\"批处理优化\",{\"0\":{\"267\":1},\"1\":{\"264\":1}}],[\"批量操作在发送\",{\"1\":{\"399\":1}}],[\"批量获取多个hash类型key的field的值\",{\"1\":{\"377\":1}}],[\"批量添加多个string类型的键值对\",{\"1\":{\"376\":1}}],[\"批量添加数据\",{\"1\":{\"180\":1}}],[\"批量插入速度\",{\"1\":{\"236\":1}}],[\"批量插入\",{\"0\":{\"199\":1}}],[\"串行化\",{\"1\":{\"259\":1}}],[\"幻读\",{\"1\":{\"258\":1,\"259\":1}}],[\"属性\",{\"1\":{\"470\":1}}],[\"属性从1个字节变为5个字节\",{\"1\":{\"443\":1}}],[\"属性表示的长度来判断字符串是否结束\",{\"1\":{\"425\":1}}],[\"属性的值有两种\",{\"1\":{\"256\":1}}],[\"属于该类型\",{\"1\":{\"288\":1}}],[\"属于服务器层面\",{\"1\":{\"242\":1}}],[\"属于oracle旗下\",{\"1\":{\"104\":1}}],[\"比如列表对象\",{\"1\":{\"469\":1}}],[\"比如成功时返回的ok\",{\"1\":{\"469\":1}}],[\"比如现在执行lpop命令\",{\"1\":{\"468\":1}}],[\"比如对元素进行添加\",{\"1\":{\"464\":1}}],[\"比如删除一个列表键和删除一个字符串键的操作过程是不一样的\",{\"1\":{\"464\":1}}],[\"比如查找12\",{\"1\":{\"450\":1}}],[\"比如服务端处理客户端socket\",{\"1\":{\"404\":1}}],[\"比如jpg图片或者序列化的对象\",{\"1\":{\"376\":1}}],[\"比如string\",{\"1\":{\"291\":1}}],[\"比如\",{\"1\":{\"273\":1,\"305\":1,\"459\":3}}],[\"比如数据表a中的一条值对应数据表b中的一条值\",{\"1\":{\"90\":1}}],[\"比较\",{\"1\":{\"254\":1,\"406\":1}}],[\"终止执行当前程序\",{\"1\":{\"253\":1}}],[\"继续执行当前程序\",{\"1\":{\"253\":1}}],[\"游标名称\",{\"1\":{\"252\":4}}],[\"游标的使用包括游标的声明\",{\"1\":{\"252\":1}}],[\"游标cursor是用来存储查询结果的数据类型\",{\"1\":{\"252\":1}}],[\"游标\",{\"0\":{\"252\":1},\"1\":{\"385\":1}}],[\"声明自己的\",{\"1\":{\"300\":1}}],[\"声明数组\",{\"1\":{\"288\":1}}],[\"声明数字\",{\"1\":{\"288\":1}}],[\"声明布尔类型\",{\"1\":{\"288\":1}}],[\"声明字符串\",{\"1\":{\"288\":1}}],[\"声明变量的时候\",{\"1\":{\"288\":1}}],[\"声明游标\",{\"1\":{\"252\":1}}],[\"声明\",{\"1\":{\"244\":1,\"288\":1}}],[\"访问次数会随时间缩减\",{\"1\":{\"456\":1}}],[\"访问共享内存\",{\"1\":{\"319\":1}}],[\"访问\",{\"1\":{\"288\":2}}],[\"访问缓存有网络开销\",{\"1\":{\"280\":1}}],[\"访问之前\",{\"1\":{\"244\":1}}],[\"访问速度快\",{\"1\":{\"235\":1,\"236\":1,\"237\":1}}],[\"名字分别叫s1\",{\"1\":{\"331\":1}}],[\"名字分别叫7001\",{\"1\":{\"295\":1}}],[\"名称叫做\",{\"1\":{\"307\":1}}],[\"名称\",{\"1\":{\"240\":1,\"396\":1}}],[\"名为\",{\"1\":{\"127\":1}}],[\"封装http请求工具\",{\"0\":{\"312\":1}}],[\"封装函数\",{\"1\":{\"307\":1}}],[\"封装\",{\"1\":{\"239\":1}}],[\"太大的表无法缓存在内存中\",{\"1\":{\"237\":1}}],[\"低8位记录逻辑访问次数\",{\"1\":{\"456\":1}}],[\"低延迟\",{\"1\":{\"365\":1}}],[\"低一致性需求\",{\"1\":{\"274\":1}}],[\"低\",{\"1\":{\"236\":3,\"274\":1,\"321\":2}}],[\"高16位以分钟为单位记录最近一次访问时间\",{\"1\":{\"456\":1}}],[\"高并发写的问题\",{\"1\":{\"337\":1}}],[\"高并发读的问题\",{\"1\":{\"337\":1}}],[\"高一致性需求\",{\"1\":{\"274\":1}}],[\"高\",{\"1\":{\"236\":4,\"274\":1,\"321\":2}}],[\"高度为3时\",{\"1\":{\"126\":1}}],[\"高度为2时\",{\"1\":{\"126\":1}}],[\"崩溃修复能力和并发控制\",{\"1\":{\"234\":1}}],[\"文档类型\",{\"1\":{\"364\":1}}],[\"文档地址\",{\"1\":{\"266\":1}}],[\"文档型数据库\",{\"1\":{\"109\":1}}],[\"文件传输\",{\"1\":{\"573\":1}}],[\"文件描述符\",{\"1\":{\"404\":1}}],[\"文件体积很大\",{\"1\":{\"321\":1}}],[\"文件体积小\",{\"1\":{\"321\":1}}],[\"文件体积最小多大以上才触发重写\",{\"1\":{\"320\":1}}],[\"文件大小\",{\"1\":{\"321\":1}}],[\"文件大很多\",{\"1\":{\"320\":1}}],[\"文件比上次文件增长多少百分比\",{\"1\":{\"320\":1}}],[\"文件执行重写功能\",{\"1\":{\"320\":1}}],[\"文件会比\",{\"1\":{\"320\":1}}],[\"文件中可以选择使用那种实现方式\",{\"1\":{\"459\":1}}],[\"文件中\",{\"1\":{\"320\":1,\"426\":1}}],[\"文件中找到\",{\"1\":{\"319\":1}}],[\"文件来进行配置\",{\"1\":{\"320\":1}}],[\"文件都比较耗时\",{\"1\":{\"319\":1}}],[\"文件替换旧的\",{\"1\":{\"319\":1}}],[\"文件时\",{\"1\":{\"319\":1}}],[\"文件保存的路径目录\",{\"1\":{\"319\":1}}],[\"文件名称\",{\"1\":{\"319\":1}}],[\"文件夹下\",{\"1\":{\"310\":1}}],[\"文件\",{\"1\":{\"235\":1,\"236\":1,\"287\":1,\"319\":4,\"320\":3,\"334\":1}}],[\"文件xxx\",{\"1\":{\"234\":1}}],[\"完成对应的功能即可\",{\"1\":{\"464\":1}}],[\"完成\",{\"1\":{\"319\":1,\"438\":1}}],[\"完成同步时也会记录当前同步的\",{\"1\":{\"300\":1}}],[\"完成与存储引擎的交互\",{\"1\":{\"231\":1}}],[\"完全相同时则无可厚非\",{\"1\":{\"210\":1}}],[\"来控制\",{\"1\":{\"448\":1}}],[\"来限制\",{\"1\":{\"448\":1}}],[\"来分片存储数据\",{\"1\":{\"444\":1}}],[\"来细化存储大小\",{\"1\":{\"441\":1}}],[\"来对哈希表进行相应的扩展或者收缩\",{\"1\":{\"437\":1}}],[\"来对redis数据库进⾏操作\",{\"1\":{\"373\":1}}],[\"来计算元素应该存储到数组中的哪个索引位置\",{\"1\":{\"436\":1}}],[\"来达到存储特殊字符的字符串的目的\",{\"1\":{\"421\":1}}],[\"来实现list\",{\"1\":{\"416\":1}}],[\"来实现\",{\"1\":{\"416\":1}}],[\"来实现消息队列的功能\",{\"1\":{\"385\":1}}],[\"来判断就绪状态\",{\"1\":{\"410\":1}}],[\"来确认\",{\"1\":{\"404\":1}}],[\"来获取数据\",{\"1\":{\"404\":1}}],[\"来操作\",{\"1\":{\"359\":1}}],[\"来操作redis\",{\"1\":{\"358\":1}}],[\"来监管之前的redis主从集群\",{\"1\":{\"330\":1}}],[\"来完成\",{\"1\":{\"288\":1}}],[\"来回收缓存数据\",{\"1\":{\"283\":1}}],[\"来说\",{\"1\":{\"273\":1}}],[\"来选取合适的存储引擎\",{\"1\":{\"231\":1}}],[\"来减少多次请求带来的性能消耗\",{\"1\":{\"199\":1}}],[\"真正的负责了mysql中数据的存储和提取\",{\"1\":{\"231\":1}}],[\"显示待处理消息的相关信息\",{\"1\":{\"385\":1}}],[\"显示可能应用到这张表上的索引\",{\"1\":{\"229\":1}}],[\"显示内连接\",{\"1\":{\"94\":1}}],[\"重置数组大小\",{\"1\":{\"432\":1}}],[\"重置编码为新编码\",{\"1\":{\"432\":1}}],[\"重启\",{\"1\":{\"370\":1}}],[\"重启后失效\",{\"1\":{\"297\":1}}],[\"重载系统服务\",{\"1\":{\"370\":1}}],[\"重新计算索引\",{\"1\":{\"438\":1}}],[\"重新利用哈希算法\",{\"1\":{\"437\":1}}],[\"重新散列\",{\"1\":{\"437\":1}}],[\"重新分片\",{\"1\":{\"344\":1}}],[\"重新创建出7001\",{\"1\":{\"339\":1}}],[\"重新加载配置\",{\"1\":{\"306\":1,\"310\":1}}],[\"重复次数可在\",{\"1\":{\"289\":1}}],[\"重要\",{\"1\":{\"229\":1}}],[\"重做日志缓冲\",{\"1\":{\"75\":1}}],[\"重做日志缓冲以及重做日志文件\",{\"1\":{\"72\":1}}],[\"重做日志是用来实现事务的持久性\",{\"1\":{\"72\":1}}],[\"重做日志\",{\"0\":{\"72\":1,\"75\":1},\"1\":{\"75\":1}}],[\"包括0\",{\"1\":{\"469\":1}}],[\"包括\",{\"1\":{\"407\":1,\"428\":1}}],[\"包括seletc语句执行过程中表如何连接和连接的顺序\",{\"1\":{\"229\":1}}],[\"包\",{\"1\":{\"305\":1}}],[\"包含对各种数据库的集成\",{\"1\":{\"358\":1}}],[\"包含3个master节点\",{\"1\":{\"338\":1}}],[\"包含两个数\",{\"1\":{\"288\":1}}],[\"包含读取数据的语句\",{\"1\":{\"254\":1}}],[\"包含临界值\",{\"1\":{\"187\":1}}],[\"命令处理\",{\"0\":{\"468\":1}}],[\"命令处理部分\",{\"1\":{\"458\":1}}],[\"命令或者\",{\"1\":{\"437\":1}}],[\"命令对所有\",{\"1\":{\"399\":1}}],[\"命令入队事务时返回的queue\",{\"1\":{\"469\":1}}],[\"命令入队\",{\"1\":{\"399\":1}}],[\"命令后进入事务执行\",{\"1\":{\"399\":1}}],[\"命令前被放入队列缓存\",{\"1\":{\"399\":1}}],[\"命令创建\",{\"1\":{\"385\":1}}],[\"命令的执行是原子性的\",{\"1\":{\"399\":1}}],[\"命令的基本语法如下\",{\"1\":{\"383\":1}}],[\"命令的这个\",{\"1\":{\"345\":1}}],[\"命令发送给频道\",{\"1\":{\"381\":1}}],[\"命令行客户端\",{\"0\":{\"372\":1},\"1\":{\"371\":1}}],[\"命令可以手动让集群中的某个\",{\"1\":{\"345\":1}}],[\"命令可以查看服务器状态信息\",{\"1\":{\"226\":1}}],[\"命令说明\",{\"1\":{\"341\":1}}],[\"命令\",{\"1\":{\"297\":1,\"305\":1,\"320\":1,\"325\":1,\"327\":2,\"328\":1,\"376\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1,\"396\":1,\"397\":1,\"398\":1,\"437\":1}}],[\"命令获取mysql如何执行select语句的信息\",{\"1\":{\"229\":1}}],[\"秒发送一次\",{\"1\":{\"328\":1}}],[\"秒向集群的每个实例发送\",{\"1\":{\"325\":1}}],[\"秒将缓冲区数据写入到\",{\"1\":{\"320\":1}}],[\"秒内\",{\"1\":{\"319\":3}}],[\"秒\",{\"1\":{\"227\":1}}],[\"性能的瓶颈一般情况下都是\",{\"1\":{\"461\":1}}],[\"性能不会随监听的\",{\"1\":{\"410\":1}}],[\"性能会下降\",{\"1\":{\"410\":1}}],[\"性能反而会下降\",{\"1\":{\"406\":1}}],[\"性能自然很差\",{\"1\":{\"404\":1}}],[\"性能最好\",{\"1\":{\"320\":1}}],[\"性能适中\",{\"1\":{\"320\":1}}],[\"性能影响大\",{\"1\":{\"320\":1}}],[\"性能较差\",{\"1\":{\"283\":1}}],[\"性能较好\",{\"1\":{\"272\":1}}],[\"性能要求较高\",{\"1\":{\"280\":1}}],[\"性能受影响\",{\"1\":{\"272\":1}}],[\"性能由好到差的连接类型为\",{\"1\":{\"229\":1}}],[\"性能查询\",{\"1\":{\"226\":1}}],[\"性能也是最好的\",{\"1\":{\"132\":1}}],[\"≈\",{\"1\":{\"221\":1}}],[\"计数器为\",{\"1\":{\"465\":1}}],[\"计数器\",{\"1\":{\"456\":1}}],[\"计数为0则可以回收\",{\"1\":{\"456\":1}}],[\"计数累加\",{\"1\":{\"221\":1}}],[\"计算新hash表的realesize\",{\"1\":{\"438\":2}}],[\"计算索引值\",{\"1\":{\"437\":1}}],[\"计算索引值index\",{\"1\":{\"435\":1}}],[\"计算出\",{\"1\":{\"436\":1}}],[\"计算键\",{\"1\":{\"435\":1}}],[\"计算哈希值和索引值方法如下\",{\"1\":{\"435\":1}}],[\"计算⼀周的uv可以使⽤7天的uv合并计算即可\",{\"1\":{\"398\":1}}],[\"计算hll的近似基数\",{\"1\":{\"398\":1}}],[\"计算基数所需的空间总是固定\",{\"1\":{\"398\":1}}],[\"计算两个位置之间的距离\",{\"1\":{\"396\":1}}],[\"计算方式是利用\",{\"1\":{\"343\":1}}],[\"计算\",{\"1\":{\"343\":2,\"456\":1}}],[\"计算体积\",{\"1\":{\"29\":1}}],[\"计算机操作系统\",{\"0\":{\"43\":1}}],[\"计算机组成原理\",{\"0\":{\"18\":1}}],[\"计算机网络还可以实现电子化办公与服务\",{\"1\":{\"577\":1}}],[\"计算机网络中的各台计算机可以通过网络互为替代机\",{\"1\":{\"576\":1}}],[\"计算机网络可以分为通信子网和资源子网\",{\"1\":{\"571\":1}}],[\"计算机网络可以分为边缘部分和核心部分\",{\"1\":{\"570\":1}}],[\"计算机网络是\",{\"1\":{\"566\":1}}],[\"计算机网络是一个将分散的\",{\"1\":{\"564\":1}}],[\"计算机网络的功能\",{\"0\":{\"572\":1}}],[\"计算机网络的组成\",{\"0\":{\"568\":1}}],[\"计算机网络的概念\",{\"0\":{\"563\":1,\"564\":1}}],[\"计算机网络的分类\",{\"0\":{\"556\":1}}],[\"计算机网络体系结构\",{\"0\":{\"555\":1}}],[\"计算机网络\",{\"0\":{\"12\":1}}],[\"把执行结果写出\",{\"1\":{\"462\":1}}],[\"把待添加的元素放入数组末尾\",{\"1\":{\"432\":1}}],[\"把已就绪的\",{\"1\":{\"404\":1}}],[\"把每一行的字段值都取出来\",{\"1\":{\"221\":2}}],[\"把每一行的主键id值都取出来\",{\"1\":{\"221\":1}}],[\"把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中\",{\"1\":{\"33\":1}}],[\"服务的基本流程图\",{\"1\":{\"409\":1}}],[\"服务\",{\"1\":{\"344\":2}}],[\"服务状态监控\",{\"0\":{\"325\":1}}],[\"服务停止时执行\",{\"1\":{\"319\":1}}],[\"服务时\",{\"1\":{\"319\":1}}],[\"服务重启可能会丢失数据\",{\"1\":{\"318\":1}}],[\"服务内部\",{\"1\":{\"304\":1}}],[\"服务和动态网关\",{\"1\":{\"304\":1}}],[\"服务宕机\",{\"1\":{\"271\":1}}],[\"服务器负责数据的管理\",{\"1\":{\"421\":1}}],[\"服务器\",{\"1\":{\"421\":1}}],[\"服务器中\",{\"1\":{\"352\":1}}],[\"服务器通过api和存储引擎进行通信\",{\"1\":{\"231\":1}}],[\"服务器也会为安全接入的每个客户端验证它所具有的操作权限\",{\"1\":{\"231\":1}}],[\"服务层处于mysql体系结构中的第二层\",{\"1\":{\"231\":1}}],[\"服务层\",{\"1\":{\"231\":1}}],[\"服务层对于返回的每一行\",{\"1\":{\"221\":1}}],[\"服务层判断是否为null\",{\"1\":{\"221\":1}}],[\"服务层拿到主键以后\",{\"1\":{\"221\":1}}],[\"服务层直接按行进行累加\",{\"1\":{\"221\":1}}],[\"服务端\",{\"1\":{\"460\":1}}],[\"服务端通信的标准\",{\"1\":{\"421\":1}}],[\"服务端响应结果的格式必须有一个规范\",{\"1\":{\"421\":1}}],[\"服务端解析并执行命令\",{\"1\":{\"421\":1}}],[\"服务端从\",{\"1\":{\"408\":1}}],[\"服务端调用\",{\"1\":{\"408\":1}}],[\"服务端正常会返回pong\",{\"1\":{\"372\":1}}],[\"服务端优化\",{\"0\":{\"335\":1},\"1\":{\"264\":1}}],[\"服务端还可以向客户端发送数据\",{\"1\":{\"17\":1}}],[\"服务端收到来自客户端的连接释放报文段\",{\"1\":{\"17\":1}}],[\"服务端又会收到大量的连接请求\",{\"1\":{\"16\":1}}],[\"服务端却有两个连接\",{\"1\":{\"16\":1}}],[\"服务端以为客户端建立了新的连接请求\",{\"1\":{\"16\":1}}],[\"服务端接受连接请求\",{\"1\":{\"16\":1}}],[\"服务端接收到客户端发来的连接请求\",{\"1\":{\"15\":1}}],[\"累计值就加1\",{\"1\":{\"221\":1}}],[\"于使用redis类似\",{\"1\":{\"220\":1}}],[\"维护成本\",{\"1\":{\"274\":1}}],[\"维护方便\",{\"1\":{\"270\":1}}],[\"维护好各项属性\",{\"1\":{\"432\":1}}],[\"维护好数据表内的数据即可\",{\"1\":{\"220\":1}}],[\"维护好这个存储的变量即可\",{\"1\":{\"220\":1}}],[\"维护索引结构的代价也就越大\",{\"1\":{\"134\":1}}],[\"因此在\",{\"1\":{\"461\":1}}],[\"因此多线程并不会带来巨大的性能提升\",{\"1\":{\"458\":1}}],[\"因此所有的\",{\"1\":{\"454\":1}}],[\"因此称为渐进式\",{\"1\":{\"438\":1}}],[\"因此必须对哈希表中的每一个\",{\"1\":{\"438\":1}}],[\"因此需要采取一些措施来解决哈希冲突\",{\"1\":{\"435\":1}}],[\"因此需要有\",{\"1\":{\"419\":1}}],[\"因此采用的编码方式为\",{\"1\":{\"430\":1}}],[\"因此c字符串无法正确存取\",{\"1\":{\"425\":1}}],[\"因此客户端发送命令的格式\",{\"1\":{\"421\":1}}],[\"因此具备与hashset类似的特征\",{\"1\":{\"379\":1}}],[\"因此我们使用jedis连接池代替jedis的直接连接方式\",{\"1\":{\"347\":1}}],[\"因此节点列表中的前n个就是master\",{\"1\":{\"341\":1}}],[\"因此\",{\"1\":{\"300\":1,\"417\":1,\"419\":3,\"438\":1}}],[\"因此执行count\",{\"1\":{\"219\":1}}],[\"因为我们一次可以跨一个台阶或者两个台阶\",{\"1\":{\"534\":1}}],[\"因为再爬2阶就能到第n阶\",{\"1\":{\"521\":1}}],[\"因为再爬1阶就能到第n阶\",{\"1\":{\"521\":1}}],[\"因为结果和nums\",{\"1\":{\"482\":2}}],[\"因为链表一般都是从首尾访问较多\",{\"1\":{\"448\":1}}],[\"因为是6位\",{\"1\":{\"442\":1}}],[\"因为记录两个指针要占用\",{\"1\":{\"441\":1}}],[\"因为c字符串以空字符作为字符串结束的标识\",{\"1\":{\"425\":1}}],[\"因为sortedset的可排序特性\",{\"1\":{\"380\":1}}],[\"因为也是一个hash表\",{\"1\":{\"379\":1}}],[\"因为redis\",{\"1\":{\"341\":1}}],[\"因为已经配置了后台启动模式\",{\"1\":{\"340\":1}}],[\"因为数据完整性更高\",{\"1\":{\"321\":1}}],[\"因为数据完整性不如aof\",{\"1\":{\"321\":1}}],[\"因为\",{\"1\":{\"319\":1,\"398\":1,\"541\":1}}],[\"因为其自动加载缓存的能力将会变得非常实用\",{\"1\":{\"281\":1}}],[\"因为id是主键\",{\"1\":{\"126\":1}}],[\"因为两张表的是完全相同的\",{\"1\":{\"96\":1}}],[\"因为事务id是自增的\",{\"1\":{\"85\":1}}],[\"因为这些日志可能还用于mvcc\",{\"1\":{\"76\":1}}],[\"因为顺序表支持随机访问\",{\"1\":{\"36\":1}}],[\"耗时越长\",{\"1\":{\"216\":1}}],[\"业务名\",{\"1\":{\"376\":1}}],[\"业务场景\",{\"1\":{\"274\":1}}],[\"业务操作时避免对主键的修改\",{\"1\":{\"207\":1}}],[\"业务基本上就完全停止\",{\"1\":{\"140\":1}}],[\"满足了社会的需要\",{\"1\":{\"577\":1}}],[\"满足\",{\"1\":{\"477\":1}}],[\"满足以下两种情况时会触发哈希表扩容\",{\"1\":{\"437\":1}}],[\"满足下列特点\",{\"1\":{\"418\":1}}],[\"满足条件后\",{\"1\":{\"249\":1}}],[\"满足业务需求的情况下\",{\"1\":{\"207\":1}}],[\"满足最左前缀法则\",{\"1\":{\"129\":1}}],[\"合并后排序\",{\"1\":{\"543\":1}}],[\"合并后数组不应由函数返回\",{\"1\":{\"541\":1}}],[\"合并结果是\",{\"1\":{\"541\":3}}],[\"合并\",{\"1\":{\"541\":1}}],[\"合并两个有序数组\",{\"0\":{\"540\":1}}],[\"合并页的阀值\",{\"1\":{\"206\":1}}],[\"合并插入缓存\",{\"1\":{\"73\":1}}],[\"实例中的红黑树保存要监听的\",{\"1\":{\"410\":1}}],[\"实例中\",{\"1\":{\"408\":1}}],[\"实例的句柄\",{\"1\":{\"407\":1}}],[\"实例\",{\"1\":{\"343\":1,\"344\":2}}],[\"实例是否健康\",{\"1\":{\"328\":1}}],[\"实例数量的一半\",{\"1\":{\"325\":1}}],[\"实例故障重启后\",{\"1\":{\"319\":1}}],[\"实际数据\",{\"1\":{\"464\":1}}],[\"实际上的\",{\"1\":{\"419\":1}}],[\"实际上并没有将记录值物理删除\",{\"1\":{\"206\":1}}],[\"实际发生的事件类型\",{\"1\":{\"406\":1}}],[\"实际使用的索引\",{\"1\":{\"229\":1}}],[\"实现联网计算机之间的数据通信\",{\"1\":{\"571\":1}}],[\"实现却更简单\",{\"1\":{\"453\":1}}],[\"实现了分片集群的支持\",{\"1\":{\"346\":1}}],[\"实现了节点的感知和自动切换\",{\"1\":{\"334\":1}}],[\"实现无感知的数据迁移\",{\"1\":{\"345\":1}}],[\"实现故障转移\",{\"0\":{\"327\":1}}],[\"实现健康检测和自动恢复\",{\"1\":{\"318\":1}}],[\"实现读写分离解决\",{\"1\":{\"318\":1}}],[\"实现读写分离\",{\"1\":{\"293\":1,\"334\":1}}],[\"实现复杂度增高\",{\"1\":{\"458\":1}}],[\"实现复杂\",{\"1\":{\"270\":1,\"272\":1}}],[\"实现简单\",{\"1\":{\"270\":1,\"272\":1}}],[\"实现\",{\"1\":{\"90\":1,\"91\":1,\"92\":1,\"358\":1,\"404\":1,\"415\":1}}],[\"实现方式中独有的api\",{\"1\":{\"459\":1}}],[\"实现方式\",{\"1\":{\"86\":1}}],[\"实现原理\",{\"0\":{\"82\":1},\"1\":{\"86\":1}}],[\"叫做页分裂\",{\"1\":{\"205\":1}}],[\"调整为\",{\"1\":{\"205\":1}}],[\"调用对应的处理器\",{\"1\":{\"462\":1}}],[\"调用前置处理器\",{\"1\":{\"462\":1}}],[\"调用不同的处理器\",{\"1\":{\"460\":1}}],[\"调用频率影响\",{\"1\":{\"455\":1}}],[\"调用一切系统资源\",{\"1\":{\"401\":1}}],[\"调用一次递归函数\",{\"1\":{\"30\":1}}],[\"调用者只操作缓存\",{\"1\":{\"275\":1}}],[\"调用者调用该服务\",{\"1\":{\"275\":1}}],[\"调用\",{\"1\":{\"240\":1,\"406\":1}}],[\"调用存储过程可以简化应用开发人员的很多工作\",{\"1\":{\"239\":1}}],[\"调用两次递归函数\",{\"1\":{\"30\":1}}],[\"尽可能避免全量同步\",{\"1\":{\"301\":1}}],[\"尽可能的保证了空间的利用率\",{\"1\":{\"205\":1}}],[\"尽量建立联合索引\",{\"1\":{\"214\":1}}],[\"尽量建立唯一索引\",{\"1\":{\"134\":1}}],[\"尽量不要使用uuid做主键或者是其他自然主键\",{\"1\":{\"207\":1}}],[\"尽量降低主键的长度\",{\"1\":{\"207\":1}}],[\"尽量使用主键\",{\"1\":{\"223\":1}}],[\"尽量使用count\",{\"1\":{\"221\":1}}],[\"尽量使用顺序插入\",{\"1\":{\"207\":1}}],[\"尽量使用联合索引\",{\"1\":{\"134\":1}}],[\"尽量使用覆盖索引\",{\"1\":{\"131\":1,\"211\":1}}],[\"尽量选择区分度较高的列作为索引\",{\"1\":{\"134\":1}}],[\"换行分隔符\",{\"1\":{\"202\":1}}],[\"`table\",{\"1\":{\"202\":1}}],[\"```sql\",{\"1\":{\"145\":1}}],[\"```\",{\"1\":{\"145\":1}}],[\"设置dict\",{\"1\":{\"438\":2}}],[\"设置为0\",{\"1\":{\"405\":1}}],[\"设置bitmaps中某个偏移量的值\",{\"1\":{\"397\":1}}],[\"设置后访问redis必须输入密码\",{\"1\":{\"369\":1}}],[\"设置\",{\"1\":{\"353\":2}}],[\"设置连接⼯⼚\",{\"1\":{\"353\":1}}],[\"设置密码\",{\"1\":{\"351\":1}}],[\"设置最长等待时间\",{\"1\":{\"347\":1}}],[\"设置缓存为软引用或者弱引用\",{\"1\":{\"283\":1}}],[\"设置缓存有效期为\",{\"1\":{\"283\":1}}],[\"设置缓存的有效时间\",{\"1\":{\"283\":1}}],[\"设置缓存的数量上限\",{\"1\":{\"283\":1}}],[\"设置缓存大小上限为\",{\"1\":{\"283\":1}}],[\"设置事务的隔离级别\",{\"1\":{\"259\":1}}],[\"设置事务提交方式\",{\"1\":{\"256\":1}}],[\"设置系统变量\",{\"1\":{\"242\":1}}],[\"设置慢查询的\",{\"1\":{\"227\":1}}],[\"设置全局参数为local\",{\"1\":{\"202\":1}}],[\"设置别名\",{\"1\":{\"186\":1}}],[\"999\",{\"1\":{\"532\":1}}],[\"9999\",{\"1\":{\"37\":2}}],[\"900\",{\"1\":{\"319\":2}}],[\"9\",{\"1\":{\"201\":2,\"373\":1,\"447\":1,\"466\":1,\"514\":1,\"532\":1}}],[\"授权认证\",{\"1\":{\"231\":1}}],[\"授权时\",{\"1\":{\"196\":1}}],[\"授予权限\",{\"1\":{\"196\":1}}],[\"撤销权限\",{\"1\":{\"196\":1}}],[\"撤销表空间\",{\"0\":{\"69\":1},\"1\":{\"69\":1}}],[\"权限列表\",{\"1\":{\"196\":2}}],[\"权限\",{\"1\":{\"196\":1}}],[\"权限控制\",{\"0\":{\"196\":1}}],[\"密码\",{\"1\":{\"195\":1,\"369\":1}}],[\"才执行删除\",{\"1\":{\"455\":1}}],[\"才存储到\",{\"1\":{\"352\":1}}],[\"才可以判断到底需要同步哪些数据\",{\"1\":{\"300\":1}}],[\"才会根据第二个字段比较\",{\"1\":{\"191\":1}}],[\"才能够准确无误的实现用户的指令\",{\"1\":{\"464\":1}}],[\"才能成功连接一次\",{\"1\":{\"16\":1}}],[\"才能建立起知识体系\",{\"1\":{\"2\":1}}],[\"降序\",{\"1\":{\"191\":1}}],[\"降低响应时间\",{\"1\":{\"269\":1}}],[\"降低后端负载\",{\"1\":{\"269\":1}}],[\"降低cpu的消耗\",{\"1\":{\"114\":1}}],[\"降低数据排序的成本\",{\"1\":{\"114\":1}}],[\"降低数据库的io成本\",{\"1\":{\"114\":1}}],[\"执行以下步骤\",{\"1\":{\"468\":1}}],[\"执行一个处理数据类型命令的时候\",{\"1\":{\"468\":1}}],[\"执行一次sql\",{\"1\":{\"153\":1}}],[\"执行command\",{\"1\":{\"462\":1}}],[\"执行速度非常快\",{\"1\":{\"458\":1}}],[\"执行清理耗时不超过1ms\",{\"1\":{\"455\":1}}],[\"执行清理耗时不超过一次执行周期的25\",{\"1\":{\"455\":1}}],[\"执行频率受beforesleep\",{\"1\":{\"455\":1}}],[\"执行频率受server\",{\"1\":{\"455\":1}}],[\"执行过期key清理\",{\"1\":{\"455\":1}}],[\"执行周期有两种\",{\"1\":{\"455\":1}}],[\"执行事务\",{\"1\":{\"399\":2}}],[\"执行缓存在服务器中的脚本\",{\"1\":{\"384\":1}}],[\"执行lua脚本\",{\"1\":{\"384\":1}}],[\"执行load指令\",{\"1\":{\"202\":1}}],[\"执行脚本的常用命令为\",{\"1\":{\"382\":1}}],[\"执行teststring\",{\"1\":{\"351\":1}}],[\"执行拷贝\",{\"1\":{\"339\":1}}],[\"执行\",{\"1\":{\"328\":1,\"439\":1}}],[\"执行间隔时间长\",{\"1\":{\"319\":1}}],[\"执行写操作\",{\"1\":{\"319\":1}}],[\"执行命令\",{\"1\":{\"305\":1}}],[\"执行get\",{\"1\":{\"298\":2}}],[\"执行set\",{\"1\":{\"298\":1}}],[\"执行slaveof\",{\"1\":{\"297\":2}}],[\"执行slaveof命令\",{\"1\":{\"297\":1}}],[\"执行下列操作以测试\",{\"1\":{\"298\":1}}],[\"执行下面命令\",{\"1\":{\"297\":2}}],[\"执行创建存储过程的sql时\",{\"1\":{\"240\":1}}],[\"执行顺序从上到下\",{\"1\":{\"229\":1}}],[\"执行顺序\",{\"0\":{\"193\":1},\"1\":{\"190\":1}}],[\"执行时机不同\",{\"1\":{\"190\":1}}],[\"成为\",{\"1\":{\"421\":1}}],[\"成为新\",{\"1\":{\"327\":1}}],[\"成本\",{\"1\":{\"269\":1}}],[\"成立任意一个即可\",{\"1\":{\"187\":1}}],[\"成功传输到了服务端\",{\"1\":{\"16\":1}}],[\"匹配到的参数会存入\",{\"1\":{\"311\":1}}],[\"匹配任意个字符\",{\"1\":{\"187\":1}}],[\"匹配单个字符\",{\"1\":{\"187\":1}}],[\"占据\",{\"1\":{\"465\":1}}],[\"占据的内存不一样\",{\"1\":{\"441\":1}}],[\"占用缓存空间\",{\"1\":{\"273\":1}}],[\"占用8个字节\",{\"1\":{\"126\":1}}],[\"占位符\",{\"1\":{\"187\":1}}],[\"大小超过了\",{\"1\":{\"417\":1}}],[\"大小固定值为\",{\"1\":{\"406\":1}}],[\"大小\",{\"1\":{\"326\":1,\"444\":1,\"449\":1}}],[\"大小150m\",{\"1\":{\"307\":1}}],[\"大小有上限\",{\"1\":{\"301\":1}}],[\"大容量缓存是能带来性能加速的收益\",{\"1\":{\"273\":1}}],[\"大量cpu和内存消耗\",{\"1\":{\"321\":1}}],[\"大量的缓存\",{\"1\":{\"271\":1}}],[\"大量数据的情况下\",{\"1\":{\"116\":1}}],[\"大纲\",{\"0\":{\"261\":1}}],[\"大数据量排序时\",{\"1\":{\"211\":1}}],[\"大批量数据插入\",{\"0\":{\"202\":1}}],[\"大于0为阻塞时间\",{\"1\":{\"407\":1}}],[\"大于0\",{\"1\":{\"405\":1}}],[\"大于等于\",{\"1\":{\"187\":1}}],[\"大于\",{\"1\":{\"187\":1,\"406\":1,\"432\":1}}],[\"去尽可能的优先满足胃口较小的孩子\",{\"1\":{\"492\":1}}],[\"去掉即可\",{\"1\":{\"417\":1}}],[\"去掉字符串头部和尾部的空格\",{\"1\":{\"53\":1}}],[\"去除重复记录\",{\"1\":{\"186\":1}}],[\"涉及的数据的删除时\",{\"1\":{\"182\":1}}],[\"涉及的数据的修改时\",{\"1\":{\"181\":1}}],[\"涉及两个文件\",{\"1\":{\"72\":1}}],[\"危险警告\",{\"1\":{\"181\":1,\"182\":1}}],[\"给你两个按\",{\"1\":{\"541\":1}}],[\"给你一个\",{\"1\":{\"514\":1}}],[\"给你一个整数\",{\"1\":{\"484\":1}}],[\"给你一个整数数组\",{\"1\":{\"477\":1,\"532\":1}}],[\"给定\",{\"1\":{\"496\":1}}],[\"给client\",{\"1\":{\"462\":1}}],[\"给新元素腾出空间\",{\"1\":{\"432\":1}}],[\"给⼀个key设置有效期\",{\"1\":{\"361\":1}}],[\"给\",{\"1\":{\"344\":1,\"438\":2}}],[\"给所有其他\",{\"1\":{\"327\":1}}],[\"给备选的\",{\"1\":{\"327\":1}}],[\"给缓存数据添加ttl时间\",{\"1\":{\"274\":1}}],[\"给缓存业务添加降级限流操作\",{\"1\":{\"271\":1}}],[\"给业务添加多级缓存\",{\"1\":{\"271\":1}}],[\"给不同的\",{\"1\":{\"271\":1}}],[\"给全部字段添加数据\",{\"1\":{\"180\":1}}],[\"给指定字段添加数据\",{\"1\":{\"180\":1}}],[\"值越小淘汰优先级越高\",{\"1\":{\"456\":1}}],[\"值越大\",{\"1\":{\"229\":1}}],[\"值一样则按照\",{\"1\":{\"453\":1}}],[\"值取决于当前要做的是扩容还是收缩\",{\"1\":{\"438\":2}}],[\"值升序排列\",{\"1\":{\"419\":1}}],[\"值排序\",{\"1\":{\"419\":1,\"453\":1}}],[\"值和\",{\"1\":{\"419\":1}}],[\"值是一个键值对集合\",{\"1\":{\"417\":1}}],[\"值最好超过\",{\"1\":{\"325\":1}}],[\"值\",{\"1\":{\"242\":2,\"244\":2,\"326\":1,\"343\":2,\"396\":1,\"419\":2,\"436\":2,\"453\":1,\"484\":1}}],[\"值n\",{\"1\":{\"180\":6}}],[\"值2\",{\"1\":{\"180\":6,\"181\":1}}],[\"值1\",{\"1\":{\"180\":6,\"181\":1}}],[\"改变编码方式\",{\"1\":{\"432\":1}}],[\"改这三个操作\",{\"1\":{\"179\":1}}],[\"改\",{\"1\":{\"179\":1}}],[\"删\",{\"1\":{\"179\":2}}],[\"删除等操作\",{\"1\":{\"464\":1}}],[\"删除以释放更多的内存的流程\",{\"1\":{\"456\":1}}],[\"删除策略\",{\"0\":{\"455\":1}}],[\"删除消费者组\",{\"1\":{\"385\":1}}],[\"删除消费者\",{\"1\":{\"385\":1}}],[\"删除消息\",{\"1\":{\"385\":1,\"388\":1}}],[\"删除sorted\",{\"1\":{\"380\":1}}],[\"删除⼀个指定的key\",{\"1\":{\"361\":1}}],[\"删除旧的\",{\"1\":{\"339\":1}}],[\"删除之前的7001\",{\"1\":{\"339\":1}}],[\"删除现象也是如此\",{\"1\":{\"258\":1}}],[\"删除用户\",{\"1\":{\"195\":1}}],[\"删除数据库\",{\"1\":{\"196\":1}}],[\"删除数据权限\",{\"1\":{\"196\":1}}],[\"删除数据\",{\"0\":{\"182\":1}}],[\"删除数据表后\",{\"1\":{\"177\":1}}],[\"删除字段\",{\"1\":{\"178\":1}}],[\"删除指定数据表\",{\"1\":{\"177\":1}}],[\"删除触发器\",{\"0\":{\"159\":1}}],[\"删除索引\",{\"1\":{\"127\":1}}],[\"删除和更新可能会影响索引树中不相邻的二级索引页\",{\"1\":{\"62\":1}}],[\"删除外键\",{\"1\":{\"49\":1}}],[\"删除节点操作\",{\"1\":{\"37\":1}}],[\"删除表\",{\"1\":{\"127\":1,\"177\":1}}],[\"删除表头元素\",{\"1\":{\"36\":1}}],[\"删除表尾元素\",{\"1\":{\"36\":1}}],[\"删除表l中的第i个位置的元素\",{\"1\":{\"35\":1}}],[\"删除顺序表\",{\"1\":{\"36\":1}}],[\"删除\",{\"0\":{\"50\":1},\"1\":{\"36\":1,\"155\":1,\"163\":1,\"164\":1,\"176\":1,\"177\":1,\"226\":1,\"240\":1,\"459\":1}}],[\"删除操作时\",{\"1\":{\"438\":1}}],[\"删除操作\",{\"1\":{\"35\":1,\"36\":1,\"237\":1}}],[\"应忽略\",{\"1\":{\"541\":1}}],[\"应该在哪个实例\",{\"1\":{\"343\":1}}],[\"应该在字段数据类型的规定范围以内\",{\"1\":{\"180\":1}}],[\"应该根据应用系统的特点选择合适的存储引擎\",{\"1\":{\"237\":1}}],[\"应该包含增\",{\"1\":{\"179\":1}}],[\"应用层\",{\"0\":{\"554\":1}}],[\"应用层之下的中间层\",{\"1\":{\"14\":1}}],[\"应用系统\",{\"1\":{\"304\":1}}],[\"应用平台\",{\"1\":{\"304\":1}}],[\"应用\",{\"1\":{\"304\":1}}],[\"应用在myisam\",{\"1\":{\"142\":1}}],[\"旧次数\",{\"1\":{\"456\":1}}],[\"旧字段名\",{\"1\":{\"178\":1}}],[\"旧表名\",{\"1\":{\"177\":1}}],[\"新增删除都可能导致连锁更新的发生\",{\"1\":{\"443\":1}}],[\"新增操作只在ht\",{\"1\":{\"439\":1}}],[\"新增操作\",{\"1\":{\"438\":1}}],[\"新编码\",{\"1\":{\"432\":1}}],[\"新master\",{\"1\":{\"328\":2}}],[\"新建文件\",{\"1\":{\"310\":1}}],[\"新建一个maven工程并引入以下依赖\",{\"1\":{\"351\":1}}],[\"新建一个\",{\"1\":{\"287\":1}}],[\"新密码\",{\"1\":{\"195\":1}}],[\"新字段名\",{\"1\":{\"178\":1}}],[\"新数据类型\",{\"1\":{\"178\":1}}],[\"新表名\",{\"1\":{\"177\":1}}],[\"长度24bit\",{\"1\":{\"456\":1}}],[\"长度不能超过2^32\",{\"1\":{\"442\":1}}],[\"长度不能超过16383\",{\"1\":{\"442\":1}}],[\"长度小于\",{\"1\":{\"415\":1}}],[\"长度越短越小\",{\"1\":{\"229\":1}}],[\"长度\",{\"1\":{\"178\":3,\"387\":1}}],[\"长度为null\",{\"1\":{\"129\":1}}],[\"长度为\",{\"1\":{\"129\":1,\"405\":1}}],[\"且不与之前的值重复\",{\"1\":{\"481\":1}}],[\"且不重复的三元组\",{\"1\":{\"477\":1}}],[\"且最大不超过\",{\"1\":{\"456\":1}}],[\"且在生产环境时大多数使用的linux系统\",{\"1\":{\"366\":1}}],[\"且\",{\"1\":{\"343\":1,\"442\":1,\"477\":1}}],[\"且种类繁多\",{\"1\":{\"179\":1}}],[\"且其操作较多\",{\"1\":{\"177\":1}}],[\"且查询比较频繁的表建立索引\",{\"1\":{\"134\":1}}],[\"影响后续我们的编辑\",{\"1\":{\"306\":1}}],[\"影响\",{\"1\":{\"273\":1}}],[\"影响功能\",{\"1\":{\"177\":1}}],[\"影响查询效率\",{\"1\":{\"132\":1}}],[\"没有在事务上增加任何维持原子性的机制\",{\"1\":{\"399\":1}}],[\"没有设置就是非阻塞模式\",{\"1\":{\"392\":1}}],[\"没有则返回nil\",{\"1\":{\"378\":1}}],[\"没有任何关联\",{\"1\":{\"341\":1}}],[\"没有网络开销\",{\"1\":{\"280\":1}}],[\"没有额外的内存消耗\",{\"1\":{\"272\":1}}],[\"没有多余的key\",{\"1\":{\"270\":1}}],[\"没有对应的数据记录值\",{\"1\":{\"258\":1}}],[\"没有not\",{\"1\":{\"221\":1}}],[\"没有也不会对sql语句造成歧义\",{\"1\":{\"177\":1}}],[\"没有实现\",{\"1\":{\"32\":1}}],[\"缩进符来增强语句的可读性\",{\"1\":{\"173\":1}}],[\"书的pdf资料在这里下载\",{\"1\":{\"171\":1}}],[\"视频资料\",{\"1\":{\"549\":1}}],[\"视频\",{\"1\":{\"404\":1}}],[\"视频地址\",{\"1\":{\"171\":1,\"266\":2,\"546\":1}}],[\"视图不仅可以简化用户对数据的理解\",{\"1\":{\"167\":1}}],[\"视图不保存数据\",{\"1\":{\"162\":1}}],[\"视图的作用\",{\"0\":{\"167\":1}}],[\"视图的更新\",{\"0\":{\"166\":1}}],[\"视图中的行与基础表中的行之间必须存在一对一的关系\",{\"1\":{\"166\":1}}],[\"视图中的数据并不在数据库中实际存在\",{\"1\":{\"162\":1}}],[\"视图就是一张逻辑sql查询的临时表\",{\"1\":{\"163\":1}}],[\"视图名称\",{\"1\":{\"163\":7}}],[\"视图view是一种虚拟存在的表\",{\"1\":{\"162\":1}}],[\"视图\",{\"0\":{\"160\":1},\"1\":{\"170\":1}}],[\"运行在内核空间时称为内核态\",{\"1\":{\"401\":1}}],[\"运行查看结果\",{\"1\":{\"360\":1}}],[\"运行后的样子\",{\"1\":{\"341\":1}}],[\"运行下面的命令就可以添加我们的仓库\",{\"1\":{\"305\":1}}],[\"运行结果\",{\"1\":{\"287\":1}}],[\"运行\",{\"1\":{\"287\":1,\"344\":1}}],[\"运算时使用\",{\"1\":{\"436\":1}}],[\"运算符\",{\"1\":{\"187\":1}}],[\"运算的实现是针对存储结构的\",{\"1\":{\"33\":1}}],[\"运算的定义是针对逻辑结构的\",{\"1\":{\"33\":1}}],[\"运维篇\",{\"1\":{\"170\":1}}],[\"进阶\",{\"1\":{\"541\":1}}],[\"进阶篇\",{\"1\":{\"170\":1}}],[\"进一步提高对多核\",{\"1\":{\"458\":1}}],[\"进一步节省了内存\",{\"1\":{\"449\":1}}],[\"进入redis的src目录\",{\"1\":{\"341\":1}}],[\"进入\",{\"1\":{\"295\":1,\"331\":1,\"339\":3,\"340\":1}}],[\"进程缓存和\",{\"1\":{\"283\":1}}],[\"进程本地缓存\",{\"1\":{\"280\":1}}],[\"进去\",{\"1\":{\"221\":1}}],[\"进行统一的调配\",{\"1\":{\"573\":1}}],[\"进行遍历\",{\"1\":{\"480\":1}}],[\"进行筛选\",{\"1\":{\"345\":1}}],[\"进行通配\",{\"1\":{\"196\":1}}],[\"进行纵向计算\",{\"1\":{\"189\":1}}],[\"进行数据恢复使用\",{\"1\":{\"72\":1,\"75\":1}}],[\"学习目录\",{\"0\":{\"170\":1}}],[\"等组成\",{\"1\":{\"569\":1}}],[\"等等\",{\"1\":{\"469\":1}}],[\"等待被写出\",{\"1\":{\"462\":1}}],[\"等待fd就绪\",{\"1\":{\"462\":1}}],[\"等待\",{\"1\":{\"459\":1}}],[\"等待碎片整理的\",{\"1\":{\"454\":1}}],[\"等待数据阶段\",{\"1\":{\"403\":1}}],[\"等后台进程\",{\"1\":{\"437\":1}}],[\"等都进行一致的高性能响应\",{\"1\":{\"304\":1}}],[\"等\",{\"1\":{\"166\":1,\"229\":1}}],[\"聚合函数\",{\"0\":{\"189\":1},\"1\":{\"189\":1,\"190\":1}}],[\"聚合函数或者窗口函数\",{\"1\":{\"166\":1}}],[\"聚合查询\",{\"0\":{\"188\":1},\"1\":{\"185\":1}}],[\"聚集索引中查询直接就能够得到数据的记录值\",{\"1\":{\"126\":1}}],[\"聚集索引的选取规则\",{\"1\":{\"124\":1}}],[\"聚集索引\",{\"1\":{\"124\":1}}],[\"检查骑士巡视方案\",{\"0\":{\"513\":1},\"1\":{\"515\":1}}],[\"检查redisobject的type属性和执行命令所需的类型是否相符\",{\"1\":{\"468\":1}}],[\"检查rdlist列表是否为空\",{\"1\":{\"407\":1}}],[\"检查该\",{\"1\":{\"455\":1}}],[\"检查时在\",{\"1\":{\"454\":1}}],[\"检查选项\",{\"0\":{\"164\":1}}],[\"检索速度还是很慢\",{\"1\":{\"117\":1}}],[\"检索速度慢\",{\"1\":{\"116\":1}}],[\"修改和删除则会在dict\",{\"1\":{\"438\":1}}],[\"修改数组长度\",{\"1\":{\"432\":1}}],[\"修改数据\",{\"0\":{\"181\":1}}],[\"修改数据类型\",{\"1\":{\"178\":1}}],[\"修改为yes后即为后台运行\",{\"1\":{\"369\":1}}],[\"修改为0\",{\"1\":{\"369\":1}}],[\"修改配置类\",{\"1\":{\"334\":1}}],[\"修改配置文件\",{\"1\":{\"297\":1,\"339\":1}}],[\"修改s2\",{\"1\":{\"331\":1}}],[\"修改故障节点配置\",{\"1\":{\"328\":1}}],[\"修改nginx\",{\"0\":{\"309\":1}}],[\"修改每个目录下的redis\",{\"1\":{\"339\":1}}],[\"修改每个实例的声明ip\",{\"1\":{\"295\":1}}],[\"修改每个实例的端口\",{\"1\":{\"295\":1}}],[\"修改每个文件夹内的配置文件\",{\"1\":{\"295\":1}}],[\"修改redis配置文件redis\",{\"1\":{\"369\":1}}],[\"修改redistemplate\",{\"1\":{\"356\":1}}],[\"修改redis\",{\"1\":{\"295\":1}}],[\"修改用户\",{\"1\":{\"195\":1}}],[\"修改字段名称和字段类型\",{\"1\":{\"178\":1}}],[\"修改字段\",{\"1\":{\"178\":1}}],[\"修改表权限\",{\"1\":{\"196\":1}}],[\"修改表字符集\",{\"1\":{\"177\":1}}],[\"修改表名\",{\"1\":{\"177\":1}}],[\"修改表的时候添加约束\",{\"1\":{\"47\":1}}],[\"修改\",{\"1\":{\"163\":1,\"177\":1,\"306\":1,\"432\":1,\"438\":1}}],[\"案例\",{\"0\":{\"156\":1}}],[\"类路径地址比我们真实的数据内容还大\",{\"1\":{\"354\":1}}],[\"类中属性需要给出\",{\"1\":{\"354\":1}}],[\"类\",{\"1\":{\"334\":1,\"354\":1,\"355\":1}}],[\"类似epoll\",{\"1\":{\"462\":1}}],[\"类似java的hashtable\",{\"1\":{\"439\":1}}],[\"类似\",{\"1\":{\"288\":1,\"462\":1}}],[\"类似于java中的hashmap结构\",{\"1\":{\"377\":1}}],[\"类似于只复制数据的索引\",{\"1\":{\"319\":1}}],[\"类似于编程语言中的\",{\"1\":{\"250\":1}}],[\"类似于\",{\"1\":{\"239\":1,\"289\":1}}],[\"类似于lucene\",{\"1\":{\"115\":1}}],[\"类型信息\",{\"1\":{\"464\":1}}],[\"类型是二进制安全的\",{\"1\":{\"376\":1}}],[\"类型只有在特殊的业务场景下会使用到\",{\"1\":{\"375\":1,\"395\":1}}],[\"类型时\",{\"1\":{\"359\":1}}],[\"类型的整数集合中添加一个\",{\"1\":{\"432\":1}}],[\"类型的\",{\"1\":{\"355\":1}}],[\"类型的数据元素\",{\"1\":{\"432\":1}}],[\"类型的数据\",{\"1\":{\"352\":1,\"354\":2,\"356\":1,\"359\":1,\"360\":2}}],[\"类型\",{\"0\":{\"154\":1},\"1\":{\"246\":1,\"376\":1,\"432\":1,\"436\":1}}],[\"语言的字符串实质为字符数组\",{\"1\":{\"425\":1}}],[\"语言的字符串\",{\"1\":{\"425\":1}}],[\"语言中字符串存在着很多的问题\",{\"1\":{\"425\":1}}],[\"语言中也有字符串\",{\"1\":{\"425\":1}}],[\"语言中的一些数据类型\",{\"1\":{\"288\":1}}],[\"语言来编写的\",{\"1\":{\"425\":1}}],[\"语言类似\",{\"1\":{\"291\":1}}],[\"语言编写并以源代码形式开放\",{\"1\":{\"286\":1}}],[\"语句\",{\"1\":{\"290\":1}}],[\"语句中控制\",{\"1\":{\"289\":1}}],[\"语句在\",{\"1\":{\"228\":1}}],[\"语句级触发\",{\"1\":{\"153\":1}}],[\"语法格式\",{\"1\":{\"386\":1,\"387\":1,\"388\":1,\"389\":1,\"390\":1,\"391\":1,\"392\":1,\"393\":1,\"394\":1}}],[\"语法2\",{\"1\":{\"247\":1}}],[\"语法1\",{\"1\":{\"247\":1}}],[\"语法如下\",{\"1\":{\"82\":1}}],[\"语法创建通用表空间\",{\"1\":{\"68\":1}}],[\"语法\",{\"0\":{\"49\":1,\"155\":1,\"383\":1},\"1\":{\"132\":1,\"143\":1,\"187\":1,\"189\":1,\"190\":1,\"191\":1,\"192\":1,\"229\":1,\"245\":1}}],[\"举个例子\",{\"1\":{\"408\":1}}],[\"举个简单的例子\",{\"1\":{\"129\":1,\"210\":1}}],[\"举例推导dp数组\",{\"1\":{\"503\":1}}],[\"举例说明\",{\"0\":{\"210\":1,\"217\":1,\"224\":1},\"1\":{\"376\":1}}],[\"举例\",{\"1\":{\"153\":1}}],[\"触发命令请求处理器\",{\"1\":{\"460\":1}}],[\"触发连接应答处理器\",{\"1\":{\"460\":1}}],[\"触发条件有两个\",{\"1\":{\"417\":1}}],[\"触发并执行触发器中定义的sql语句集合\",{\"1\":{\"153\":1}}],[\"触发器语句\",{\"1\":{\"155\":1}}],[\"触发器类型\",{\"1\":{\"154\":1}}],[\"触发器会触发一次\",{\"1\":{\"153\":1}}],[\"触发器的这种特性可以与协助应用在数据库端确保数据的完整性\",{\"1\":{\"153\":1}}],[\"触发器是于表有关的数据库对象\",{\"1\":{\"153\":1}}],[\"触发器\",{\"0\":{\"152\":1},\"1\":{\"170\":1}}],[\"暂未理解\",{\"1\":{\"149\":1}}],[\"允许\",{\"1\":{\"448\":1}}],[\"允许访问的地址\",{\"1\":{\"369\":1}}],[\"允许获取排他锁的事务更新数据\",{\"1\":{\"147\":1}}],[\"允许一个事务去读一行\",{\"1\":{\"147\":1}}],[\"临键锁\",{\"0\":{\"149\":1},\"1\":{\"146\":1}}],[\"临时表\",{\"0\":{\"70\":1}}],[\"产生幻读\",{\"1\":{\"146\":1}}],[\"产生的\",{\"1\":{\"83\":2}}],[\"防止其他事务在这个间隙进行insert\",{\"1\":{\"146\":1}}],[\"防止其他事务对此行进行update和delete\",{\"1\":{\"146\":1}}],[\"间隙锁\",{\"0\":{\"148\":1},\"1\":{\"146\":1}}],[\"写响应结果\",{\"1\":{\"461\":1}}],[\"写\",{\"1\":{\"406\":1,\"407\":1}}],[\"写数据时\",{\"1\":{\"401\":1}}],[\"写入用户空间\",{\"1\":{\"404\":1}}],[\"写入\",{\"1\":{\"356\":1}}],[\"写入传播到一个外部数据源当中\",{\"1\":{\"281\":1}}],[\"写命令执行完先放入\",{\"1\":{\"320\":2}}],[\"写出\",{\"1\":{\"319\":1}}],[\"写满以后会覆盖最早的数据\",{\"1\":{\"301\":1}}],[\"写上以后会使sql的可读性更高\",{\"1\":{\"177\":1}}],[\"写锁既会阻塞其他客户端的读\",{\"1\":{\"143\":1}}],[\"写结果\",{\"1\":{\"21\":1,\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":1}}],[\"元数据锁\",{\"0\":{\"144\":1},\"1\":{\"142\":1}}],[\"元素个数\",{\"1\":{\"432\":1}}],[\"元素数据类型不限\",{\"1\":{\"421\":1}}],[\"元素数量小于\",{\"1\":{\"419\":1}}],[\"元素越多耗费内存就越多的集合形成鲜明对⽐\",{\"1\":{\"398\":1}}],[\"元素\",{\"1\":{\"396\":1}}],[\"元素不重复\",{\"1\":{\"380\":1}}],[\"元素不可重复\",{\"1\":{\"379\":1}}],[\"元素可以重复\",{\"1\":{\"378\":1}}],[\"元素后移语句将执行\",{\"1\":{\"36\":1}}],[\"元素后移语句将不执行\",{\"1\":{\"36\":1}}],[\"元素之间的关系由存储单元的邻接关系来体现\",{\"1\":{\"33\":1}}],[\"备份\",{\"1\":{\"139\":1}}],[\"备注信息\",{\"1\":{\"229\":1}}],[\"备注\",{\"0\":{\"307\":1},\"1\":{\"126\":1,\"246\":1}}],[\"已废弃\",{\"1\":{\"466\":1}}],[\"已处理\",{\"1\":{\"385\":1}}],[\"已经注册到了\",{\"1\":{\"408\":1}}],[\"已经被覆盖时\",{\"1\":{\"302\":1}}],[\"已经更新操作的事务提交语句都将被阻塞\",{\"1\":{\"138\":1}}],[\"已连接状态\",{\"1\":{\"15\":2}}],[\"加一\",{\"1\":{\"470\":1}}],[\"加\",{\"1\":{\"380\":1}}],[\"加上\",{\"1\":{\"372\":1}}],[\"加上参数\",{\"1\":{\"202\":1}}],[\"加载\",{\"1\":{\"309\":2}}],[\"加载openresty的lua模块\",{\"1\":{\"307\":1}}],[\"加载master\",{\"1\":{\"300\":1}}],[\"加入键的时候如果过限\",{\"1\":{\"276\":3,\"456\":3}}],[\"加入键的时候\",{\"1\":{\"276\":1,\"456\":1}}],[\"加的行锁与表锁的冲突\",{\"1\":{\"145\":1}}],[\"加mdl写锁\",{\"1\":{\"144\":1}}],[\"加mdl读锁\",{\"1\":{\"144\":1}}],[\"加锁\",{\"1\":{\"139\":1,\"143\":1}}],[\"加锁后整个实例就处于只读状态\",{\"1\":{\"138\":1}}],[\"加快处理速度\",{\"1\":{\"61\":1}}],[\"全栈指南\",{\"0\":{\"547\":1}}],[\"全称为\",{\"1\":{\"319\":1,\"320\":1,\"365\":1}}],[\"全量同步的流程\",{\"1\":{\"300\":1}}],[\"全量同步\",{\"0\":{\"300\":1},\"1\":{\"302\":1}}],[\"全部字段添加数据\",{\"1\":{\"180\":1}}],[\"全局锁就是对整个数据库实例加锁\",{\"1\":{\"138\":1}}],[\"全局锁\",{\"0\":{\"137\":1}}],[\"全文索引查找的是文本中的关键词\",{\"1\":{\"124\":1}}],[\"全文索引\",{\"1\":{\"124\":2,\"236\":1}}],[\"从功能组成上看\",{\"0\":{\"571\":1},\"1\":{\"571\":1}}],[\"从工作方式上看\",{\"0\":{\"570\":1},\"1\":{\"570\":1}}],[\"从组成部分上看\",{\"0\":{\"569\":1},\"1\":{\"569\":1}}],[\"从左边网格向右移动\",{\"1\":{\"511\":1}}],[\"从左上角开始\",{\"1\":{\"509\":1}}],[\"从上边网格向下移动\",{\"1\":{\"511\":1}}],[\"从小到大遍历\",{\"1\":{\"503\":1}}],[\"从第三个数开始\",{\"1\":{\"498\":1}}],[\"从最小的饼干开始\",{\"1\":{\"492\":1}}],[\"从最后一次写入操作开始计时\",{\"1\":{\"283\":1}}],[\"从微观上看\",{\"1\":{\"446\":1}}],[\"从宏观上看\",{\"1\":{\"446\":1}}],[\"从本质上来说\",{\"1\":{\"397\":1}}],[\"从key⾥返回所有给定位置元素的位置\",{\"1\":{\"396\":1}}],[\"从尾部开始消费\",{\"1\":{\"393\":1}}],[\"从头开始消费\",{\"1\":{\"393\":1}}],[\"从大到小\",{\"1\":{\"385\":1}}],[\"从脚本缓存中移除所有脚本\",{\"1\":{\"384\":1}}],[\"从redis中获取一条数据\",{\"1\":{\"351\":1}}],[\"从磁盘读取快照文件\",{\"1\":{\"319\":1}}],[\"从链式结构\",{\"1\":{\"301\":1}}],[\"从节点都叫做\",{\"1\":{\"293\":1}}],[\"从\",{\"1\":{\"288\":1,\"301\":1,\"421\":1}}],[\"从所有键中驱逐使用频率最少的键\",{\"1\":{\"276\":1,\"456\":1}}],[\"从所有配置了过期时间的键中驱逐使用频率最少的键\",{\"1\":{\"276\":1,\"456\":1}}],[\"从所有key随机删除\",{\"1\":{\"276\":1,\"456\":1}}],[\"从配置了过期时间的键中驱逐马上就要过期的键\",{\"1\":{\"276\":1,\"456\":1}}],[\"从过期键的集合中随机驱逐\",{\"1\":{\"276\":1,\"456\":1}}],[\"从越大数据开始的分页\",{\"1\":{\"216\":1}}],[\"从mysql安装到mysql高级\",{\"1\":{\"171\":1}}],[\"从这个角度来说\",{\"1\":{\"136\":1}}],[\"从而利用空闲计算机资源以提高整个系统的利用率\",{\"1\":{\"575\":1}}],[\"从而极大地提高硬件资源\",{\"1\":{\"574\":1}}],[\"从而避免无效的等待\",{\"1\":{\"404\":1}}],[\"从而将\",{\"1\":{\"304\":1}}],[\"从而为应用程序提供灵活的扩展和定制功能\",{\"1\":{\"286\":1}}],[\"从而使得用户不必为以后的操作每次指定全部的查询条件\",{\"1\":{\"167\":1}}],[\"从而使得逻辑上相邻的两个元素在物理上也相邻\",{\"1\":{\"36\":1}}],[\"从而获取一致性视图\",{\"1\":{\"138\":1}}],[\"从而提高索引效率\",{\"1\":{\"132\":1}}],[\"从而提高语句的效率\",{\"1\":{\"56\":1}}],[\"从而确保多对多的关系\",{\"1\":{\"92\":1}}],[\"从而减少磁盘io\",{\"1\":{\"61\":1}}],[\"从而形成一个自己熟悉且较为完备的知识体系\",{\"1\":{\"2\":1}}],[\"介绍和基本语法\",{\"0\":{\"161\":1}}],[\"介绍\",{\"0\":{\"136\":1,\"138\":1,\"142\":1,\"153\":1,\"162\":1,\"239\":1,\"358\":1},\"1\":{\"189\":1,\"234\":1,\"235\":1,\"236\":1}}],[\"避免配置干扰\",{\"1\":{\"339\":1}}],[\"避免主进程受到影响\",{\"1\":{\"319\":1}}],[\"避免全量同步时的磁盘\",{\"1\":{\"301\":1}}],[\"避免被猜测id规律\",{\"1\":{\"270\":1}}],[\"避免回表查询\",{\"1\":{\"214\":1}}],[\"避免回表\",{\"1\":{\"134\":1}}],[\"避免同一个表中某数据列中的值重复\",{\"1\":{\"124\":1}}],[\"排列\",{\"1\":{\"541\":1}}],[\"排列的整数数组\",{\"1\":{\"541\":1}}],[\"排他\",{\"1\":{\"144\":1}}],[\"排他锁\",{\"1\":{\"80\":1,\"147\":1}}],[\"排序方式\",{\"1\":{\"191\":1}}],[\"排序方式2\",{\"1\":{\"191\":1}}],[\"排序方式1\",{\"1\":{\"191\":1}}],[\"排序查询\",{\"0\":{\"191\":1},\"1\":{\"185\":1}}],[\"排序字段列表\",{\"1\":{\"184\":1,\"193\":1}}],[\"排序规则\",{\"1\":{\"176\":1}}],[\"排序\",{\"1\":{\"134\":1}}],[\"能根据自己的指令\",{\"1\":{\"464\":1}}],[\"能监听的\",{\"1\":{\"410\":1}}],[\"能否继续重复\",{\"1\":{\"289\":1}}],[\"能大量减少对数据库的访问\",{\"1\":{\"280\":1}}],[\"能够看到当前mysql是否支持profile操作\",{\"1\":{\"228\":1}}],[\"能够指出文章中一些能够完美\",{\"1\":{\"3\":1}}],[\"能通过索引直接查到\",{\"1\":{\"131\":1}}],[\"覆盖索引\",{\"0\":{\"131\":1},\"1\":{\"214\":1}}],[\"强制索引\",{\"1\":{\"130\":1}}],[\"哪里不满足\",{\"1\":{\"129\":1}}],[\"括号内为长度\",{\"1\":{\"129\":1}}],[\"746\",{\"0\":{\"531\":1},\"1\":{\"533\":1}}],[\"70\",{\"0\":{\"518\":1},\"1\":{\"520\":1}}],[\"7004\",{\"1\":{\"344\":9}}],[\"7003这几个目录\",{\"1\":{\"339\":1}}],[\"7003\",{\"1\":{\"294\":1,\"295\":10,\"296\":2,\"297\":2,\"338\":1,\"339\":5,\"340\":2,\"341\":2,\"346\":1}}],[\"7002和7003这两个slave节点只能执行读操作\",{\"1\":{\"298\":1}}],[\"7002\",{\"1\":{\"294\":1,\"295\":10,\"296\":2,\"297\":2,\"327\":1,\"338\":1,\"339\":6,\"340\":2,\"341\":2,\"346\":1}}],[\"7001节点\",{\"1\":{\"297\":1}}],[\"7001\",{\"1\":{\"294\":1,\"295\":8,\"296\":2,\"297\":4,\"331\":3,\"338\":1,\"339\":4,\"340\":2,\"341\":3,\"342\":2,\"344\":3,\"346\":1}}],[\"7\",{\"1\":{\"129\":2,\"193\":1,\"201\":2,\"466\":1,\"509\":2,\"514\":4,\"532\":1}}],[\"|10000000|qqqqqqqq|rrrrrrrr|ssssssss|ttttttt|\",{\"1\":{\"442\":1}}],[\"|01pppppp|qqqqqqqq|\",{\"1\":{\"442\":1}}],[\"|00pppppp|\",{\"1\":{\"442\":1}}],[\"|\",{\"1\":{\"127\":2,\"163\":3,\"226\":1,\"242\":6,\"259\":3,\"295\":2,\"296\":1,\"331\":1,\"339\":2,\"340\":6,\"462\":2}}],[\"||\",{\"1\":{\"36\":3,\"187\":1,\"543\":2}}],[\"8个点位都没有\",{\"1\":{\"516\":1}}],[\"88\",{\"0\":{\"540\":1},\"1\":{\"351\":1}}],[\"888\",{\"1\":{\"298\":1}}],[\"8003目录\",{\"1\":{\"339\":1}}],[\"8003\",{\"1\":{\"338\":1,\"339\":3,\"340\":2,\"341\":2,\"346\":1}}],[\"8002\",{\"1\":{\"338\":1,\"339\":4,\"340\":2,\"341\":2,\"346\":1}}],[\"8001\",{\"1\":{\"338\":1,\"339\":4,\"340\":2,\"341\":2,\"346\":1}}],[\"8080\",{\"1\":{\"334\":2}}],[\"8081\",{\"1\":{\"306\":2}}],[\"8\",{\"1\":{\"126\":1,\"201\":2,\"276\":1,\"347\":4,\"351\":1,\"360\":2,\"373\":1,\"415\":1,\"422\":3,\"426\":1,\"442\":2,\"448\":1,\"456\":1,\"465\":1,\"466\":1,\"503\":1,\"514\":3}}],[\"8n2​\",{\"1\":{\"23\":1}}],[\"虽然你有两块小饼干\",{\"1\":{\"491\":1}}],[\"虽然节省内存\",{\"1\":{\"444\":1}}],[\"虽然是非阻塞的\",{\"1\":{\"403\":1}}],[\"虽然\",{\"1\":{\"354\":1}}],[\"虽然服务启动了\",{\"1\":{\"341\":1}}],[\"虽然建立有索引\",{\"1\":{\"126\":1}}],[\"虽然只执行了一条查询语句\",{\"1\":{\"125\":1}}],[\"那些被经常使用的查询可以被定义为视图\",{\"1\":{\"167\":1}}],[\"那个执行效率更高\",{\"1\":{\"126\":1}}],[\"那么第⼀层楼梯再跨两步就到第三层\",{\"1\":{\"521\":1}}],[\"那么我们可以进行分解\",{\"1\":{\"498\":1}}],[\"那么我们必须建立一套完整的机制保证数据能够可靠发送\",{\"1\":{\"16\":1}}],[\"那么最好的情况就是使用最小的饼干\",{\"1\":{\"492\":1}}],[\"那么后面的数都是比他大的数\",{\"1\":{\"482\":1}}],[\"那么当i++单独执行后\",{\"1\":{\"481\":1}}],[\"那么当一个节点数据发生变化时\",{\"1\":{\"443\":1}}],[\"那么说明该对象可以被删除销毁\",{\"1\":{\"470\":1}}],[\"那么验证操作的复杂度将会是o\",{\"1\":{\"469\":1}}],[\"那么验证操作的复杂度为o\",{\"1\":{\"469\":2}}],[\"那么它每个元素占用的内存是一样的且取决于最大的那个元素\",{\"1\":{\"441\":1}}],[\"那么要一次性的进行\",{\"1\":{\"438\":1}}],[\"那么如果删除掉刚加入的int16类型时\",{\"1\":{\"432\":1}}],[\"那么如何解决这些问题呢\",{\"1\":{\"352\":1}}],[\"那么整个整数集合中的元素都会升级为\",{\"1\":{\"432\":1}}],[\"那么事务将被打断\",{\"1\":{\"399\":1}}],[\"那么\",{\"1\":{\"322\":1,\"438\":1,\"443\":1,\"464\":1}}],[\"那么可以像下面这样安装\",{\"1\":{\"305\":1}}],[\"那么选择这个存储引擎是非常合适的\",{\"1\":{\"237\":1}}],[\"那么innodb存储引擎是比较合适的选择\",{\"1\":{\"237\":1}}],[\"那么innodb引擎就会生成一个rowid作为隐藏的聚集索引\",{\"1\":{\"124\":1}}],[\"那么都是可以使用索引进行查询的\",{\"1\":{\"210\":1}}],[\"那么此时慢查询就无法满足我们的需求\",{\"1\":{\"227\":1}}],[\"那么此时需要将数据插入到页中\",{\"1\":{\"205\":1}}],[\"那么此时所有的数据在页内都会顺序排列\",{\"1\":{\"205\":1}}],[\"那么在删除数据时会进行缩容操作吗\",{\"1\":{\"432\":1}}],[\"那么在插入时会伴随页分裂\",{\"1\":{\"205\":1}}],[\"那么在主键乱序插入一组数据以后\",{\"1\":{\"205\":1}}],[\"那么在备份期间从库不能执行主库同步过来的二进制日志\",{\"1\":{\"140\":1}}],[\"那么在备份期间都不能执行更新\",{\"1\":{\"140\":1}}],[\"那么涉及的索引都不会被使用到\",{\"1\":{\"129\":1}}],[\"那么就需要进行第一个和第二个阶梯的初始化\",{\"1\":{\"534\":1}}],[\"那么就可以想到动态规划了\",{\"1\":{\"521\":1}}],[\"那么就是多线程\",{\"1\":{\"458\":1}}],[\"那么就根据\",{\"1\":{\"343\":1}}],[\"那么就不可避免的会出现哈希碰撞\",{\"1\":{\"121\":1}}],[\"那么就存在当客户端发送的连接请求报文段阻塞时\",{\"1\":{\"16\":1}}],[\"那么对应的时间复杂度就是\",{\"1\":{\"23\":1}}],[\"那么对比于三次握手\",{\"1\":{\"16\":1}}],[\"那么各类官方文档是不是更为权威呢\",{\"1\":{\"2\":1}}],[\"那么为什么不去直接使用他们整理好的学习笔记呢\",{\"1\":{\"2\":1}}],[\"回归命令\",{\"0\":{\"553\":1}}],[\"回到步骤三\",{\"1\":{\"408\":1}}],[\"回表查询\",{\"0\":{\"125\":1},\"1\":{\"125\":1}}],[\"回滚事务\",{\"1\":{\"256\":1}}],[\"回滚指针\",{\"1\":{\"82\":1}}],[\"回滚日志\",{\"1\":{\"76\":1,\"83\":1}}],[\"回滚段中\",{\"1\":{\"76\":1}}],[\"回滚段\",{\"1\":{\"58\":1}}],[\"常见指令\",{\"0\":{\"551\":1}}],[\"常见的nosql数据库有\",{\"1\":{\"363\":1}}],[\"常见的取值有simple\",{\"1\":{\"229\":1}}],[\"常见的聚合函数\",{\"1\":{\"189\":1}}],[\"常用来存储一个有序数据\",{\"1\":{\"378\":1}}],[\"常用的数据类型包括5种\",{\"1\":{\"421\":1}}],[\"常用的操作符\",{\"1\":{\"100\":1,\"101\":1,\"102\":1}}],[\"常用的操作符号\",{\"1\":{\"99\":1}}],[\"常用的几个如下所示\",{\"1\":{\"53\":1}}],[\"常规写法\",{\"1\":{\"334\":1}}],[\"常规索引\",{\"1\":{\"124\":2}}],[\"❌\",{\"1\":{\"123\":5,\"259\":6}}],[\"✅\",{\"1\":{\"123\":6,\"259\":6}}],[\"导致一个测试用例过不去\",{\"1\":{\"516\":1}}],[\"导致链表过长\",{\"1\":{\"444\":1}}],[\"导致哈希表的\",{\"1\":{\"438\":1}}],[\"导致的过多磁盘\",{\"1\":{\"301\":1}}],[\"导致数据被覆盖\",{\"1\":{\"301\":1}}],[\"导致请求数据库的总量比较大\",{\"1\":{\"272\":1}}],[\"导致瞬间大量请求到达数据库\",{\"1\":{\"271\":1}}],[\"导致性能降低\",{\"1\":{\"122\":1}}],[\"导致正常的连接请求无法响应或者缓慢响应\",{\"1\":{\"15\":1}}],[\"无上限\",{\"1\":{\"406\":1}}],[\"无序\",{\"1\":{\"379\":1}}],[\"无关联\",{\"1\":{\"364\":1}}],[\"无需了解网络的存在\",{\"1\":{\"567\":1}}],[\"无需阻塞等待\",{\"1\":{\"411\":1}}],[\"无需重复拷贝\",{\"1\":{\"410\":1}}],[\"无需传递任何参数\",{\"1\":{\"410\":1}}],[\"无需关心缓存一致性问题\",{\"1\":{\"275\":1}}],[\"无需显示使用\",{\"1\":{\"144\":1}}],[\"无\",{\"1\":{\"274\":1}}],[\"无数的请求访问会在瞬间给数据库带来巨大的冲击\",{\"1\":{\"272\":1}}],[\"无法响应客户端请求\",{\"1\":{\"319\":1}}],[\"无法共享\",{\"1\":{\"280\":1}}],[\"无法再压缩sql的执行时间\",{\"1\":{\"227\":1}}],[\"无法利用索引完成排序操作\",{\"1\":{\"121\":1}}],[\"无论我们怎么变化\",{\"1\":{\"481\":1}}],[\"无论是否在执行bgsave\",{\"1\":{\"437\":1}}],[\"无论是否定义\",{\"1\":{\"164\":1}}],[\"无论是阻塞\",{\"1\":{\"404\":1}}],[\"无论是在远程连接或者本地连接\",{\"1\":{\"372\":1}}],[\"无论是叶子结点还是非叶子结点\",{\"1\":{\"122\":1}}],[\"无论影响多少行\",{\"1\":{\"153\":1}}],[\"无论将哪张表放在左边\",{\"1\":{\"96\":1}}],[\"拉链法\",{\"1\":{\"121\":1}}],[\"知识点\",{\"1\":{\"121\":1}}],[\"知识只有被系统性的归纳起来\",{\"1\":{\"2\":1}}],[\"哈希大小\",{\"1\":{\"436\":1}}],[\"哈希算法\",{\"1\":{\"435\":1}}],[\"哈希节点\",{\"1\":{\"435\":1,\"436\":1}}],[\"哈希表大小\",{\"1\":{\"437\":1}}],[\"哈希表大小的掩码\",{\"1\":{\"436\":1}}],[\"哈希表已保存节点数量\",{\"1\":{\"437\":1}}],[\"哈希表的\",{\"1\":{\"437\":2}}],[\"哈希表\",{\"1\":{\"435\":1,\"436\":1,\"467\":1}}],[\"哈希表dict\",{\"0\":{\"434\":1}}],[\"哈希结构与\",{\"1\":{\"417\":1}}],[\"哈希对象\",{\"1\":{\"469\":3}}],[\"哈希对象的编码可以是\",{\"1\":{\"417\":1}}],[\"哈希对象的键是一个字符串类型\",{\"1\":{\"417\":1}}],[\"哈希对象hash\",{\"0\":{\"417\":1}}],[\"哈希\",{\"0\":{\"377\":1}}],[\"哈希索引的特点\",{\"1\":{\"121\":1}}],[\"哈希索引就是采用一定的hash算法\",{\"1\":{\"121\":1}}],[\"哈希冲突\",{\"1\":{\"121\":1,\"435\":2}}],[\"映射到对应的槽位上\",{\"1\":{\"121\":1}}],[\"相反如果执行的是收缩操作\",{\"1\":{\"437\":1}}],[\"相比\",{\"1\":{\"408\":1}}],[\"相关业务对数据安全性\",{\"1\":{\"364\":1}}],[\"相关信息\",{\"1\":{\"149\":1,\"373\":1}}],[\"相对于铺天盖地的关系型数据库运用\",{\"1\":{\"363\":1}}],[\"相对于二叉树\",{\"1\":{\"122\":1}}],[\"相对完整\",{\"1\":{\"321\":1}}],[\"相同的输入参数总是产生相同的结果\",{\"1\":{\"254\":1}}],[\"相邻的叶子结点会有一个单向的指针连接\",{\"1\":{\"119\":1}}],[\"相当于查询数据表a\",{\"1\":{\"94\":1}}],[\"待更新\",{\"1\":{\"472\":1,\"475\":1}}],[\"待更新b树\",{\"1\":{\"118\":1}}],[\"待查询时再创建缓存\",{\"1\":{\"275\":1}}],[\"待数据传输完成以后\",{\"1\":{\"17\":1}}],[\"树的度数指的是一个节点的子节点个数\",{\"1\":{\"118\":1}}],[\"树形结构\",{\"1\":{\"33\":1}}],[\"小鹏\",{\"1\":{\"422\":5}}],[\"小米11\",{\"1\":{\"376\":1}}],[\"小于nums\",{\"1\":{\"481\":1}}],[\"小于redis\",{\"1\":{\"469\":1}}],[\"小于等于\",{\"1\":{\"187\":1}}],[\"小于\",{\"1\":{\"187\":1,\"300\":1,\"432\":2}}],[\"小贴士\",{\"1\":{\"131\":1,\"206\":1}}],[\"小知识\",{\"1\":{\"118\":1,\"133\":1,\"159\":1,\"205\":1}}],[\"小结\",{\"0\":{\"328\":1,\"356\":1},\"1\":{\"17\":1}}],[\"红黑树虽然解决了退化为单链表的这种现象\",{\"1\":{\"117\":1}}],[\"红黑树\",{\"0\":{\"117\":1},\"1\":{\"117\":1}}],[\"二进制安全\",{\"1\":{\"427\":1}}],[\"二级索引\",{\"1\":{\"124\":1}}],[\"二级索引通常情况下是非唯一的\",{\"1\":{\"62\":1}}],[\"二叉树\",{\"0\":{\"116\":1},\"1\":{\"116\":1}}],[\"快照\",{\"1\":{\"319\":1}}],[\"快照文件称为\",{\"1\":{\"319\":1}}],[\"快照读会退化为当前读\",{\"1\":{\"81\":1}}],[\"快照读读取的是记录数据的可见版本\",{\"1\":{\"81\":1}}],[\"快照读\",{\"0\":{\"81\":1}}],[\"快照读为mysql实现mvcc提供了一个非阻塞读功能\",{\"1\":{\"79\":1}}],[\"快速列表\",{\"1\":{\"466\":1}}],[\"快速列表quicklist\",{\"0\":{\"445\":1}}],[\"快速构造出足以胜任\",{\"1\":{\"304\":1}}],[\"快速入门\",{\"0\":{\"287\":1,\"351\":1}}],[\"快速定位特定数据\",{\"1\":{\"124\":1}}],[\"快速匹配文档的方式\",{\"1\":{\"115\":1}}],[\"只共享字符串对象\",{\"1\":{\"469\":1}}],[\"只要是能实现远程信息处理的系统或者能进一步达到资源共享的系统\",{\"1\":{\"565\":1}}],[\"只要\",{\"1\":{\"464\":1}}],[\"只要求逻辑相邻\",{\"1\":{\"33\":1}}],[\"只包含设置了\",{\"1\":{\"454\":1}}],[\"只减不增\",{\"1\":{\"439\":1}}],[\"只需要把排序有关的\",{\"1\":{\"417\":1}}],[\"只需要执行一次\",{\"1\":{\"410\":1}}],[\"只会通知一次\",{\"1\":{\"408\":1}}],[\"只会通知用户进程有fd就绪\",{\"1\":{\"404\":1}}],[\"只会根据输⼊元素来计算基数\",{\"1\":{\"398\":1}}],[\"只接受新消息\",{\"1\":{\"393\":1}}],[\"只不过链表中的每个节点都是一个\",{\"1\":{\"444\":1}}],[\"只不过在没有元素时等待指定时间\",{\"1\":{\"378\":1}}],[\"只不过在写入之前会把\",{\"1\":{\"352\":1}}],[\"只不过是编码方式不同\",{\"1\":{\"376\":1}}],[\"只不过获取到的值为null\",{\"1\":{\"243\":1}}],[\"只复制了对应的页表\",{\"1\":{\"319\":1}}],[\"只是字符串是异常信息\",{\"1\":{\"421\":1}}],[\"只是记录被标记\",{\"1\":{\"206\":1}}],[\"只是保存了查询的sql逻辑\",{\"1\":{\"162\":1}}],[\"只有指针才能够指向任意的地址\",{\"1\":{\"469\":1}}],[\"只有在7001这个master节点上可以执行写操作\",{\"1\":{\"298\":1}}],[\"只有值\",{\"1\":{\"288\":1}}],[\"只有很少的更新和删除操作\",{\"1\":{\"237\":1}}],[\"只有这一个\",{\"1\":{\"236\":1}}],[\"只有当第一个字段的值相同时\",{\"1\":{\"191\":1}}],[\"只有共享锁和共享锁之间是兼容的\",{\"1\":{\"147\":1}}],[\"只有精确匹配索引列的查询才有效\",{\"1\":{\"115\":1}}],[\"只能依次处理每一个\",{\"1\":{\"404\":1}}],[\"只能再次全量同步\",{\"1\":{\"301\":1}}],[\"只能将这些表作为临时表或者缓存使用\",{\"1\":{\"236\":1}}],[\"只能有一个\",{\"1\":{\"124\":1}}],[\"只能增加树的高度\",{\"1\":{\"122\":1}}],[\"底层是数组加链表来解决哈希冲突\",{\"1\":{\"439\":1}}],[\"底层所使用的字符串表示\",{\"1\":{\"428\":1}}],[\"底层实现\",{\"0\":{\"426\":1,\"431\":1,\"436\":1,\"447\":1,\"452\":1,\"462\":1},\"1\":{\"432\":1}}],[\"底层存储为\",{\"1\":{\"421\":1}}],[\"底层同时使用了两种结构\",{\"1\":{\"419\":1}}],[\"底层同样基于\",{\"1\":{\"346\":1}}],[\"底层数据结构必须满足键值存储\",{\"1\":{\"419\":1}}],[\"底层数据结构是用哈希表实现的\",{\"1\":{\"115\":1}}],[\"底层采用二分查找方式来查询\",{\"1\":{\"433\":1}}],[\"底层采用的编码与\",{\"1\":{\"417\":1}}],[\"底层采用链表数据结构管理page\",{\"1\":{\"61\":1}}],[\"底层的实现是一个跳表\",{\"1\":{\"380\":1}}],[\"底层都是字节数组形式存储\",{\"1\":{\"376\":1}}],[\"底层利用\",{\"1\":{\"334\":1}}],[\"效果相同\",{\"1\":{\"377\":1}}],[\"效果更佳\",{\"1\":{\"20\":1}}],[\"效率更高\",{\"1\":{\"415\":1}}],[\"效率\",{\"1\":{\"401\":1}}],[\"效率提升\",{\"1\":{\"239\":1}}],[\"效率排行\",{\"1\":{\"221\":1}}],[\"效率很高\",{\"1\":{\"219\":1}}],[\"效率相对较低\",{\"1\":{\"213\":1}}],[\"效率通常要高于b+tree索引\",{\"1\":{\"121\":1}}],[\"效率降低\",{\"1\":{\"114\":1}}],[\"优先用最大的饼干满足胃口最大的孩子\",{\"1\":{\"492\":1}}],[\"优先级越高\",{\"1\":{\"326\":1}}],[\"优化版\",{\"0\":{\"538\":1}}],[\"优化\",{\"1\":{\"506\":1}}],[\"优化自定义序列化\",{\"0\":{\"355\":1}}],[\"优化思路\",{\"0\":{\"218\":1,\"220\":1}}],[\"优化场景\",{\"0\":{\"216\":1}}],[\"优化的b+树\",{\"0\":{\"120\":1}}],[\"优点\",{\"1\":{\"114\":1,\"234\":1,\"270\":2,\"272\":1,\"280\":2,\"320\":1,\"427\":1}}],[\"优缺点\",{\"0\":{\"114\":1}}],[\"gird\",{\"1\":{\"516\":1}}],[\"given\",{\"1\":{\"432\":1}}],[\"gitee\",{\"1\":{\"373\":1,\"549\":1}}],[\"gitee地址\",{\"1\":{\"373\":1}}],[\"github地址\",{\"1\":{\"373\":1}}],[\"github\",{\"1\":{\"280\":2,\"281\":1,\"350\":1,\"373\":1}}],[\"go语言的go\",{\"1\":{\"374\":1}}],[\"g\",{\"1\":{\"295\":6,\"331\":4,\"339\":1,\"344\":1,\"491\":4,\"494\":4}}],[\"gcc\",{\"1\":{\"305\":1}}],[\"gc\",{\"1\":{\"283\":1}}],[\"guava\",{\"1\":{\"281\":2}}],[\"guavacache\",{\"1\":{\"280\":1}}],[\"globle|session\",{\"1\":{\"228\":1}}],[\"global\",{\"1\":{\"202\":1,\"226\":2,\"242\":7}}],[\"gap\",{\"1\":{\"146\":1}}],[\"grid\",{\"1\":{\"512\":9,\"514\":12,\"516\":4,\"517\":26}}],[\"grep\",{\"1\":{\"340\":2}}],[\"grant\",{\"1\":{\"196\":1}}],[\"grants\",{\"1\":{\"196\":1}}],[\"graph类型\",{\"1\":{\"364\":1}}],[\"graph\",{\"1\":{\"109\":2}}],[\"groupname\",{\"1\":{\"393\":5}}],[\"groups\",{\"1\":{\"385\":1}}],[\"groupid>\",{\"1\":{\"334\":1,\"351\":2,\"353\":1,\"360\":1}}],[\"group\",{\"0\":{\"212\":1,\"394\":1},\"1\":{\"134\":1,\"166\":1,\"184\":1,\"185\":1,\"190\":1,\"193\":1,\"385\":2,\"393\":2,\"394\":6}}],[\"geohash\",{\"1\":{\"396\":4}}],[\"georadiusbymember\",{\"1\":{\"396\":2}}],[\"georadius\",{\"1\":{\"396\":2}}],[\"geodist\",{\"1\":{\"396\":2}}],[\"geopos\",{\"1\":{\"396\":2}}],[\"geoadd\",{\"1\":{\"396\":2}}],[\"geographic\",{\"1\":{\"396\":1}}],[\"geo类型\",{\"0\":{\"396\":1}}],[\"geo\",{\"1\":{\"375\":1,\"395\":1,\"396\":1}}],[\"genericjackson2jsonredisserializer\",{\"1\":{\"353\":5,\"356\":1}}],[\"general\",{\"0\":{\"68\":1}}],[\"gem\",{\"1\":{\"341\":1}}],[\"getmaximumgenerated\",{\"1\":{\"488\":1}}],[\"getmapping\",{\"1\":{\"334\":2}}],[\"getinputstream\",{\"1\":{\"422\":1}}],[\"getifpresent\",{\"1\":{\"282\":1}}],[\"getoutputstream\",{\"1\":{\"422\":1}}],[\"getbytes\",{\"1\":{\"422\":1}}],[\"getbyindex\",{\"1\":{\"36\":1}}],[\"getbit\",{\"1\":{\"397\":1}}],[\"getting\",{\"1\":{\"366\":1}}],[\"get方法\",{\"1\":{\"354\":1}}],[\"getresource\",{\"1\":{\"347\":1}}],[\"getjedis\",{\"1\":{\"347\":1}}],[\"getkey\",{\"1\":{\"334\":1}}],[\"get请求参数\",{\"1\":{\"311\":2}}],[\"get\",{\"1\":{\"282\":1,\"307\":2,\"334\":3,\"342\":1,\"351\":1,\"354\":1,\"360\":1,\"376\":1,\"422\":1,\"448\":1}}],[\"getlistlen\",{\"1\":{\"37\":1}}],[\"getelem\",{\"1\":{\"35\":1}}],[\"图形化界⾯的客户端种类很多\",{\"1\":{\"373\":1}}],[\"图形化客户端\",{\"0\":{\"373\":1},\"1\":{\"371\":1,\"373\":1}}],[\"图形\",{\"1\":{\"109\":1}}],[\"图状结构或网状结构\",{\"1\":{\"33\":1}}],[\"注册\",{\"1\":{\"459\":1,\"462\":2}}],[\"注册的实例ip\",{\"1\":{\"339\":1}}],[\"注释内容\",{\"1\":{\"173\":3}}],[\"注释\",{\"1\":{\"173\":2,\"283\":1}}],[\"注\",{\"1\":{\"109\":4}}],[\"注意边界控制即可\",{\"1\":{\"511\":1}}],[\"注意ip地址替换为你自己的虚拟机ip\",{\"1\":{\"306\":1}}],[\"注意事项\",{\"0\":{\"211\":1,\"214\":1,\"223\":1}}],[\"注意\",{\"1\":{\"36\":1,\"47\":1,\"86\":1,\"96\":1,\"97\":1,\"114\":1,\"127\":1,\"139\":1,\"143\":1,\"180\":1,\"189\":1,\"190\":1,\"192\":1,\"195\":1,\"210\":1,\"240\":1,\"242\":1,\"243\":1,\"259\":1,\"301\":1,\"347\":1,\"353\":1,\"372\":1,\"380\":1,\"399\":1,\"461\":1,\"467\":1,\"469\":1,\"477\":2,\"514\":1,\"534\":1,\"541\":2,\"557\":1}}],[\"标示\",{\"1\":{\"448\":2}}],[\"标示开始rehash\",{\"1\":{\"438\":2}}],[\"标识信息\",{\"1\":{\"426\":1}}],[\"标识符对应信息\",{\"1\":{\"426\":1}}],[\"标准统一\",{\"1\":{\"108\":1}}],[\"标量子查询指的是子查询的返回的结果是一行一列的一个值\",{\"1\":{\"99\":1}}],[\"标量子查询\",{\"0\":{\"99\":1},\"1\":{\"98\":1}}],[\"便于判断空闲时间太久的key\",{\"1\":{\"465\":1}}],[\"便于维护\",{\"1\":{\"108\":1}}],[\"便于系统异常时恢复数据\",{\"1\":{\"71\":1}}],[\"特殊值\",{\"1\":{\"448\":1}}],[\"特殊类型作为了解即可\",{\"1\":{\"375\":1,\"395\":1}}],[\"特殊类型\",{\"1\":{\"375\":1,\"395\":1}}],[\"特征也与linkedlist类似\",{\"1\":{\"378\":1}}],[\"特点\",{\"0\":{\"140\":1},\"1\":{\"108\":1,\"124\":2,\"234\":1,\"235\":1,\"236\":2,\"239\":1}}],[\"特性\",{\"1\":{\"86\":1}}],[\"建议不开启\",{\"1\":{\"319\":1}}],[\"建议建立联合索引\",{\"1\":{\"133\":1}}],[\"建议使用索引\",{\"1\":{\"130\":1}}],[\"建立公共溢出区等方法解决\",{\"1\":{\"435\":1}}],[\"建立公共溢出区等方法进行解决\",{\"1\":{\"121\":1}}],[\"建立连接\",{\"1\":{\"422\":1}}],[\"建立前缀索引\",{\"1\":{\"134\":1}}],[\"建立索引时也会区分字段的排序规则\",{\"1\":{\"210\":1}}],[\"建立索引\",{\"1\":{\"132\":1,\"232\":1}}],[\"建立在关系模型基础上\",{\"1\":{\"108\":1}}],[\"建表后添加外键\",{\"1\":{\"49\":1}}],[\"建表时添加外键\",{\"1\":{\"49\":1}}],[\"商业版\",{\"1\":{\"106\":1}}],[\"免费\",{\"1\":{\"106\":1}}],[\"社区版\",{\"1\":{\"106\":1}}],[\"又能从左边网格向右移动\",{\"1\":{\"511\":1}}],[\"又可以成为哈希类型\",{\"1\":{\"377\":1}}],[\"又可以分为3类\",{\"1\":{\"376\":1}}],[\"又可以分为两类\",{\"1\":{\"143\":1}}],[\"又可以分为以下两种\",{\"1\":{\"124\":1}}],[\"又发现数据已经存在\",{\"1\":{\"258\":1}}],[\"又会阻塞其他客户端的读\",{\"1\":{\"143\":1}}],[\"又叫组合索引\",{\"1\":{\"127\":1}}],[\"又叫架构话查询语言\",{\"1\":{\"104\":1}}],[\"又称为多路平衡查找树\",{\"1\":{\"118\":1}}],[\"又称为哈希\",{\"1\":{\"33\":1}}],[\"操作可以瞬间完成\",{\"1\":{\"438\":1}}],[\"操作是同步还是异步\",{\"1\":{\"413\":1}}],[\"操作时\",{\"1\":{\"411\":1}}],[\"操作会立即返回结果\",{\"1\":{\"403\":1}}],[\"操作并将结果保存在destkey中\",{\"1\":{\"397\":1}}],[\"操作redis指令\",{\"1\":{\"370\":1}}],[\"操作sortedset类型数据\",{\"1\":{\"359\":1}}],[\"操作set类型数据\",{\"1\":{\"359\":1}}],[\"操作string类型数据\",{\"1\":{\"359\":1}}],[\"操作list类型数据\",{\"1\":{\"359\":1}}],[\"操作hash类型数据\",{\"1\":{\"359\":1}}],[\"操作api\",{\"0\":{\"359\":1}}],[\"操作\",{\"1\":{\"356\":1}}],[\"操作一个\",{\"1\":{\"352\":1}}],[\"操作系统控制\",{\"1\":{\"320\":1}}],[\"操作较慢\",{\"1\":{\"319\":1}}],[\"操作效率较高\",{\"1\":{\"209\":1}}],[\"操作语法\",{\"0\":{\"163\":1}}],[\"操作的字段建立索引\",{\"1\":{\"134\":1}}],[\"操作关系型数据库的编程语言\",{\"1\":{\"104\":1}}],[\"操作符\",{\"1\":{\"100\":1}}],[\"操纵和管理数据库的大型软件系统\",{\"1\":{\"104\":1}}],[\"简化\",{\"1\":{\"422\":1}}],[\"简称为sds\",{\"1\":{\"425\":1}}],[\"简称\",{\"1\":{\"408\":2}}],[\"简称fd\",{\"1\":{\"404\":1}}],[\"简称replid\",{\"1\":{\"300\":1}}],[\"简介\",{\"0\":{\"349\":1}}],[\"简述全量同步和增量同步的区别\",{\"1\":{\"302\":1}}],[\"简写为database\",{\"1\":{\"104\":2}}],[\"简单说一下原因\",{\"1\":{\"481\":1}}],[\"简单表\",{\"1\":{\"229\":1}}],[\"简单理解\",{\"1\":{\"162\":1,\"164\":1}}],[\"简单的来说\",{\"1\":{\"162\":1}}],[\"简单的select语句\",{\"1\":{\"81\":1}}],[\"简单来说发布订阅\",{\"1\":{\"385\":1}}],[\"简单来说就是把内存中的所有数据都记录到磁盘中\",{\"1\":{\"319\":1}}],[\"简单来说\",{\"1\":{\"130\":1}}],[\"简单\",{\"0\":{\"22\":1},\"1\":{\"167\":1}}],[\"子进程\",{\"1\":{\"319\":1}}],[\"子进程读取内存数据并写入新的\",{\"1\":{\"319\":1}}],[\"子进程共享主进程的内存数据\",{\"1\":{\"319\":1}}],[\"子句或者是操作表的顺序\",{\"1\":{\"229\":1}}],[\"子句创建视图时\",{\"1\":{\"164\":1}}],[\"子查询的返回列表的所有值都必须满足\",{\"1\":{\"100\":1}}],[\"子查询的返回列表中\",{\"1\":{\"100\":1}}],[\"子查询的结果为多行多列\",{\"1\":{\"98\":1}}],[\"子查询的结果为一行\",{\"1\":{\"98\":1}}],[\"子查询的结果为一列\",{\"1\":{\"98\":1}}],[\"子查询的结果为单个值\",{\"1\":{\"98\":1}}],[\"子查询的外部可以是insert\",{\"1\":{\"98\":1}}],[\"子查询又称为嵌套查询\",{\"1\":{\"98\":1}}],[\"子查询\",{\"0\":{\"98\":1}}],[\"子表将外键列设置成一个默认的值\",{\"1\":{\"50\":1}}],[\"别名2\",{\"1\":{\"186\":1}}],[\"别名1\",{\"1\":{\"186\":1}}],[\"别名b\",{\"1\":{\"96\":1}}],[\"别名a\",{\"1\":{\"96\":1}}],[\"别无其他关系\",{\"1\":{\"33\":1}}],[\"右外连接\",{\"1\":{\"95\":2}}],[\"右填充\",{\"1\":{\"53\":1}}],[\"查4个部分\",{\"1\":{\"179\":1}}],[\"查找快\",{\"1\":{\"379\":1}}],[\"查找使用了索引\",{\"1\":{\"131\":2}}],[\"查找的元素在最后一个\",{\"1\":{\"36\":1}}],[\"查找的元素就在第一个\",{\"1\":{\"36\":1}}],[\"查看流和消费者组的相关信息\",{\"1\":{\"385\":1}}],[\"查看订阅与发布系统状态\",{\"1\":{\"381\":1}}],[\"查看⼀个key的剩余有效期\",{\"1\":{\"361\":1}}],[\"查看符合模板的所有key\",{\"1\":{\"361\":1}}],[\"查看集群信息时就能看到\",{\"1\":{\"343\":1}}],[\"查看集群状态\",{\"1\":{\"297\":1}}],[\"查看7002的日志\",{\"1\":{\"333\":1}}],[\"查看7003的日志\",{\"1\":{\"333\":1}}],[\"查看sentinel日志\",{\"1\":{\"333\":1}}],[\"查看openresty目录的nginx目录\",{\"1\":{\"306\":1}}],[\"查看状态\",{\"1\":{\"297\":1,\"370\":1}}],[\"查看事务的隔离级别\",{\"1\":{\"259\":1}}],[\"查看所有系统变量\",{\"1\":{\"242\":1}}],[\"查看系统变量\",{\"1\":{\"242\":1}}],[\"查看支持的存储引擎\",{\"1\":{\"232\":1}}],[\"查看指定的脚本是否已经被保存在缓存当中\",{\"1\":{\"384\":1}}],[\"查看指定变量的值\",{\"1\":{\"242\":1}}],[\"查看指定query\",{\"1\":{\"228\":2}}],[\"查看指定表的索引\",{\"1\":{\"127\":1}}],[\"查看每一条执行过的sql语句的耗时情况\",{\"1\":{\"228\":1}}],[\"查看是否支持profile\",{\"1\":{\"228\":1}}],[\"查看慢日志文件中记录的信息\",{\"1\":{\"227\":1}}],[\"查看视图数据\",{\"1\":{\"163\":1}}],[\"查看创建视图语句\",{\"1\":{\"163\":1}}],[\"查看\",{\"1\":{\"155\":1,\"240\":1,\"256\":1}}],[\"查看意向锁及行锁的加锁情况\",{\"1\":{\"145\":1}}],[\"查看元数据锁\",{\"1\":{\"144\":1}}],[\"查看索引\",{\"1\":{\"127\":1}}],[\"查询分数\",{\"1\":{\"419\":1}}],[\"查询效率要求极高\",{\"1\":{\"418\":1}}],[\"查询效率高\",{\"1\":{\"121\":1}}],[\"查询速度快\",{\"1\":{\"380\":1}}],[\"查询速度一般\",{\"1\":{\"378\":1}}],[\"查询速度更快\",{\"1\":{\"122\":1}}],[\"查询方式\",{\"1\":{\"364\":1}}],[\"查询失败处理\",{\"1\":{\"307\":1}}],[\"查询redis数据为空\",{\"1\":{\"307\":1}}],[\"查询redis失败\",{\"1\":{\"307\":1}}],[\"查询redis\",{\"0\":{\"316\":1},\"1\":{\"307\":1}}],[\"查询redis的方法\",{\"1\":{\"307\":1}}],[\"查询缓存\",{\"1\":{\"272\":1}}],[\"查询语句\",{\"1\":{\"252\":1}}],[\"查询某个存储过程的定义\",{\"1\":{\"240\":1}}],[\"查询指定数据库的存储过程及状态信息\",{\"1\":{\"240\":1}}],[\"查询指定表的建表语句\",{\"1\":{\"177\":1}}],[\"查询数据等技术的实现方式\",{\"1\":{\"232\":1}}],[\"查询数据权限\",{\"1\":{\"196\":1}}],[\"查询类别\",{\"0\":{\"209\":1}}],[\"查询类型\",{\"0\":{\"185\":1,\"213\":1}}],[\"查询权限\",{\"1\":{\"196\":1}}],[\"查询用户\",{\"1\":{\"195\":1}}],[\"查询的序列号\",{\"1\":{\"229\":1}}],[\"查询的页码\",{\"1\":{\"192\":1}}],[\"查询的字段一般为聚合函数和分组字段\",{\"1\":{\"190\":1}}],[\"查询记录数\",{\"1\":{\"192\":2}}],[\"查询其他字段无任何意义\",{\"1\":{\"190\":1}}],[\"查询多个字段\",{\"1\":{\"186\":1}}],[\"查询表结构\",{\"1\":{\"177\":1}}],[\"查询当前数据库的所有表\",{\"1\":{\"177\":1}}],[\"查询当前数据库\",{\"1\":{\"176\":1}}],[\"查询所有数据库\",{\"1\":{\"176\":1}}],[\"查询\",{\"1\":{\"163\":1,\"176\":1,\"177\":1,\"226\":1,\"334\":1,\"396\":1,\"438\":2}}],[\"查询时只能进行遍历\",{\"1\":{\"444\":1}}],[\"查询时\",{\"1\":{\"132\":1,\"134\":1}}],[\"查询使用了索引\",{\"1\":{\"131\":1}}],[\"查询条件的顺序为\",{\"1\":{\"129\":3}}],[\"查询了两次b+树\",{\"1\":{\"126\":1}}],[\"查询后的值为该字段对应的id值\",{\"1\":{\"126\":1}}],[\"查询性能大大降低\",{\"1\":{\"116\":1}}],[\"查询右表的所有数据\",{\"1\":{\"95\":1}}],[\"查询左表的所有数据\",{\"1\":{\"95\":1}}],[\"左上角\",{\"1\":{\"514\":1}}],[\"左外连接\",{\"1\":{\"95\":2}}],[\"左外连接和右外连接\",{\"1\":{\"95\":1}}],[\"左填充\",{\"1\":{\"53\":1}}],[\"外连接有两种情况\",{\"1\":{\"95\":1}}],[\"外连接\",{\"0\":{\"95\":1}}],[\"外键\",{\"1\":{\"237\":1}}],[\"外键字段\",{\"1\":{\"50\":1}}],[\"外键字段名\",{\"1\":{\"49\":2}}],[\"外键名称\",{\"1\":{\"49\":3,\"50\":1}}],[\"外键约束\",{\"0\":{\"48\":1},\"1\":{\"47\":1}}],[\"隐式内连接\",{\"1\":{\"94\":1}}],[\"隐藏主键\",{\"1\":{\"82\":1}}],[\"隐藏字段\",{\"1\":{\"82\":1}}],[\"笛卡尔积是指在数学中\",{\"1\":{\"93\":1}}],[\"笛卡尔积\",{\"1\":{\"93\":2}}],[\"然而缓存空间是有限的\",{\"1\":{\"273\":1}}],[\"然而在多表查询之前\",{\"1\":{\"93\":1}}],[\"然后根据事件类型的不同\",{\"1\":{\"460\":1}}],[\"然后执行删除\",{\"1\":{\"455\":1}}],[\"然后利用\",{\"1\":{\"436\":1}}],[\"然后拷贝到用户缓冲区\",{\"1\":{\"401\":1}}],[\"然后写入设备\",{\"1\":{\"401\":1}}],[\"然后是疑似宕机\",{\"1\":{\"345\":1}}],[\"然后对\",{\"1\":{\"343\":1}}],[\"然后通过命令来管理集群\",{\"1\":{\"341\":1}}],[\"然后我们在s1目录创建一个sentinel\",{\"1\":{\"331\":1}}],[\"然后让所有节点都执行\",{\"1\":{\"328\":1}}],[\"然后让配置生效\",{\"1\":{\"305\":1}}],[\"然后判断\",{\"1\":{\"326\":1}}],[\"然后判定逻辑是否满足\",{\"1\":{\"250\":1}}],[\"然后每隔\",{\"1\":{\"320\":1}}],[\"然后访问页面\",{\"1\":{\"306\":1}}],[\"然后就可以像下面这样安装软件包\",{\"1\":{\"305\":1}}],[\"然后再重复上面的命令\",{\"1\":{\"305\":1}}],[\"然后再以一定的频率刷新到磁盘\",{\"1\":{\"61\":1}}],[\"然后连接\",{\"1\":{\"297\":1}}],[\"然后将键值对放到新的哈希表位置上\",{\"1\":{\"437\":1}}],[\"然后将s1\",{\"1\":{\"331\":1}}],[\"然后将redis\",{\"1\":{\"295\":1}}],[\"然后将新节点插入到当前链表的表头\",{\"1\":{\"37\":1}}],[\"然后才进行条件判断\",{\"1\":{\"289\":1}}],[\"然后进行删除操作\",{\"1\":{\"273\":1}}],[\"然后累积计数\",{\"1\":{\"219\":1}}],[\"然后在排序缓冲区sort\",{\"1\":{\"209\":1}}],[\"然后重新创建\",{\"1\":{\"177\":1}}],[\"然后存储在hash表中\",{\"1\":{\"121\":1}}],[\"然后这个隐藏列就相当于一个指针\",{\"1\":{\"58\":1}}],[\"关键看数据在内核空间与用户空间的拷贝过程\",{\"1\":{\"413\":1}}],[\"关键字建议使用大写\",{\"1\":{\"173\":1}}],[\"关键字\",{\"1\":{\"33\":1,\"47\":1,\"124\":1}}],[\"关闭服务器\",{\"1\":{\"361\":1}}],[\"关闭redis连接的工具方法\",{\"1\":{\"307\":1}}],[\"关闭aof\",{\"1\":{\"295\":1}}],[\"关闭自动提交\",{\"1\":{\"256\":1}}],[\"关闭游标\",{\"1\":{\"252\":1}}],[\"关系型数据库\",{\"0\":{\"108\":1}}],[\"关联\",{\"1\":{\"364\":1,\"462\":1}}],[\"关联数组\",{\"1\":{\"288\":1}}],[\"关联了两方多的主键\",{\"1\":{\"92\":1}}],[\"关联另外一方的主键\",{\"1\":{\"90\":1}}],[\"例如ping命令\",{\"1\":{\"462\":2}}],[\"例如异步删除命令\",{\"1\":{\"458\":1}}],[\"例如一个内容为\",{\"1\":{\"427\":1}}],[\"例如一个user对象\",{\"1\":{\"376\":1}}],[\"例如存储\",{\"1\":{\"421\":1}}],[\"例如返回\",{\"1\":{\"421\":1}}],[\"例如常规文件\",{\"1\":{\"404\":1}}],[\"例如我们的项目名称叫\",{\"1\":{\"376\":1}}],[\"例如查看set指令的帮助文档\",{\"1\":{\"361\":1}}],[\"例如slave1\",{\"1\":{\"327\":1}}],[\"例如\",{\"1\":{\"91\":1,\"93\":1,\"164\":1,\"220\":1,\"240\":1,\"269\":1,\"274\":2,\"280\":2,\"343\":2,\"372\":1,\"376\":1,\"378\":1,\"421\":3,\"426\":1,\"462\":1,\"573\":2}}],[\"例如将最常用的字段抽取出来\",{\"1\":{\"90\":1}}],[\"例子\",{\"0\":{\"29\":1}}],[\"例子3\",{\"0\":{\"24\":1}}],[\"例子2\",{\"0\":{\"23\":1,\"27\":1}}],[\"例子1\",{\"0\":{\"22\":1,\"26\":1}}],[\"锁机制\",{\"1\":{\"236\":1}}],[\"锁定索引记录间隙\",{\"1\":{\"146\":1}}],[\"锁定单个行记录的锁\",{\"1\":{\"146\":1}}],[\"锁定粒度最小\",{\"1\":{\"146\":1}}],[\"锁定力度大\",{\"1\":{\"142\":1}}],[\"锁类型\",{\"1\":{\"144\":1}}],[\"锁对数据库而言显得尤其重要\",{\"1\":{\"136\":1}}],[\"锁冲突也是影响数据库并发访问性能的一个重要因素\",{\"1\":{\"136\":1}}],[\"锁是计算机协调多个进程或线程并发访问某一资源的机制\",{\"1\":{\"136\":1}}],[\"锁\",{\"0\":{\"135\":1},\"1\":{\"86\":1,\"170\":1}}],[\"仅保存需要进行递推的两个值\",{\"1\":{\"529\":1}}],[\"仅能从上边网格向下移动\",{\"1\":{\"511\":1}}],[\"仅能从左边网格向右移动\",{\"1\":{\"511\":1}}],[\"仅维护两个需要递推的数值\",{\"1\":{\"506\":1}}],[\"仅有j\",{\"1\":{\"481\":1}}],[\"仅有i++可以实现\",{\"1\":{\"481\":1}}],[\"仅仅是为了确保合并结果可以顺利存放到\",{\"1\":{\"541\":1}}],[\"仅仅变更一个指针的话\",{\"1\":{\"481\":1}}],[\"仅仅定义\",{\"1\":{\"32\":1}}],[\"仅在非叶子结点中存储索引\",{\"1\":{\"119\":1}}],[\"仅在事务中第一次执行快照读时生成readview\",{\"1\":{\"86\":1}}],[\"预分配事务id\",{\"1\":{\"85\":1}}],[\"未设置该参数默认为全局函数\",{\"1\":{\"291\":1}}],[\"未命中\",{\"1\":{\"272\":1}}],[\"未提交\",{\"1\":{\"85\":1}}],[\"未被使用\",{\"1\":{\"61\":1}}],[\"读len个字节\",{\"1\":{\"422\":1}}],[\"读\",{\"1\":{\"406\":1,\"407\":1}}],[\"读数据是\",{\"1\":{\"401\":1}}],[\"读已提交\",{\"1\":{\"259\":1}}],[\"读未提交\",{\"1\":{\"259\":1}}],[\"读写效率\",{\"1\":{\"461\":1}}],[\"读写效率稍差\",{\"1\":{\"234\":1}}],[\"读写分离\",{\"0\":{\"168\":1},\"1\":{\"170\":1}}],[\"读锁不会阻塞其他客户端的读\",{\"1\":{\"143\":1}}],[\"读视图是快照读sql执行时mvcc提取数据的依据\",{\"1\":{\"85\":1}}],[\"读视图\",{\"0\":{\"85\":1}}],[\"读取请求数据到\",{\"1\":{\"462\":1}}],[\"读取首字节\",{\"1\":{\"422\":1}}],[\"读取\",{\"1\":{\"408\":1}}],[\"读取了\",{\"1\":{\"408\":1}}],[\"读取并处理数据\",{\"1\":{\"404\":1}}],[\"读取数量\",{\"1\":{\"394\":1}}],[\"读取数据以后\",{\"1\":{\"356\":1}}],[\"读取数据\",{\"1\":{\"342\":1}}],[\"读取消费组中的消息\",{\"1\":{\"394\":1}}],[\"读取消费者组中的消息\",{\"1\":{\"385\":1}}],[\"读取redis数据的api\",{\"1\":{\"307\":1}}],[\"读取本地内存\",{\"1\":{\"280\":1}}],[\"读取满足条件的数据行\",{\"1\":{\"209\":1}}],[\"读取时还要保证其他并发事务不能修改当前记录\",{\"1\":{\"80\":1}}],[\"读取的是记录的最新版本\",{\"1\":{\"80\":1}}],[\"读取下一个值\",{\"1\":{\"37\":1}}],[\"链表过长\",{\"1\":{\"437\":1}}],[\"链表的尾部是最早的旧数据\",{\"1\":{\"84\":1}}],[\"链表的头部是最新的旧数据\",{\"1\":{\"84\":1}}],[\"链地址法\",{\"1\":{\"435\":1}}],[\"链接\",{\"1\":{\"171\":1,\"546\":1}}],[\"链式存储\",{\"1\":{\"33\":2}}],[\"作为值写入\",{\"1\":{\"352\":1}}],[\"作为新的\",{\"1\":{\"328\":1}}],[\"作为事务在未提交情况下回滚的依据\",{\"1\":{\"84\":1}}],[\"作用是维护消费者的未确认的\",{\"1\":{\"385\":1}}],[\"作用是跳过当前循环剩下的语句\",{\"1\":{\"251\":1}}],[\"作用\",{\"1\":{\"269\":1}}],[\"作用包含两个\",{\"1\":{\"76\":1}}],[\"含义\",{\"1\":{\"82\":1,\"85\":1,\"124\":2,\"246\":1}}],[\"记录的是\",{\"1\":{\"503\":1}}],[\"记录的是事务提交时数据页的物理修改\",{\"1\":{\"75\":1}}],[\"记录最大值\",{\"1\":{\"488\":1}}],[\"记录为\",{\"1\":{\"456\":1}}],[\"记录就绪的\",{\"1\":{\"407\":1}}],[\"记录要监听的fd\",{\"1\":{\"407\":1}}],[\"记录要监听的fd集合\",{\"1\":{\"405\":1}}],[\"记录\",{\"1\":{\"386\":1}}],[\"记录了当前已经被客户端读取的消息\",{\"1\":{\"385\":1}}],[\"记录命令\",{\"1\":{\"321\":1}}],[\"记录每一次执行的命令\",{\"1\":{\"321\":1}}],[\"记录错误信息\",{\"1\":{\"307\":1}}],[\"记录慢查询日志\",{\"1\":{\"227\":1}}],[\"记录并维护系统当前活跃的事务\",{\"1\":{\"85\":1}}],[\"记录插入这条记录或最后一次修改该记录的事务id\",{\"1\":{\"82\":1}}],[\"记录中的隐藏字段分别为\",{\"1\":{\"82\":1}}],[\"开头\",{\"1\":{\"442\":2}}],[\"开机启动\",{\"0\":{\"370\":1}}],[\"开发人员和系统工程师可以使用\",{\"1\":{\"304\":1}}],[\"开发的提供了近乎最佳命中率的高性能的缓存库\",{\"1\":{\"281\":1}}],[\"开发的\",{\"1\":{\"280\":1}}],[\"开始循环遍历\",{\"1\":{\"526\":1,\"529\":1}}],[\"开始监听事件循环\",{\"1\":{\"462\":1}}],[\"开始递增的无符号整数\",{\"1\":{\"404\":1}}],[\"开始事务\",{\"1\":{\"399\":2}}],[\"开始值\",{\"1\":{\"390\":1,\"391\":1}}],[\"开始从新的\",{\"1\":{\"327\":1}}],[\"开始时会\",{\"1\":{\"319\":1}}],[\"开始和结束的下标\",{\"1\":{\"291\":1}}],[\"开始\",{\"1\":{\"288\":1,\"496\":1}}],[\"开始的\",{\"1\":{\"36\":6,\"514\":1}}],[\"开启redis开机自启动\",{\"1\":{\"370\":1}}],[\"开启rdb\",{\"1\":{\"295\":1}}],[\"开启集群功能\",{\"1\":{\"339\":1}}],[\"开启子进程执行\",{\"1\":{\"319\":1}}],[\"开启共享词典\",{\"1\":{\"307\":1}}],[\"开启主从关系\",{\"0\":{\"297\":1}}],[\"开启事务\",{\"1\":{\"256\":1}}],[\"开启事务后第一个select语句才是快照读的地方\",{\"1\":{\"81\":1}}],[\"开启profile\",{\"1\":{\"228\":1}}],[\"开启mysql中的慢查询\",{\"1\":{\"227\":1}}],[\"开启的话需要在mysql的配置文件\",{\"1\":{\"227\":1}}],[\"开启从本地加载文件导入数据库的开关\",{\"1\":{\"202\":1}}],[\"开放寻址法\",{\"1\":{\"121\":1}}],[\"都保存在之前学习过的\",{\"1\":{\"454\":1}}],[\"都检查一下dict\",{\"1\":{\"438\":1}}],[\"都需求根据键获取值\",{\"1\":{\"417\":1}}],[\"都需要把所有要监听的\",{\"1\":{\"410\":1}}],[\"都拷贝到内核空间\",{\"1\":{\"410\":1}}],[\"都必须等待\",{\"1\":{\"404\":1}}],[\"都有一个尺寸\",{\"1\":{\"491\":1}}],[\"都有一个胃口值\",{\"1\":{\"491\":1}}],[\"都有唯一的名称\",{\"1\":{\"385\":1}}],[\"都有位移的\",{\"1\":{\"300\":1}}],[\"都以\",{\"1\":{\"343\":1}}],[\"都是计算机网络\",{\"1\":{\"565\":1}}],[\"都是已知条件\",{\"1\":{\"498\":1,\"521\":1}}],[\"都是需要同时变更两个指针\",{\"1\":{\"481\":1}}],[\"都是以处理二进制的方式来处理\",{\"1\":{\"425\":1}}],[\"都是键值存储\",{\"1\":{\"417\":1}}],[\"都是有效部分\",{\"1\":{\"343\":1}}],[\"都是一种当前读\",{\"1\":{\"80\":1}}],[\"都可以有多个\",{\"1\":{\"337\":1}}],[\"都认为实例主观下线\",{\"1\":{\"328\":1}}],[\"都认为该实例主观下线\",{\"1\":{\"325\":1}}],[\"都互斥\",{\"1\":{\"145\":1}}],[\"都会保存数据\",{\"1\":{\"122\":1}}],[\"都会把旧的版本写入到undo日志中\",{\"1\":{\"58\":1}}],[\"都会把对应的事务id赋值给trx\",{\"1\":{\"58\":1}}],[\"都生成一个快照读\",{\"1\":{\"81\":1}}],[\"使合并后的数组同样按\",{\"1\":{\"541\":1}}],[\"使其不断自增\",{\"1\":{\"481\":1}}],[\"使用dp数组记录每一步所需要花费的最小体力\",{\"1\":{\"536\":1}}],[\"使用dp数组进行记录\",{\"0\":{\"502\":1,\"505\":1,\"525\":1,\"528\":1},\"1\":{\"503\":1}}],[\"使用最小花费爬楼梯\",{\"0\":{\"531\":1},\"1\":{\"533\":1}}],[\"使用哈希表的sizemask属性和第一步得到的哈希值\",{\"1\":{\"435\":1}}],[\"使用字典设置的哈希函数\",{\"1\":{\"435\":1}}],[\"使用率暴增\",{\"1\":{\"403\":1}}],[\"使用自动注入获取对象\",{\"1\":{\"360\":1}}],[\"使用说明\",{\"1\":{\"359\":1}}],[\"使用对应的\",{\"1\":{\"356\":1}}],[\"使用到了\",{\"1\":{\"353\":1}}],[\"使用可视化工具查看\",{\"1\":{\"352\":1}}],[\"使用可视化工具查看一下\",{\"1\":{\"352\":1}}],[\"使用分片集群可以解决上述问题\",{\"1\":{\"337\":1}}],[\"使用场景\",{\"1\":{\"321\":1,\"364\":1}}],[\"使用方式如下\",{\"1\":{\"372\":1}}],[\"使用方式二\",{\"1\":{\"297\":1}}],[\"使用方便\",{\"1\":{\"108\":1}}],[\"使用redis\",{\"1\":{\"297\":1,\"352\":1}}],[\"使用tcc等分布式事务方案\",{\"1\":{\"275\":1}}],[\"使用内存淘汰机制\",{\"1\":{\"274\":1}}],[\"使用就可以\",{\"1\":{\"243\":1}}],[\"使用中间表\",{\"1\":{\"213\":1}}],[\"使用索引\",{\"1\":{\"213\":1}}],[\"使用索引的效率越高\",{\"1\":{\"134\":1}}],[\"使用insert语句插入的性能不高\",{\"1\":{\"202\":1}}],[\"使用逗号分隔\",{\"1\":{\"196\":1}}],[\"使用\",{\"1\":{\"173\":1,\"176\":1,\"195\":1,\"243\":1,\"283\":1,\"344\":1,\"356\":1,\"385\":1,\"386\":1,\"387\":1,\"388\":1,\"389\":1,\"390\":1,\"391\":1,\"392\":1,\"393\":1,\"394\":1}}],[\"使用别名old和new来引用触发器中发生变化的记录内容\",{\"1\":{\"153\":1}}],[\"使用意向锁来减少表锁的检查\",{\"1\":{\"145\":1}}],[\"使用记录值的id再在聚集索引中查询\",{\"1\":{\"125\":1}}],[\"使用二叉树做索引结构\",{\"1\":{\"116\":1}}],[\"使用select\",{\"1\":{\"243\":1}}],[\"使用set\",{\"1\":{\"243\":1}}],[\"使用sql语言操作\",{\"1\":{\"108\":1}}],[\"使用some的地方均可以使用any\",{\"1\":{\"100\":1}}],[\"使用表存储数据\",{\"1\":{\"108\":1}}],[\"使用了大量的aio来处理io请求\",{\"1\":{\"73\":1}}],[\"使得\",{\"1\":{\"344\":1}}],[\"使得表锁不用检查每行数据是否加锁\",{\"1\":{\"145\":1}}],[\"使得提高查询的效率\",{\"1\":{\"90\":1}}],[\"使得读写操作没有冲突\",{\"1\":{\"79\":1}}],[\"内的不同整数组成\",{\"1\":{\"514\":1}}],[\"内置不同的\",{\"1\":{\"436\":1}}],[\"内容可能包括空字符串\",{\"1\":{\"425\":1}}],[\"内容如下\",{\"1\":{\"306\":1,\"310\":1,\"339\":1}}],[\"内核中会处理大量请求\",{\"1\":{\"412\":1}}],[\"内核等待数据就绪并拷贝到用户空间后才会递交信号\",{\"1\":{\"412\":1}}],[\"内核遍历\",{\"1\":{\"406\":1}}],[\"内核会将就绪的\",{\"1\":{\"410\":1}}],[\"内核会将数据拷贝到用户线程\",{\"1\":{\"402\":1}}],[\"内核会去查看数据是否准备就绪\",{\"1\":{\"402\":1}}],[\"内核空间中遍历拷贝后的\",{\"1\":{\"405\":1}}],[\"内核空间可以执行特权命令\",{\"1\":{\"401\":1}}],[\"内核空间\",{\"1\":{\"401\":1}}],[\"内核与硬件交互\",{\"1\":{\"401\":1}}],[\"内部调用\",{\"1\":{\"462\":1}}],[\"内部会调用\",{\"1\":{\"462\":2}}],[\"内部有触发\",{\"1\":{\"319\":1}}],[\"内部的缓存使用的就是\",{\"1\":{\"280\":1}}],[\"内部包含\",{\"1\":{\"76\":1}}],[\"内存存储数据库\",{\"1\":{\"454\":1}}],[\"内存占用较低\",{\"1\":{\"444\":1}}],[\"内存占用小\",{\"1\":{\"270\":1}}],[\"内存不够时还会进行扩容\",{\"1\":{\"432\":1}}],[\"内存预分配\",{\"0\":{\"427\":1}}],[\"内存的寻址空间划分为两部分\",{\"1\":{\"401\":1}}],[\"内存\",{\"1\":{\"364\":1,\"398\":1}}],[\"内存淘汰就是当\",{\"1\":{\"456\":1}}],[\"内存淘汰\",{\"1\":{\"274\":1}}],[\"内存是硬盘的缓存\",{\"1\":{\"269\":1}}],[\"内存策略\",{\"0\":{\"454\":1},\"1\":{\"265\":1}}],[\"内存使用达到设置的阈值时\",{\"1\":{\"456\":1}}],[\"内存使用\",{\"1\":{\"236\":1}}],[\"内存储的是segment段\",{\"1\":{\"204\":1}}],[\"内存结构\",{\"0\":{\"60\":1},\"1\":{\"60\":1}}],[\"内连接分为两种类型\",{\"1\":{\"94\":1}}],[\"内连接\",{\"0\":{\"94\":1},\"1\":{\"94\":1}}],[\"存活时间\",{\"1\":{\"454\":1}}],[\"存放每一个\",{\"1\":{\"454\":1}}],[\"存放所有\",{\"1\":{\"454\":1}}],[\"存放在内存中\",{\"1\":{\"236\":1}}],[\"存放在前面介绍的rollback\",{\"1\":{\"76\":1}}],[\"存入\",{\"1\":{\"354\":1}}],[\"存数据\",{\"1\":{\"282\":1}}],[\"存在一个能为用户自动管理资源的网络操作系统\",{\"1\":{\"567\":1}}],[\"存在下面的问题\",{\"1\":{\"279\":1}}],[\"存在误判可能\",{\"1\":{\"270\":1}}],[\"存在以下问题\",{\"1\":{\"140\":1}}],[\"存储上限为\",{\"1\":{\"415\":1}}],[\"存储方式\",{\"1\":{\"364\":1}}],[\"存储的\",{\"1\":{\"352\":1}}],[\"存储一个数据\",{\"1\":{\"342\":1}}],[\"存储能力问题\",{\"1\":{\"318\":1}}],[\"存储容量有限\",{\"1\":{\"280\":1}}],[\"存储容量更大\",{\"1\":{\"280\":1}}],[\"存储函数是通过函数调用\",{\"1\":{\"254\":1}}],[\"存储函数的范围\",{\"1\":{\"254\":1}}],[\"存储函数的参数只能是in类型的\",{\"1\":{\"254\":1}}],[\"存储函数就是必须有返回值的存储过程\",{\"1\":{\"254\":1}}],[\"存储函数就是有返回值的存储过程\",{\"1\":{\"254\":1}}],[\"存储函数名称\",{\"1\":{\"254\":1}}],[\"存储函数\",{\"0\":{\"254\":1}}],[\"存储限制\",{\"1\":{\"236\":1}}],[\"存储索引\",{\"1\":{\"235\":1}}],[\"存储表结构信息\",{\"1\":{\"235\":1,\"236\":1}}],[\"存储该表的表架构\",{\"1\":{\"234\":1}}],[\"存储层位于mysql结构体系的最底层\",{\"1\":{\"231\":1}}],[\"存储层\",{\"1\":{\"231\":1}}],[\"存储过程的范围\",{\"1\":{\"254\":1}}],[\"存储过程名称\",{\"1\":{\"240\":3,\"246\":1}}],[\"存储过程思想上很简单\",{\"1\":{\"239\":1}}],[\"存储过程是事先经过编译并且存储在数据库中的一段sql语句的集合\",{\"1\":{\"239\":1}}],[\"存储过程\",{\"0\":{\"238\":1},\"1\":{\"170\":1}}],[\"存储引擎选择\",{\"0\":{\"237\":1}}],[\"存储引擎特点\",{\"0\":{\"233\":1}}],[\"存储引擎列表\",{\"1\":{\"232\":1}}],[\"存储引擎是基于表的\",{\"1\":{\"232\":1}}],[\"存储引擎就是存储数据\",{\"1\":{\"232\":1}}],[\"存储引擎简介\",{\"0\":{\"232\":1}}],[\"存储引擎\",{\"0\":{\"230\":1},\"1\":{\"170\":1}}],[\"存储引擎支持\",{\"0\":{\"123\":1},\"1\":{\"121\":1}}],[\"存储数据\",{\"1\":{\"235\":1,\"342\":1}}],[\"存储数据文件的路径地址\",{\"1\":{\"202\":1}}],[\"存储数据库\",{\"1\":{\"109\":1}}],[\"存储数据域\",{\"1\":{\"37\":1}}],[\"存储用户创建的临时表等数据\",{\"1\":{\"70\":1}}],[\"存储\",{\"1\":{\"33\":1}}],[\"存储结构\",{\"1\":{\"33\":2}}],[\"亦然\",{\"1\":{\"76\":1}}],[\"多线程网络模型\",{\"0\":{\"461\":1}}],[\"多线程会导致过多的上下文切换\",{\"1\":{\"458\":1}}],[\"多行字符串\",{\"1\":{\"421\":1,\"422\":1}}],[\"多行注释\",{\"1\":{\"173\":1}}],[\"多路复用模块依然是由主线程执行\",{\"1\":{\"461\":1}}],[\"多路复用来提高网络性能\",{\"1\":{\"459\":1}}],[\"多路复用的实现方案\",{\"1\":{\"405\":1}}],[\"多路复用的技术有三种方式\",{\"1\":{\"404\":1}}],[\"多路复用\",{\"1\":{\"401\":1,\"460\":1}}],[\"多次写操作\",{\"1\":{\"320\":1}}],[\"多个单词之间用\",{\"1\":{\"376\":1}}],[\"多个参数以逗号隔开\",{\"1\":{\"291\":1}}],[\"多个权限之间\",{\"1\":{\"196\":1}}],[\"多级缓存就是充分利用请求处理的每个环节\",{\"1\":{\"279\":1}}],[\"多级缓存方案\",{\"1\":{\"279\":1}}],[\"多级缓存\",{\"0\":{\"303\":1},\"1\":{\"264\":1}}],[\"多字段排序\",{\"1\":{\"211\":1}}],[\"多字段排序时\",{\"1\":{\"211\":1}}],[\"多选之\",{\"1\":{\"187\":1}}],[\"多选一\",{\"1\":{\"100\":1}}],[\"多张表的列数必须保持一致\",{\"1\":{\"97\":1}}],[\"多对多\",{\"0\":{\"92\":1}}],[\"多表关系\",{\"0\":{\"89\":1}}],[\"多表查询是指从多张数据表中查询数据\",{\"1\":{\"93\":1}}],[\"多表查询\",{\"0\":{\"88\":1,\"93\":1},\"1\":{\"170\":1}}],[\"多版本并发控制\",{\"1\":{\"76\":1,\"79\":1}}],[\"多层循环\",{\"1\":{\"20\":1}}],[\"提倡运用非关系型的数据存储\",{\"1\":{\"363\":1}}],[\"提升为\",{\"1\":{\"324\":1}}],[\"提升服务性能\",{\"1\":{\"279\":1}}],[\"提交自己的\",{\"1\":{\"302\":1}}],[\"提交事务\",{\"1\":{\"256\":1}}],[\"提取码\",{\"1\":{\"171\":1,\"546\":1}}],[\"提高可靠性\",{\"0\":{\"576\":1}}],[\"提高读写效率\",{\"1\":{\"269\":1}}],[\"提高并发访问性能\",{\"1\":{\"234\":1}}],[\"提高查询效率\",{\"1\":{\"134\":1}}],[\"提高区间访问的性能\",{\"1\":{\"120\":1}}],[\"提高数据检索的效率\",{\"1\":{\"114\":1}}],[\"提供了统一的高性能事件库\",{\"1\":{\"459\":1}}],[\"提供了一个配置项\",{\"1\":{\"448\":1}}],[\"提供了三个函数\",{\"1\":{\"407\":1}}],[\"提供了三种缓存驱逐策略\",{\"1\":{\"283\":1}}],[\"提供了经纬度设置\",{\"1\":{\"396\":1}}],[\"提供了消息的持久化和主备复制功能\",{\"1\":{\"385\":1}}],[\"提供了\",{\"1\":{\"358\":1}}],[\"提供了对不同\",{\"1\":{\"358\":1}}],[\"提供了很多操作集群的命令\",{\"1\":{\"344\":1}}],[\"提供了哨兵\",{\"1\":{\"324\":1}}],[\"提供了各种\",{\"1\":{\"311\":1}}],[\"提供了适配器以供简单的迁移策略\",{\"1\":{\"281\":1}}],[\"提供了灵活的构造器去创建一个拥有下列特性的缓存\",{\"1\":{\"281\":1}}],[\"提供了近乎最佳命中率的高性能的本地缓存库\",{\"1\":{\"280\":1}}],[\"提供良好的事务管理\",{\"1\":{\"234\":1}}],[\"提供专业技术支持\",{\"1\":{\"106\":1}}],[\"提供回滚\",{\"1\":{\"76\":1}}],[\"提示\",{\"1\":{\"2\":1,\"89\":1,\"98\":1,\"105\":1,\"177\":2,\"191\":1,\"196\":1,\"201\":1,\"223\":1,\"243\":1,\"250\":1,\"251\":1,\"257\":1,\"356\":1,\"477\":1,\"496\":1,\"509\":1,\"514\":1,\"519\":1,\"532\":1,\"541\":1}}],[\"要在一次\",{\"1\":{\"438\":1}}],[\"要在同一台虚拟机开启3个实例\",{\"1\":{\"295\":1,\"331\":1}}],[\"要插入的位置\",{\"1\":{\"432\":1}}],[\"要插入数据的数据表名称\",{\"1\":{\"202\":1}}],[\"要执行的操作\",{\"1\":{\"407\":1}}],[\"要监听的事件类型\",{\"1\":{\"406\":1,\"407\":1}}],[\"要监听的\",{\"1\":{\"406\":1,\"407\":1}}],[\"要监听异常事件的fd集合\",{\"1\":{\"405\":1}}],[\"要监听写事件的fd集合\",{\"1\":{\"405\":1}}],[\"要监听读事件的fd集合\",{\"1\":{\"405\":1}}],[\"要监视的fd\",{\"1\":{\"405\":1}}],[\"要从设备读取数据到内核缓冲区\",{\"1\":{\"401\":1}}],[\"要把用户缓冲数据拷贝到内核缓冲区\",{\"1\":{\"401\":1}}],[\"要实现开机启动\",{\"1\":{\"370\":1}}],[\"要进行其他指令操作时\",{\"1\":{\"368\":1}}],[\"要进一步提高\",{\"1\":{\"293\":1}}],[\"要求f\",{\"1\":{\"498\":3,\"521\":3}}],[\"要求只能存储\",{\"1\":{\"355\":1}}],[\"要求非空且唯一\",{\"1\":{\"47\":1}}],[\"要配置主从可以使用replicaof\",{\"1\":{\"297\":1}}],[\"要注意的是lua中\",{\"1\":{\"290\":1}}],[\"要想不失效\",{\"1\":{\"242\":1}}],[\"要么同时失败\",{\"1\":{\"255\":1}}],[\"要么通过sql的执行时间来判断sql是否需要优化\",{\"1\":{\"229\":1}}],[\"要么全部不执行\",{\"1\":{\"399\":1}}],[\"要么全部失败\",{\"1\":{\"74\":1,\"257\":1}}],[\"要么全部成功\",{\"1\":{\"74\":1,\"257\":1}}],[\"要使视图可以更新\",{\"1\":{\"166\":1}}],[\"要控制索引的数量\",{\"1\":{\"134\":1}}],[\"要遵守最左前缀法则\",{\"1\":{\"129\":1}}],[\"要保存大量数据\",{\"1\":{\"122\":1}}],[\"就返回null\",{\"1\":{\"468\":1}}],[\"就返回\",{\"1\":{\"462\":1}}],[\"就很容易理解\",{\"1\":{\"441\":1}}],[\"就要通过\",{\"1\":{\"437\":1}}],[\"就会去第二个哈希表上进行查找\",{\"1\":{\"438\":1}}],[\"就会使用整数集合作为集合键的底层实现\",{\"1\":{\"430\":1}}],[\"就会出现页合并\",{\"1\":{\"205\":1}}],[\"就能知道就绪的\",{\"1\":{\"410\":1}}],[\"就绪时\",{\"1\":{\"411\":1}}],[\"就绪\",{\"1\":{\"408\":1,\"459\":1}}],[\"就绪的同时\",{\"1\":{\"404\":1}}],[\"就把对应的fd加入到rdlist这个就绪列表中\",{\"1\":{\"407\":1}}],[\"就可以得到通知\",{\"1\":{\"408\":1}}],[\"就可以计算接近\",{\"1\":{\"398\":1}}],[\"就可以从undo\",{\"1\":{\"76\":1}}],[\"就需要搭建主从集群\",{\"1\":{\"293\":1}}],[\"就将其全部归纳到字段操作里\",{\"1\":{\"177\":1}}],[\"就形成了带有顺序指针的b+tree\",{\"1\":{\"120\":1}}],[\"就是数组结合单向链表的实现\",{\"1\":{\"437\":1}}],[\"就是数据库sql语言层面的代码封装与重用\",{\"1\":{\"239\":1}}],[\"就是在等待数据和拷贝数据到用户空间两个阶段过程中都必须阻塞等待\",{\"1\":{\"402\":1}}],[\"就是在sql语句中加入一些人为的提示来达到优化的目的\",{\"1\":{\"130\":1}}],[\"就是元素的2维坐标\",{\"1\":{\"396\":1}}],[\"就是如上界面\",{\"1\":{\"368\":1}}],[\"就是写数据到\",{\"1\":{\"310\":1}}],[\"就是一个被高并发访问并且缓存重建业务较复杂的\",{\"1\":{\"272\":1}}],[\"就是把多次查询的结果合并起来\",{\"1\":{\"97\":1}}],[\"就是快照读\",{\"1\":{\"81\":1}}],[\"就看你是从那个视角去看待这段关系\",{\"1\":{\"91\":1}}],[\"就用它来回收\",{\"1\":{\"73\":1}}],[\"就好像缓存穿透一般\",{\"1\":{\"2\":1}}],[\"职责\",{\"1\":{\"73\":1}}],[\"线程就会被阻塞\",{\"1\":{\"404\":1}}],[\"线程无需等待\",{\"1\":{\"272\":1}}],[\"线程需要等待\",{\"1\":{\"272\":1}}],[\"线程类型\",{\"1\":{\"73\":1}}],[\"线性ols回归\",{\"1\":{\"553\":1}}],[\"线性表长度\",{\"1\":{\"36\":1}}],[\"线性表长度加\",{\"1\":{\"36\":1}}],[\"线性表中元素的位序是从\",{\"1\":{\"36\":1}}],[\"线性表的链式存储成为单链表\",{\"1\":{\"37\":1}}],[\"线性表的顺序存储类型描述\",{\"1\":{\"36\":1}}],[\"线性表的顺序结构又称为顺序表\",{\"1\":{\"36\":1}}],[\"线性表的基本操作\",{\"1\":{\"35\":1}}],[\"线性表是具有相同数据类型的n个数据元素的有限集序列\",{\"1\":{\"35\":1}}],[\"线性表定义和操作\",{\"0\":{\"35\":1}}],[\"线性表\",{\"0\":{\"34\":1},\"1\":{\"35\":1}}],[\"线性结构\",{\"1\":{\"33\":2}}],[\"后结果为实际值\",{\"1\":{\"442\":1}}],[\"后就可以去做其他事情\",{\"1\":{\"412\":1}}],[\"后台启动\",{\"0\":{\"369\":1}}],[\"后台线程主要有四类\",{\"1\":{\"73\":1}}],[\"后台线程的作用就是将innodb缓冲池\",{\"1\":{\"73\":1}}],[\"后台线程\",{\"0\":{\"73\":1}}],[\"后读取内存数据并写入\",{\"1\":{\"319\":1}}],[\"后面的每一项数字都是前面两项数字的和\",{\"1\":{\"496\":1}}],[\"后面的4个字节用来表示encoding中存储的字符串长度\",{\"1\":{\"442\":1}}],[\"后面的字段索引失效\",{\"1\":{\"129\":1}}],[\"后面跟上数组元素个数\",{\"1\":{\"421\":1}}],[\"后面跟上数字格式的字符串\",{\"1\":{\"421\":1}}],[\"后面跟上单行字符串\",{\"1\":{\"421\":1}}],[\"后面是openresty安装目录下的nginx的目录\",{\"1\":{\"305\":1}}],[\"后\",{\"1\":{\"279\":1,\"327\":1,\"541\":1}}],[\"后续命令则记录在repl\",{\"1\":{\"302\":1}}],[\"后续的dml的写语句\",{\"1\":{\"138\":1}}],[\"后续复用该readview\",{\"1\":{\"86\":1}}],[\"后者是在磁盘中\",{\"1\":{\"72\":1,\"75\":1}}],[\"发起命令时\",{\"1\":{\"460\":1}}],[\"发起连接请求时\",{\"1\":{\"460\":1}}],[\"发出请求\",{\"1\":{\"422\":1}}],[\"发布命令\",{\"1\":{\"381\":1}}],[\"发布消息\",{\"1\":{\"381\":1}}],[\"发布者客户端向指定的频道\",{\"1\":{\"381\":1}}],[\"发布订阅\",{\"0\":{\"381\":1},\"1\":{\"262\":1,\"381\":1,\"385\":1}}],[\"发现服务都已经正常启动\",{\"1\":{\"340\":1}}],[\"发现\",{\"1\":{\"301\":1}}],[\"发现不一致\",{\"1\":{\"300\":1}}],[\"发生锁冲突的概率最低\",{\"1\":{\"146\":1}}],[\"发生锁冲突的概率最高\",{\"1\":{\"142\":1}}],[\"发生错误时\",{\"1\":{\"72\":1,\"75\":1}}],[\"发送一条命令\",{\"1\":{\"421\":1}}],[\"发送了\",{\"1\":{\"408\":1}}],[\"发送消息\",{\"1\":{\"381\":1}}],[\"发送者\",{\"1\":{\"381\":1}}],[\"发送http请求\",{\"1\":{\"307\":1}}],[\"发送\",{\"1\":{\"300\":1,\"302\":1,\"327\":1}}],[\"发送确认报文段\",{\"1\":{\"16\":1,\"17\":1}}],[\"发送报文段的同时为该tcp连接分配对应的缓存和变量\",{\"1\":{\"15\":1}}],[\"发送请求报文段\",{\"1\":{\"15\":1}}],[\"前端框架\",{\"0\":{\"471\":1}}],[\"前端系列\",{\"0\":{\"7\":1}}],[\"前的处理器\",{\"1\":{\"462\":1}}],[\"前一个节点长度小于254字节\",{\"1\":{\"443\":1}}],[\"前提是这个field不存在\",{\"1\":{\"377\":1}}],[\"前提是这个key不存在\",{\"1\":{\"376\":1}}],[\"前台启动redis后\",{\"1\":{\"368\":1}}],[\"前台启动redis\",{\"1\":{\"368\":1}}],[\"前台启动\",{\"0\":{\"368\":1}}],[\"前景回顾\",{\"1\":{\"352\":1}}],[\"前景提要\",{\"1\":{\"227\":1,\"229\":1}}],[\"前面我们了解的几种方法要么通过sql的执行频率\",{\"1\":{\"229\":1}}],[\"前或后\",{\"1\":{\"206\":1}}],[\"前缀长度\",{\"1\":{\"132\":1}}],[\"前缀索引\",{\"0\":{\"132\":1}}],[\"前者是在内存中\",{\"1\":{\"72\":1,\"75\":1}}],[\"先读长度\",{\"1\":{\"422\":1}}],[\"先判断\",{\"1\":{\"300\":1}}],[\"先判定条件\",{\"1\":{\"249\":1}}],[\"先查询\",{\"1\":{\"279\":1}}],[\"先操作数据库\",{\"1\":{\"275\":1}}],[\"先操作缓冲池中的数据\",{\"1\":{\"61\":1}}],[\"先执行一次逻辑\",{\"1\":{\"250\":1}}],[\"先开启一个新的数据页\",{\"1\":{\"205\":1}}],[\"先通过筛选条件在二级索引中查找对应的记录值\",{\"1\":{\"125\":1}}],[\"先将数据页写入双写缓冲区文件中\",{\"1\":{\"71\":1}}],[\"独立表空间\",{\"0\":{\"67\":1}}],[\"系统为了提高\",{\"1\":{\"401\":1}}],[\"系统的发行版\",{\"1\":{\"401\":1}}],[\"系统的设计选择是一个权衡的过程\",{\"1\":{\"273\":1}}],[\"系统资源占用\",{\"1\":{\"321\":1}}],[\"系统中添加\",{\"1\":{\"305\":1}}],[\"系统变量名\",{\"1\":{\"242\":3}}],[\"系统变量是mysql服务器提供\",{\"1\":{\"242\":1}}],[\"系统变量\",{\"0\":{\"242\":1}}],[\"系统表空间是更改缓冲区的存储区域\",{\"1\":{\"66\":1}}],[\"系统表空间\",{\"0\":{\"66\":1}}],[\"系列文档\",{\"1\":{\"266\":1}}],[\"系列\",{\"0\":{\"10\":1}}],[\"自治计算机\",{\"1\":{\"566\":1}}],[\"自减操作\",{\"1\":{\"376\":2}}],[\"自定义客户端\",{\"0\":{\"422\":1}}],[\"自定义redistemplate\",{\"1\":{\"356\":1}}],[\"自定义的序列化方式也加进去了对引用类型的序列化\",{\"1\":{\"354\":1}}],[\"自定义序列化方式\",{\"0\":{\"354\":1}}],[\"自定义\",{\"1\":{\"331\":1,\"422\":1}}],[\"自动提升一个\",{\"1\":{\"345\":1}}],[\"自动故障恢复\",{\"1\":{\"324\":1}}],[\"自动加载元素到缓存当中\",{\"1\":{\"281\":1}}],[\"自适应hash就是innodb存储引擎根据我们的查询条件\",{\"1\":{\"121\":1}}],[\"自适应哈希索引无需人工干预\",{\"1\":{\"64\":1}}],[\"自适应哈希索引\",{\"0\":{\"64\":1},\"1\":{\"64\":1}}],[\"自连接可以是内连接\",{\"1\":{\"96\":1}}],[\"自连接是不区分左连接和右连接的\",{\"1\":{\"96\":1}}],[\"自连接查询必须使用表别名\",{\"1\":{\"96\":1}}],[\"自连接顾名思义就是自己连接自己\",{\"1\":{\"96\":1}}],[\"自连接\",{\"0\":{\"96\":1}}],[\"自己构建了一种新的字符串结构\",{\"1\":{\"425\":1}}],[\"自己计数\",{\"1\":{\"220\":1}}],[\"自己写总结的目的是为了记录自己对知识点的掌握程度\",{\"1\":{\"2\":1}}],[\"自己对知识的学习笔记和总结\",{\"1\":{\"1\":1}}],[\"参数解析代码示例\",{\"1\":{\"311\":1}}],[\"参数示例\",{\"1\":{\"311\":1}}],[\"参数格式\",{\"1\":{\"311\":1}}],[\"参数类型\",{\"1\":{\"246\":1}}],[\"参数名\",{\"1\":{\"246\":1}}],[\"参数列表\",{\"1\":{\"240\":2,\"254\":1}}],[\"参数说明\",{\"1\":{\"202\":1,\"204\":1}}],[\"参数\",{\"0\":{\"246\":1},\"1\":{\"63\":1,\"64\":1,\"66\":1,\"67\":1,\"234\":1}}],[\"参考资料\",{\"0\":{\"171\":1,\"266\":1,\"546\":1,\"549\":1}}],[\"参考了b站的数据结构\",{\"1\":{\"20\":1}}],[\"参考与鸣谢\",{\"0\":{\"3\":1}}],[\"日期等简单的形式\",{\"1\":{\"99\":1}}],[\"日期函数\",{\"0\":{\"55\":1}}],[\"日志记录\",{\"1\":{\"153\":1}}],[\"日志不仅在回滚时需要\",{\"1\":{\"83\":1}}],[\"日志只在回滚时需要\",{\"1\":{\"83\":1}}],[\"日志\",{\"0\":{\"150\":1},\"1\":{\"79\":1,\"170\":1,\"339\":1}}],[\"日志在每次事务提交后写入\",{\"1\":{\"63\":1}}],[\"日志在每次事务提交时写入并刷新到磁盘\",{\"1\":{\"63\":1}}],[\"日志刷新到磁盘时机\",{\"1\":{\"63\":1}}],[\"日志缓冲区中的数据会定期刷新到磁盘中\",{\"1\":{\"63\":1}}],[\"日志缓冲区\",{\"0\":{\"63\":1},\"1\":{\"63\":1}}],[\"减\",{\"1\":{\"442\":1}}],[\"减轻\",{\"1\":{\"279\":1}}],[\"减少内存分配次数\",{\"1\":{\"427\":1}}],[\"减少\",{\"1\":{\"301\":2}}],[\"减少数据库的压力\",{\"1\":{\"280\":1}}],[\"减少数据在数据库和应用服务器之间的传输\",{\"1\":{\"239\":1}}],[\"减少网络交互\",{\"1\":{\"239\":1}}],[\"减少单列索引\",{\"1\":{\"134\":1}}],[\"减少select\",{\"1\":{\"131\":1}}],[\"减少阻塞\",{\"1\":{\"73\":1}}],[\"减少磁盘io\",{\"1\":{\"62\":1}}],[\"减1\",{\"1\":{\"36\":1}}],[\"有三种方法可以爬到楼顶\",{\"1\":{\"519\":1}}],[\"有两种方法可以爬到楼顶\",{\"1\":{\"519\":1}}],[\"有两个\",{\"1\":{\"454\":1}}],[\"有些指令只能针对某些特定的类型\",{\"1\":{\"464\":1}}],[\"有关\",{\"1\":{\"438\":1}}],[\"有数据可读时\",{\"1\":{\"408\":3}}],[\"有user和product两种不同类型的数据\",{\"1\":{\"376\":1}}],[\"有效期到期时该key会被⾃动删除\",{\"1\":{\"361\":1}}],[\"有效地变成一个强大的通用\",{\"1\":{\"304\":1}}],[\"有效性是所有数据库必须解决的一个问题\",{\"1\":{\"136\":1}}],[\"有效性和完整性\",{\"1\":{\"46\":1}}],[\"有临时和永久两种模式\",{\"1\":{\"297\":1}}],[\"有点相似\",{\"1\":{\"281\":1}}],[\"有点繁琐\",{\"1\":{\"149\":1}}],[\"有额外内存消耗\",{\"1\":{\"272\":1}}],[\"有\",{\"1\":{\"236\":2}}],[\"有not\",{\"1\":{\"221\":1}}],[\"有asc和desc两种\",{\"1\":{\"210\":1}}],[\"有字段存在符合的索引\",{\"1\":{\"210\":1}}],[\"有时候即便我们创建了联合索引\",{\"1\":{\"133\":1}}],[\"有时候需要索引很长的字符串\",{\"1\":{\"132\":1}}],[\"有回表查询\",{\"1\":{\"126\":1}}],[\"有序集\",{\"1\":{\"467\":1}}],[\"有序集合对象\",{\"1\":{\"469\":2}}],[\"有序集合对象zset\",{\"0\":{\"419\":1}}],[\"有序集合\",{\"0\":{\"380\":1}}],[\"有序等特征\",{\"1\":{\"430\":1}}],[\"有序\",{\"1\":{\"113\":1,\"378\":1,\"433\":1}}],[\"有任意一个满足即可\",{\"1\":{\"100\":1}}],[\"有多个事务需要对同一个数据进行操作\",{\"1\":{\"84\":1}}],[\"有可能是历史数据\",{\"1\":{\"81\":1}}],[\"有了change\",{\"1\":{\"62\":1}}],[\"脏读\",{\"1\":{\"258\":1,\"259\":1}}],[\"脏page\",{\"1\":{\"61\":1}}],[\"脏页\",{\"1\":{\"61\":1}}],[\"空event\",{\"1\":{\"407\":1}}],[\"空转\",{\"1\":{\"403\":1}}],[\"空间使用\",{\"1\":{\"236\":1}}],[\"空间占用比较大\",{\"1\":{\"234\":1}}],[\"空间索引是myisam引擎的一个特殊索引\",{\"1\":{\"115\":1}}],[\"空间复杂度是很容易判断的\",{\"1\":{\"30\":1}}],[\"空间复杂度\",{\"0\":{\"30\":1},\"1\":{\"489\":1,\"501\":1,\"504\":1,\"507\":1,\"524\":1,\"527\":1,\"530\":1,\"537\":1,\"539\":1}}],[\"空闲page\",{\"1\":{\"61\":1}}],[\"缓冲区\",{\"1\":{\"320\":2,\"462\":1}}],[\"缓冲区大小\",{\"1\":{\"63\":1}}],[\"缓冲池以page页为单位\",{\"1\":{\"61\":1}}],[\"缓冲池是主内存中的一个区域\",{\"1\":{\"61\":1}}],[\"缓冲池\",{\"0\":{\"61\":1}}],[\"缓存和\",{\"1\":{\"281\":1}}],[\"缓存和数据库整合为一个服务\",{\"1\":{\"275\":1}}],[\"缓存数据量较小\",{\"1\":{\"280\":1}}],[\"缓存数据量较大\",{\"1\":{\"280\":1}}],[\"缓存在日常开发中起着至关重要的作用\",{\"1\":{\"280\":1}}],[\"缓存失效时\",{\"1\":{\"279\":1}}],[\"缓存更新策略\",{\"0\":{\"274\":1}}],[\"缓存淘汰策略\",{\"0\":{\"276\":1},\"1\":{\"273\":1}}],[\"缓存被写满是不可避免的\",{\"1\":{\"273\":1}}],[\"缓存中的元素时将会进行通知\",{\"1\":{\"281\":1}}],[\"缓存中会存在大量的永远不会被访问的数据\",{\"1\":{\"273\":1}}],[\"缓存中不存在\",{\"1\":{\"270\":1}}],[\"缓存污染会随着数据的持续增加而逐渐显露\",{\"1\":{\"273\":1}}],[\"缓存污染问题指的是缓存中一些只会被访问一次或者几次的数据\",{\"1\":{\"273\":1}}],[\"缓存污染\",{\"0\":{\"273\":1}}],[\"缓存击穿指并发查同一条数据\",{\"1\":{\"272\":1}}],[\"缓存击穿问题也叫热点\",{\"1\":{\"272\":1}}],[\"缓存击穿\",{\"0\":{\"272\":1}}],[\"缓存雪崩是不同数据都过期了\",{\"1\":{\"272\":1}}],[\"缓存雪崩是指在同一时间段内\",{\"1\":{\"271\":1}}],[\"缓存雪崩\",{\"0\":{\"271\":1}}],[\"缓存空对象\",{\"1\":{\"270\":1}}],[\"缓存就是数据交换的缓冲区\",{\"1\":{\"269\":1}}],[\"缓存\",{\"0\":{\"269\":1},\"1\":{\"283\":1}}],[\"缓存同步\",{\"0\":{\"277\":1},\"1\":{\"264\":1}}],[\"缓存问题\",{\"0\":{\"268\":1},\"1\":{\"264\":1}}],[\"缓存层和持久层都不会命中\",{\"1\":{\"2\":1}}],[\"缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在\",{\"1\":{\"270\":1}}],[\"缓存穿透将导致不存在的数据每次请求都要到持久层去查询\",{\"1\":{\"2\":1}}],[\"缓存穿透\",{\"0\":{\"270\":1},\"1\":{\"2\":1}}],[\"bm\",{\"1\":{\"447\":1}}],[\"blocking\",{\"1\":{\"401\":1,\"454\":1}}],[\"block\",{\"1\":{\"392\":1,\"394\":1}}],[\"blpop和brpop\",{\"1\":{\"378\":1}}],[\"bgrewriteaof\",{\"1\":{\"320\":1,\"437\":2}}],[\"bgsave\",{\"1\":{\"319\":5,\"437\":1}}],[\"bgsave命令\",{\"1\":{\"319\":1}}],[\"broken\",{\"1\":{\"305\":1}}],[\"break和continue关键字的用法\",{\"1\":{\"251\":1}}],[\"break\",{\"1\":{\"202\":2,\"432\":1,\"482\":1}}],[\"backward\",{\"1\":{\"452\":1}}],[\"backup\",{\"1\":{\"319\":1}}],[\"base\",{\"1\":{\"364\":1}}],[\"baklog\",{\"1\":{\"300\":2,\"301\":2,\"302\":4}}],[\"baidu\",{\"1\":{\"171\":1,\"546\":1}}],[\"bookmarks\",{\"1\":{\"447\":1}}],[\"bookmark\",{\"1\":{\"447\":1}}],[\"boot\",{\"0\":{\"360\":1},\"1\":{\"334\":1,\"360\":2,\"549\":1}}],[\"boot<\",{\"1\":{\"334\":1,\"360\":1}}],[\"boolean\",{\"1\":{\"288\":1,\"517\":1}}],[\"bool\",{\"1\":{\"36\":2}}],[\"body\",{\"1\":{\"291\":2,\"307\":1}}],[\"but\",{\"1\":{\"432\":1}}],[\"buf\",{\"1\":{\"425\":1,\"426\":5,\"462\":1}}],[\"bufferedreader\",{\"1\":{\"422\":2}}],[\"buffer中完成排序操作\",{\"1\":{\"209\":1}}],[\"buffer\",{\"0\":{\"61\":1,\"62\":1,\"63\":1,\"71\":1},\"1\":{\"62\":4,\"63\":1,\"73\":2,\"75\":1,\"211\":1,\"428\":1}}],[\"build\",{\"1\":{\"282\":1,\"283\":2}}],[\"bv1kr4y1b7qc\",{\"1\":{\"546\":1}}],[\"bv1kr4y1i7ru\",{\"1\":{\"171\":1}}],[\"bv1cr4y1671t\",{\"1\":{\"266\":1}}],[\"bit\",{\"1\":{\"465\":1}}],[\"bits\",{\"1\":{\"405\":1,\"426\":4,\"447\":4,\"456\":1,\"465\":1}}],[\"bits是long类型数组\",{\"1\":{\"405\":1}}],[\"bitop是⼀个复合操作\",{\"1\":{\"397\":1}}],[\"bitop\",{\"1\":{\"397\":1}}],[\"bitcount\",{\"1\":{\"397\":1}}],[\"bitmap不是⼀种数据类型\",{\"1\":{\"397\":1}}],[\"bitmap类型\",{\"0\":{\"397\":1}}],[\"bitmap\",{\"1\":{\"375\":1,\"395\":1}}],[\"bin\",{\"1\":{\"370\":1}}],[\"bind\",{\"1\":{\"339\":1,\"369\":1}}],[\"binlog\",{\"1\":{\"140\":1}}],[\"bigint\",{\"1\":{\"244\":1}}],[\"bilibili\",{\"1\":{\"171\":1,\"266\":1,\"546\":1}}],[\"be\",{\"1\":{\"432\":2,\"447\":1}}],[\"bean\",{\"1\":{\"334\":2,\"353\":1}}],[\"ben\",{\"1\":{\"280\":1,\"281\":1}}],[\"behind\",{\"1\":{\"275\":1}}],[\"begin\",{\"1\":{\"155\":1,\"157\":1,\"158\":1,\"159\":1,\"240\":1,\"246\":1,\"251\":1,\"254\":1,\"256\":1}}],[\"beforesleep\",{\"1\":{\"462\":2}}],[\"beforeeach\",{\"1\":{\"351\":1}}],[\"before\",{\"1\":{\"155\":1,\"462\":1}}],[\"between\",{\"1\":{\"121\":1,\"187\":1}}],[\"bytes\",{\"1\":{\"442\":5,\"447\":2}}],[\"byte\",{\"1\":{\"426\":1}}],[\"by查询时是直接通过索引进行查询\",{\"1\":{\"209\":1}}],[\"by优化\",{\"0\":{\"208\":1,\"212\":1}}],[\"by\",{\"1\":{\"134\":2,\"166\":1,\"184\":2,\"185\":2,\"190\":1,\"191\":1,\"193\":2,\"195\":2,\"202\":2,\"210\":1,\"309\":1,\"311\":1}}],[\"b+tree索引\",{\"1\":{\"123\":1,\"236\":1}}],[\"b+树支持范围匹配和排序操作\",{\"1\":{\"122\":1}}],[\"b+树具有更少的层级\",{\"1\":{\"122\":1}}],[\"b+树是b树的一个变种\",{\"1\":{\"119\":1}}],[\"b+树\",{\"0\":{\"119\":1},\"1\":{\"119\":1}}],[\"b\",{\"1\":{\"118\":1}}],[\"b树知识点\",{\"1\":{\"118\":1}}],[\"b树随着数据的插入或者删除会自动进行节点的裂变和合并\",{\"1\":{\"118\":1}}],[\"b树\",{\"0\":{\"118\":1},\"1\":{\"118\":2}}],[\"bdb等存储引擎中\",{\"1\":{\"142\":1}}],[\"bdb\",{\"1\":{\"109\":1}}],[\"b之间的交集部分\",{\"1\":{\"94\":1}}],[\"由功能完善的软件实现资源共享和信息传递的系统\",{\"1\":{\"564\":1}}],[\"由题目可得\",{\"1\":{\"534\":1}}],[\"由范围\",{\"1\":{\"514\":1}}],[\"由定义可知\",{\"1\":{\"498\":1}}],[\"由一系列特殊编码的连续内存块组成\",{\"1\":{\"440\":1}}],[\"由三部分组成\",{\"1\":{\"435\":1}}],[\"由redis自己维护\",{\"1\":{\"339\":1}}],[\"由操作系统决定何时将缓冲区内容写回磁盘\",{\"1\":{\"320\":1}}],[\"由\",{\"1\":{\"288\":1,\"319\":1}}],[\"由其他线程异步的将缓存数据持久化到数据库\",{\"1\":{\"275\":1}}],[\"由服务来维护一致性\",{\"1\":{\"275\":1}}],[\"由缓存的调用者\",{\"1\":{\"275\":1}}],[\"由于他们的尺寸都是1\",{\"1\":{\"491\":1}}],[\"由于\",{\"1\":{\"443\":1}}],[\"由于redis的作者仅编写了linux环境下的版本\",{\"1\":{\"366\":1}}],[\"由于是存储在内存汇总\",{\"1\":{\"280\":1}}],[\"由于受到硬件问题\",{\"1\":{\"236\":1}}],[\"由于数据量的巨大\",{\"1\":{\"227\":1}}],[\"由于数据在页内存储会根据主键排序\",{\"1\":{\"205\":1}}],[\"由于要保证page之间有序\",{\"1\":{\"205\":1}}],[\"由于对表字段的修改\",{\"1\":{\"177\":1}}],[\"由于服务端的资源是在第二次握手时创建的\",{\"1\":{\"15\":1}}],[\"由多张相互连接的二维表组成的数据库\",{\"1\":{\"108\":1}}],[\"由瑞典mysql\",{\"1\":{\"104\":1}}],[\"由图可知\",{\"1\":{\"60\":1}}],[\"具有巨大的经济效益\",{\"1\":{\"577\":1}}],[\"具有独立功能的计算机系统\",{\"1\":{\"564\":1}}],[\"具有崩溃恢复特征\",{\"1\":{\"59\":1}}],[\"具备类型升级机制\",{\"1\":{\"433\":1}}],[\"具备一些特点\",{\"1\":{\"433\":1}}],[\"具体流程如下\",{\"1\":{\"405\":1}}],[\"具体语法如下\",{\"1\":{\"254\":1}}],[\"具体语法为\",{\"1\":{\"249\":1,\"250\":1,\"253\":1}}],[\"具体的实现底层对用户来说是透明的\",{\"1\":{\"464\":1}}],[\"具体的\",{\"1\":{\"459\":1}}],[\"具体的核心实现如下\",{\"1\":{\"426\":1}}],[\"具体的可以参考redis官方提供的文档\",{\"1\":{\"374\":1}}],[\"具体的流程如下\",{\"1\":{\"345\":1}}],[\"具体的放到下一个小节来说\",{\"1\":{\"273\":1}}],[\"具体的事务回滚\",{\"1\":{\"84\":1}}],[\"具体的删除\",{\"1\":{\"50\":1}}],[\"具体的步骤如下\",{\"1\":{\"15\":1,\"17\":1,\"432\":1,\"438\":1}}],[\"具体是怎么做的\",{\"1\":{\"29\":1}}],[\"具体操作如下\",{\"1\":{\"22\":1,\"202\":1}}],[\"它使计算机网络中的资源互通有无\",{\"1\":{\"574\":1}}],[\"它使网络具有数据传输\",{\"1\":{\"571\":1}}],[\"它为边缘部分提供连通性和交换服务\",{\"1\":{\"570\":1}}],[\"它能够调用用户所需要的资源\",{\"1\":{\"567\":1}}],[\"它被用在几乎所有的\",{\"1\":{\"428\":1}}],[\"它就是\",{\"1\":{\"385\":1}}],[\"它有一个消息链表\",{\"1\":{\"385\":1}}],[\"它们不保证关系数据的acid特性\",{\"1\":{\"363\":1}}],[\"它的refcount属性被设置为1\",{\"1\":{\"470\":1}}],[\"它的性能瓶颈是网络延迟而不是执行速度\",{\"1\":{\"458\":1}}],[\"它的\",{\"1\":{\"355\":1}}],[\"它count\",{\"1\":{\"219\":1}}],[\"它可以做多个bitmaps的and\",{\"1\":{\"397\":1}}],[\"它可以更好地确定哪个索引更有效地用于查询\",{\"1\":{\"134\":1}}],[\"它可以减轻\",{\"1\":{\"73\":1}}],[\"它记录一条对应相反的update记录\",{\"1\":{\"76\":1}}],[\"它是计算机网络最基本和最重要的功能用来实现联网计算机之间各种信息的传输\",{\"1\":{\"573\":1}}],[\"它是一个双端链表\",{\"1\":{\"444\":1}}],[\"它是一个不可分割的工作单位\",{\"1\":{\"74\":1}}],[\"它是\",{\"1\":{\"428\":1}}],[\"它是逻辑日志\",{\"1\":{\"76\":1}}],[\"它对数据库中数据的改变就是永久的\",{\"1\":{\"74\":1,\"257\":1}}],[\"它也可能包含表和索引数据\",{\"1\":{\"66\":1}}],[\"它擅长事务处理\",{\"1\":{\"59\":1}}],[\"它完成第四层传输层所指定的功能\",{\"1\":{\"14\":1}}],[\"架构的软件\",{\"1\":{\"421\":1}}],[\"架构\",{\"0\":{\"59\":1}}],[\"行数据\",{\"1\":{\"205\":1}}],[\"行\",{\"1\":{\"204\":1}}],[\"行内数据字段分隔符号\",{\"1\":{\"202\":1}}],[\"行和列数据来自定义视图中使用的表\",{\"1\":{\"162\":1}}],[\"行级触发器\",{\"1\":{\"155\":1}}],[\"行级触发\",{\"1\":{\"153\":1}}],[\"行级锁\",{\"0\":{\"146\":1},\"1\":{\"146\":1,\"234\":1}}],[\"行锁和间隙锁组合\",{\"1\":{\"146\":1}}],[\"行锁\",{\"0\":{\"147\":1},\"1\":{\"146\":1,\"236\":1}}],[\"行锁是通过对索引上的索引项加锁来实现的\",{\"1\":{\"146\":1}}],[\"行子查询指的是子查询返回的结果是一行\",{\"1\":{\"101\":1}}],[\"行子查询\",{\"0\":{\"101\":1},\"1\":{\"98\":1}}],[\"行row\",{\"1\":{\"58\":1}}],[\"行为\",{\"1\":{\"50\":1}}],[\"512\",{\"1\":{\"415\":1,\"421\":1}}],[\"5种io模型\",{\"1\":{\"401\":1}}],[\"5种基本数据类型\",{\"0\":{\"375\":1},\"1\":{\"262\":1}}],[\"5以后\",{\"1\":{\"234\":1}}],[\"5中引入了mdl\",{\"1\":{\"144\":1}}],[\"5\",{\"0\":{\"298\":1,\"561\":1,\"577\":1},\"1\":{\"123\":1,\"129\":3,\"132\":1,\"193\":1,\"201\":2,\"291\":1,\"293\":2,\"297\":1,\"341\":1,\"345\":1,\"353\":1,\"373\":2,\"385\":1,\"405\":2,\"422\":1,\"426\":7,\"437\":1,\"443\":1,\"448\":1,\"466\":1,\"467\":1,\"503\":1,\"514\":2,\"541\":4}}],[\"5版本开始\",{\"1\":{\"59\":1}}],[\"5个区\",{\"1\":{\"58\":1}}],[\"509\",{\"0\":{\"495\":1}}],[\"50x\",{\"1\":{\"306\":2}}],[\"504\",{\"1\":{\"306\":1}}],[\"503\",{\"1\":{\"306\":1}}],[\"502\",{\"1\":{\"306\":1}}],[\"5000\",{\"1\":{\"331\":1,\"339\":1}}],[\"500\",{\"1\":{\"306\":1}}],[\"50\",{\"1\":{\"36\":1}}],[\"页合并\",{\"0\":{\"206\":1}}],[\"页内剩余空间不足时\",{\"1\":{\"205\":1}}],[\"页可以为空\",{\"1\":{\"205\":1}}],[\"页分裂\",{\"0\":{\"205\":1}}],[\"页\",{\"1\":{\"204\":1}}],[\"页中数据与磁盘中数据产生了不一致\",{\"1\":{\"61\":1}}],[\"页是innodb存储引擎磁盘管理的最小单元\",{\"1\":{\"58\":1}}],[\"页page\",{\"1\":{\"58\":1}}],[\"区\",{\"1\":{\"204\":1}}],[\"区分度越高\",{\"1\":{\"134\":1}}],[\"区别于关系数据库\",{\"1\":{\"363\":1}}],[\"区别\",{\"1\":{\"104\":1,\"190\":1}}],[\"区是表空间中的单元结构\",{\"1\":{\"58\":1}}],[\"区extent\",{\"1\":{\"58\":1}}],[\"段\",{\"1\":{\"204\":1}}],[\"段用来管理多个extent区\",{\"1\":{\"58\":1}}],[\"段分为数据段\",{\"1\":{\"58\":1}}],[\"段segment\",{\"1\":{\"58\":1}}],[\"逻辑过期\",{\"1\":{\"272\":2}}],[\"逻辑存储结构\",{\"0\":{\"58\":1},\"1\":{\"204\":1}}],[\"逻辑结构\",{\"1\":{\"33\":2}}],[\"获取生成数组中的最大值\",{\"0\":{\"483\":1},\"1\":{\"485\":1}}],[\"获取c\",{\"1\":{\"462\":1}}],[\"获取当前客户端\",{\"1\":{\"462\":1}}],[\"获取当前值编码\",{\"1\":{\"432\":1}}],[\"获取字符串长度的时间复杂度为\",{\"1\":{\"427\":1}}],[\"获取字符串长度需要进行运算\",{\"1\":{\"425\":1}}],[\"获取数组大小\",{\"1\":{\"422\":1}}],[\"获取授权\",{\"1\":{\"422\":1}}],[\"获取输出流\",{\"1\":{\"422\":1}}],[\"获取bitmaps中某个偏移量的值\",{\"1\":{\"397\":1}}],[\"获取地理位置的坐标\",{\"1\":{\"396\":1}}],[\"获取消息列表\",{\"1\":{\"385\":1,\"390\":1,\"391\":1}}],[\"获取流包含的元素数量\",{\"1\":{\"385\":1,\"389\":1}}],[\"获取指定score范围内的元素\",{\"1\":{\"380\":1}}],[\"获取指定排名范围内的元素\",{\"1\":{\"380\":1}}],[\"获取指定日期date的天数\",{\"1\":{\"55\":1}}],[\"获取指定日期date的月份\",{\"1\":{\"55\":1}}],[\"获取指定日期date的年份\",{\"1\":{\"55\":1}}],[\"获取sorted\",{\"1\":{\"380\":3}}],[\"获取set中的所有元素\",{\"1\":{\"379\":1}}],[\"获取一个hash类型的key中的所有的value\",{\"1\":{\"377\":1}}],[\"获取一个hash类型的key中的所有的field\",{\"1\":{\"377\":1}}],[\"获取一个hash类型的key中的所有的field和value\",{\"1\":{\"377\":1}}],[\"获取一个hash类型key的field的值\",{\"1\":{\"377\":1}}],[\"获取一个\",{\"1\":{\"359\":1}}],[\"获取一个连接\",{\"1\":{\"307\":1}}],[\"获取一条\",{\"1\":{\"354\":1,\"360\":1}}],[\"获取连接\",{\"1\":{\"351\":1}}],[\"获取jedis对象\",{\"1\":{\"347\":1}}],[\"获取\",{\"1\":{\"302\":1,\"360\":1,\"462\":1}}],[\"获取锁\",{\"1\":{\"272\":1}}],[\"获取游标记录\",{\"1\":{\"252\":1}}],[\"获取表l中第i个位置的数据元素的值\",{\"1\":{\"35\":1}}],[\"向网络用户提供共享其他计算机上的硬件资源\",{\"1\":{\"571\":1}}],[\"向上爬一个台阶\",{\"1\":{\"532\":2}}],[\"向上爬两个台阶\",{\"1\":{\"532\":5}}],[\"向上取整\",{\"1\":{\"54\":1}}],[\"向下\",{\"1\":{\"509\":6}}],[\"向下取整\",{\"1\":{\"54\":1}}],[\"向右\",{\"1\":{\"509\":3}}],[\"向服务端\",{\"1\":{\"421\":1}}],[\"向其中添加关注的fd\",{\"1\":{\"406\":1}}],[\"向队列添加消息\",{\"1\":{\"386\":1}}],[\"向set中添加一个或多个元素\",{\"1\":{\"379\":1}}],[\"向列表右侧插入一个或多个元素\",{\"1\":{\"378\":1}}],[\"向列表左侧插入一个或多个元素\",{\"1\":{\"378\":1}}],[\"向集群中添加一个新\",{\"1\":{\"344\":1}}],[\"向tomcat发送http请求\",{\"0\":{\"313\":1}}],[\"向客户端发送连接释放报文段\",{\"1\":{\"17\":1}}],[\"向客户端发送确认报文段并且将syn同步位和ack都置为1\",{\"1\":{\"15\":1}}],[\"数字\",{\"1\":{\"422\":1}}],[\"数值\",{\"1\":{\"421\":1}}],[\"数值函数\",{\"0\":{\"54\":1}}],[\"数\",{\"1\":{\"398\":1}}],[\"数量增多而产生显著的下降\",{\"1\":{\"410\":1}}],[\"数量\",{\"1\":{\"387\":1,\"390\":1,\"391\":1,\"392\":1,\"406\":1}}],[\"数组初始化会将所有的元素默认初始化为\",{\"1\":{\"506\":1}}],[\"数组初始化\",{\"1\":{\"503\":1}}],[\"数组查询\",{\"1\":{\"432\":1}}],[\"数组扩容\",{\"0\":{\"432\":1},\"1\":{\"432\":2}}],[\"数组的初始化\",{\"1\":{\"506\":1}}],[\"数组的最大长度\",{\"1\":{\"407\":1}}],[\"数组的索引可以是数字\",{\"1\":{\"288\":1}}],[\"数组到用户空间\",{\"1\":{\"406\":1}}],[\"数组拷贝到内核空间\",{\"1\":{\"406\":1}}],[\"数组拷贝到内核空间中\",{\"1\":{\"405\":1}}],[\"数组大小自定义\",{\"1\":{\"406\":1}}],[\"数组元素个数\",{\"1\":{\"406\":1}}],[\"数组\",{\"1\":{\"405\":1,\"406\":2,\"407\":1,\"421\":1,\"436\":1,\"462\":1,\"506\":1,\"526\":1,\"529\":1,\"536\":2,\"538\":2}}],[\"数组中的初始值\",{\"1\":{\"526\":1,\"529\":1}}],[\"数组中保存的是指向\",{\"1\":{\"436\":1}}],[\"数组中\",{\"1\":{\"311\":1,\"430\":1}}],[\"数据链路层\",{\"0\":{\"578\":1}}],[\"数据资源的利用率\",{\"1\":{\"574\":1}}],[\"数据共享\",{\"1\":{\"574\":1}}],[\"数据通信\",{\"0\":{\"573\":1}}],[\"数据指针\",{\"1\":{\"456\":1}}],[\"数据拆分存储以后比较分散\",{\"1\":{\"444\":1}}],[\"数据读写的io操作\",{\"1\":{\"413\":1}}],[\"数据就绪或超时后\",{\"1\":{\"406\":1}}],[\"数据就绪以后\",{\"1\":{\"403\":1}}],[\"数据不可读或者不可写\",{\"1\":{\"404\":1}}],[\"数据关联\",{\"1\":{\"364\":1}}],[\"数据时\",{\"1\":{\"359\":1}}],[\"数据迁移\",{\"1\":{\"345\":1}}],[\"数据恢复优先级\",{\"1\":{\"321\":1}}],[\"数据完整性\",{\"1\":{\"321\":1}}],[\"数据快照\",{\"1\":{\"319\":1}}],[\"数据备份文件\",{\"1\":{\"319\":1}}],[\"数据持久化解决\",{\"1\":{\"318\":1}}],[\"数据丢失问题\",{\"1\":{\"318\":1}}],[\"数据落后于\",{\"1\":{\"300\":1}}],[\"数据同步原理\",{\"0\":{\"299\":1}}],[\"数据经常发生改变\",{\"1\":{\"274\":1}}],[\"数据一致性成本\",{\"1\":{\"269\":1}}],[\"数据和索引\",{\"1\":{\"234\":1}}],[\"数据按主键排序\",{\"1\":{\"205\":1}}],[\"数据控制语言\",{\"1\":{\"174\":1,\"194\":1}}],[\"数据查询语言\",{\"1\":{\"174\":1}}],[\"数据操作除了插入和查询之外\",{\"1\":{\"237\":1}}],[\"数据操作语言\",{\"1\":{\"174\":1}}],[\"数据操作流程\",{\"1\":{\"75\":1}}],[\"数据表权限\",{\"1\":{\"196\":2}}],[\"数据表操作\",{\"0\":{\"177\":1}}],[\"数据表\",{\"1\":{\"174\":1}}],[\"数据定义语言\",{\"1\":{\"174\":1}}],[\"数据校验等操作\",{\"1\":{\"153\":1}}],[\"数据也是一种供许多用户共享的资源\",{\"1\":{\"136\":1}}],[\"数据分布影响\",{\"1\":{\"129\":1}}],[\"数据是有组织的进行存储\",{\"1\":{\"104\":1}}],[\"数据是信息的载体\",{\"1\":{\"32\":1}}],[\"数据被修改过\",{\"1\":{\"61\":1}}],[\"数据段就是b+树的叶子结点\",{\"1\":{\"58\":1}}],[\"数据域\",{\"1\":{\"37\":1}}],[\"数据的读取速度是非常快的\",{\"1\":{\"280\":1}}],[\"数据的变化频率低\",{\"1\":{\"274\":1}}],[\"数据的安全性也越高\",{\"1\":{\"259\":1}}],[\"数据的组织方式\",{\"0\":{\"204\":1}}],[\"数据的查询\",{\"1\":{\"64\":1}}],[\"数据的逻辑结构和存储结构是密不可分的两个方面\",{\"1\":{\"33\":1}}],[\"数据的运算\",{\"1\":{\"33\":2}}],[\"数据都不是独立存在的\",{\"1\":{\"32\":1}}],[\"数据结构不固定\",{\"1\":{\"364\":1}}],[\"数据结构固定2\",{\"1\":{\"364\":1}}],[\"数据结构的底层实现\",{\"0\":{\"423\":1},\"1\":{\"265\":1}}],[\"数据结构的基本概念\",{\"0\":{\"31\":1}}],[\"数据结构包含三个要素\",{\"1\":{\"33\":1}}],[\"数据结构三要素\",{\"0\":{\"33\":1}}],[\"数据结构\",{\"0\":{\"42\":1},\"1\":{\"32\":1,\"364\":1}}],[\"数据类型中\",{\"1\":{\"446\":1}}],[\"数据类型是一个值的集合和定义在此集合上的一组操作的总称\",{\"1\":{\"32\":1}}],[\"数据类型\",{\"0\":{\"467\":1},\"1\":{\"32\":1,\"49\":1,\"178\":1,\"288\":1,\"467\":1}}],[\"数据对象是具有相同性质的数据元素的集合\",{\"1\":{\"32\":1}}],[\"数据对象\",{\"1\":{\"32\":1}}],[\"数据项是构成数据元素的不可分割的最小单位\",{\"1\":{\"32\":1}}],[\"数据元素\",{\"1\":{\"32\":1}}],[\"数据\",{\"1\":{\"32\":1,\"113\":1,\"319\":1,\"343\":1,\"408\":1}}],[\"数据库数量\",{\"1\":{\"339\":1}}],[\"数据库发生修改则直接删除对应的缓存\",{\"1\":{\"275\":1}}],[\"数据库中也不存在\",{\"1\":{\"270\":1}}],[\"数据库中加全局锁\",{\"1\":{\"140\":1}}],[\"数据库提供的隔离机制\",{\"1\":{\"257\":1}}],[\"数据库名和表名可以使用\",{\"1\":{\"196\":1}}],[\"数据库名\",{\"1\":{\"176\":3,\"196\":2}}],[\"数据库操作\",{\"0\":{\"176\":1}}],[\"数据库可以授权\",{\"1\":{\"167\":1}}],[\"数据库系统还维护着满足特定查找算法的数据结构\",{\"1\":{\"113\":1}}],[\"数据库系统提供的隔离机制\",{\"1\":{\"74\":1}}],[\"数据库类型\",{\"0\":{\"107\":1}}],[\"数据库管理系统\",{\"1\":{\"104\":1}}],[\"数据库是存储数据的仓库\",{\"1\":{\"104\":1}}],[\"数据库\",{\"0\":{\"6\":1,\"169\":1,\"260\":1},\"1\":{\"104\":1,\"109\":1,\"174\":1}}],[\"达到n个字符串长度\",{\"1\":{\"53\":2}}],[\"功能丰富\",{\"1\":{\"365\":1}}],[\"功能\",{\"1\":{\"53\":1,\"54\":1,\"55\":1,\"56\":1,\"187\":1,\"189\":1,\"227\":1,\"320\":1}}],[\"函数可以接受可变数目的参数\",{\"1\":{\"291\":1}}],[\"函数返回值\",{\"1\":{\"291\":1}}],[\"函数中需要执行的代码语句块\",{\"1\":{\"291\":1}}],[\"函数体\",{\"1\":{\"291\":1}}],[\"函数也可以不带参数\",{\"1\":{\"291\":1}}],[\"函数参数\",{\"1\":{\"291\":1}}],[\"函数等\",{\"1\":{\"231\":1}}],[\"函数是一段可以直接被另一段程序调用的程序或者代码\",{\"1\":{\"52\":1}}],[\"函数\",{\"0\":{\"52\":1,\"291\":1},\"1\":{\"52\":1,\"53\":1,\"54\":1,\"55\":1,\"56\":1,\"170\":1,\"189\":1,\"310\":1,\"406\":1,\"436\":1,\"455\":1}}],[\"父表有变更时\",{\"1\":{\"50\":1}}],[\"默认使用的还是\",{\"1\":{\"421\":1}}],[\"默认使用innodb存储引擎\",{\"1\":{\"59\":1}}],[\"默认64字节\",{\"1\":{\"417\":1}}],[\"默认512\",{\"1\":{\"417\":1}}],[\"默认提供了一个\",{\"1\":{\"355\":1}}],[\"默认的流程\",{\"1\":{\"345\":1}}],[\"默认的聚集索引就是主键索引\",{\"1\":{\"204\":1}}],[\"默认会加载这个文件\",{\"1\":{\"319\":1}}],[\"默认是6379\",{\"1\":{\"372\":1}}],[\"默认是127\",{\"1\":{\"369\":1,\"372\":1}}],[\"默认是采用\",{\"1\":{\"352\":1}}],[\"默认是下标为0的库\",{\"1\":{\"351\":1}}],[\"默认是关闭的\",{\"1\":{\"320\":2}}],[\"默认是在\",{\"1\":{\"319\":1}}],[\"默认是保存在当前运行目录\",{\"1\":{\"319\":1}}],[\"默认是session\",{\"1\":{\"242\":1}}],[\"默认\",{\"1\":{\"246\":1,\"456\":1}}],[\"默认10秒\",{\"1\":{\"227\":1}}],[\"默认值为0\",{\"1\":{\"448\":1}}],[\"默认值为\",{\"1\":{\"448\":1}}],[\"默认值为cascaded\",{\"1\":{\"164\":1}}],[\"默认值\",{\"1\":{\"191\":1,\"419\":2}}],[\"默认自动创建\",{\"1\":{\"124\":1}}],[\"默认个数\",{\"1\":{\"73\":1}}],[\"默认打开\",{\"1\":{\"67\":1}}],[\"默认为10\",{\"1\":{\"455\":1}}],[\"默认为256k\",{\"1\":{\"211\":1}}],[\"默认为asc\",{\"1\":{\"210\":1}}],[\"默认为页的50\",{\"1\":{\"206\":1}}],[\"默认为当前数据库\",{\"1\":{\"155\":1}}],[\"默认为\",{\"1\":{\"63\":1,\"455\":1,\"456\":1}}],[\"默认大小为16mb\",{\"1\":{\"63\":1}}],[\"默认情况下会在当前目录生成一个\",{\"1\":{\"319\":1}}],[\"默认情况下profile是关闭的\",{\"1\":{\"228\":1}}],[\"默认情况下\",{\"1\":{\"58\":1,\"305\":1}}],[\"默认行为\",{\"1\":{\"50\":2}}],[\"默认约束\",{\"1\":{\"47\":1}}],[\"首字节是\",{\"1\":{\"421\":5}}],[\"首先要求骑士必须从下标0开始行动\",{\"1\":{\"516\":1}}],[\"首先要安装openresty的依赖开发库\",{\"1\":{\"305\":1}}],[\"首先从题目中可知\",{\"1\":{\"511\":1}}],[\"首先从设置了过期时间的键集合中驱逐最久没有使用的键\",{\"1\":{\"276\":1,\"456\":1}}],[\"首先是链表\",{\"1\":{\"451\":1}}],[\"首先是该实例与其他实例失去连接\",{\"1\":{\"345\":1}}],[\"首先根据\",{\"1\":{\"436\":1}}],[\"首先选定一个\",{\"1\":{\"328\":1}}],[\"首先会判断\",{\"1\":{\"326\":1}}],[\"首先你的linux虚拟机必须联网\",{\"1\":{\"305\":1}}],[\"首先通过lru算法驱逐最久没有使用的键\",{\"1\":{\"276\":1,\"456\":1}}],[\"首先检查该记录是否有对应外键\",{\"1\":{\"50\":4}}],[\"首页\",{\"0\":{\"0\":1}}],[\"添加键值对时\",{\"1\":{\"436\":1}}],[\"添加到红黑树\",{\"1\":{\"410\":1}}],[\"添加到指定的key中\",{\"1\":{\"396\":1}}],[\"添加地理位置的坐标\",{\"1\":{\"396\":1}}],[\"添加消息到末尾\",{\"1\":{\"385\":1}}],[\"添加一个或多个元素到sorted\",{\"1\":{\"380\":1}}],[\"添加一个hash类型的key的field值\",{\"1\":{\"377\":1}}],[\"添加一个string类型的键值对\",{\"1\":{\"376\":2}}],[\"添加或者修改hash类型key的field的值\",{\"1\":{\"377\":1}}],[\"添加或者修改已经存在的一个string类型的键值对\",{\"1\":{\"376\":1}}],[\"添加\",{\"1\":{\"328\":1,\"334\":1,\"344\":1}}],[\"添加对\",{\"1\":{\"309\":2}}],[\"添加下面的内容\",{\"1\":{\"287\":1,\"331\":1}}],[\"添加数据\",{\"0\":{\"180\":1}}],[\"添加字段\",{\"1\":{\"178\":1}}],[\"添加了外键之后\",{\"1\":{\"50\":1}}],[\"添加外键\",{\"1\":{\"49\":1}}],[\"更重要的是还免\",{\"1\":{\"373\":1}}],[\"更改缓冲区\",{\"0\":{\"62\":1},\"1\":{\"62\":1}}],[\"更新缓存\",{\"1\":{\"274\":1}}],[\"更新完以后\",{\"1\":{\"272\":1}}],[\"更新数据权限\",{\"1\":{\"196\":1}}],[\"更新及作用\",{\"0\":{\"165\":1}}],[\"更新触发器\",{\"0\":{\"158\":1}}],[\"更新外键在子表中的记录\",{\"1\":{\"50\":1}}],[\"更新\",{\"1\":{\"50\":2,\"164\":1,\"226\":1,\"232\":1}}],[\"更新对应记录时\",{\"1\":{\"50\":3}}],[\"更新行\",{\"1\":{\"50\":1}}],[\"更新行为\",{\"0\":{\"50\":1},\"1\":{\"50\":1}}],[\"更好的记忆与吸收知识\",{\"1\":{\"2\":1}}],[\"字典dict\",{\"1\":{\"466\":1}}],[\"字典排序\",{\"1\":{\"453\":1}}],[\"字典的删除查找更新等操作可能会在两个哈希表上进行\",{\"1\":{\"438\":1}}],[\"字典\",{\"0\":{\"434\":1},\"1\":{\"435\":1,\"436\":1}}],[\"字节以上\",{\"1\":{\"443\":1}}],[\"字节以下变到\",{\"1\":{\"443\":1}}],[\"字节时\",{\"1\":{\"416\":1}}],[\"字节\",{\"1\":{\"415\":2,\"430\":5}}],[\"字段注释\",{\"1\":{\"178\":2}}],[\"字段数据类型\",{\"1\":{\"178\":1}}],[\"字段操作\",{\"0\":{\"178\":1}}],[\"字段n注释\",{\"1\":{\"177\":1}}],[\"字段n类型\",{\"1\":{\"177\":1}}],[\"字段n\",{\"1\":{\"177\":1,\"180\":2}}],[\"字段3注释\",{\"1\":{\"177\":1}}],[\"字段3类型\",{\"1\":{\"177\":1}}],[\"字段3\",{\"1\":{\"177\":1,\"186\":1}}],[\"字段2注释\",{\"1\":{\"177\":1}}],[\"字段2类型\",{\"1\":{\"177\":1}}],[\"字段2\",{\"1\":{\"177\":1,\"180\":2,\"186\":2,\"191\":1}}],[\"字段1注释\",{\"1\":{\"177\":1}}],[\"字段1类型\",{\"1\":{\"177\":1}}],[\"字段1\",{\"1\":{\"177\":1,\"180\":2,\"186\":2,\"191\":1}}],[\"字段的长度较长\",{\"1\":{\"134\":1}}],[\"字段类型也需要保持一致\",{\"1\":{\"97\":1}}],[\"字段列表\",{\"1\":{\"94\":2,\"95\":2,\"96\":1,\"97\":2,\"184\":1,\"186\":1,\"187\":1,\"189\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":1,\"229\":1}}],[\"字段\",{\"1\":{\"85\":1,\"174\":1,\"221\":2,\"441\":2}}],[\"字段解释\",{\"1\":{\"58\":1}}],[\"字段名2\",{\"1\":{\"181\":1}}],[\"字段名1\",{\"1\":{\"181\":1}}],[\"字段名\",{\"1\":{\"49\":1,\"178\":3,\"243\":1,\"244\":1}}],[\"字符集名\",{\"1\":{\"177\":1}}],[\"字符集\",{\"1\":{\"176\":1}}],[\"字符串可存储特殊字符\",{\"1\":{\"427\":1}}],[\"字符串对象string\",{\"0\":{\"415\":1}}],[\"字符串类型的最大空间不能超过512m\",{\"1\":{\"376\":1}}],[\"字符串类型不加引号\",{\"1\":{\"129\":1}}],[\"字符串或表类型\",{\"1\":{\"288\":1}}],[\"字符串由一对双引号或者单引号来表示\",{\"1\":{\"288\":1}}],[\"字符串和日期型数据应该包含在引号之中\",{\"1\":{\"180\":1}}],[\"字符串\",{\"0\":{\"376\":1},\"1\":{\"99\":1,\"358\":1,\"428\":1,\"442\":1,\"462\":1,\"467\":1}}],[\"字符串拼接\",{\"1\":{\"53\":1}}],[\"字符串函数\",{\"0\":{\"53\":1}}],[\"字符及所能输入到计算机中并能被计算机程序识别和处理的符号的集合\",{\"1\":{\"32\":1}}],[\"表数据都是根据主键顺序组织存放的\",{\"1\":{\"204\":1}}],[\"表内字段修改\",{\"1\":{\"177\":1}}],[\"表注释\",{\"1\":{\"177\":1}}],[\"表独占写锁\",{\"1\":{\"143\":1}}],[\"表共享读锁\",{\"1\":{\"143\":1}}],[\"表锁\",{\"0\":{\"143\":1},\"1\":{\"142\":1,\"236\":2}}],[\"表级锁\",{\"0\":{\"141\":1},\"1\":{\"142\":1}}],[\"表子查询指的是子查询返回的结果是多行多列的数据集\",{\"1\":{\"102\":1}}],[\"表子查询\",{\"0\":{\"102\":1},\"1\":{\"98\":1}}],[\"表b\",{\"1\":{\"97\":1}}],[\"表b的行数\",{\"1\":{\"93\":1}}],[\"表a\",{\"1\":{\"96\":2,\"97\":1}}],[\"表a的行数\",{\"1\":{\"93\":1}}],[\"表2\",{\"1\":{\"94\":2,\"95\":2,\"97\":1}}],[\"表1\",{\"1\":{\"94\":2,\"95\":2,\"97\":1}}],[\"表空间\",{\"1\":{\"204\":1}}],[\"表空间用来管理多个segment段\",{\"1\":{\"58\":1}}],[\"表空间tablespace\",{\"1\":{\"58\":1}}],[\"表名语句能够将所有的数据清空\",{\"1\":{\"177\":1}}],[\"表名\",{\"1\":{\"49\":3,\"50\":1,\"143\":1,\"177\":6,\"178\":4,\"180\":4,\"181\":1,\"182\":1,\"184\":1,\"186\":4,\"187\":1,\"189\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":1,\"196\":2,\"229\":1,\"243\":1,\"244\":1}}],[\"表示了骑士的有效巡视方案\",{\"1\":{\"514\":1}}],[\"表示单元格\",{\"1\":{\"514\":1}}],[\"表示该对象最后一次被访问的时间\",{\"1\":{\"465\":1}}],[\"表示未进行\",{\"1\":{\"436\":1}}],[\"表示二进制安全的字符串\",{\"1\":{\"421\":1}}],[\"表示\",{\"1\":{\"396\":1,\"496\":1}}],[\"表示从尾部开始消费\",{\"1\":{\"393\":1}}],[\"表示最大值\",{\"1\":{\"390\":1,\"391\":1}}],[\"表示最小值\",{\"1\":{\"390\":1,\"391\":1}}],[\"表示由\",{\"1\":{\"386\":1}}],[\"表示每执行一次写命令\",{\"1\":{\"320\":1}}],[\"表示禁用\",{\"1\":{\"319\":1}}],[\"表示函数有可变的参数\",{\"1\":{\"291\":1}}],[\"表示双精度类型的实浮点数\",{\"1\":{\"288\":1}}],[\"表示一个无效值\",{\"1\":{\"288\":1}}],[\"表示查询返回结果的行数占需要的读取行数的百分比\",{\"1\":{\"229\":1}}],[\"表示查询中执行\",{\"1\":{\"229\":1}}],[\"表示索引中使用的字节数\",{\"1\":{\"229\":1}}],[\"表示连接类型\",{\"1\":{\"229\":1}}],[\"表示select的类型\",{\"1\":{\"229\":1}}],[\"表示感谢\",{\"1\":{\"171\":1,\"266\":1}}],[\"表示结束\",{\"1\":{\"37\":1}}],[\"表示插入失败\",{\"1\":{\"36\":1}}],[\"表示同意断开连接\",{\"1\":{\"17\":2}}],[\"表示请求连接断开\",{\"1\":{\"17\":1}}],[\"cs架构一般指服务器\",{\"1\":{\"421\":1}}],[\"cs架构\",{\"1\":{\"421\":2}}],[\"cs\",{\"1\":{\"421\":1}}],[\"ctl\",{\"1\":{\"407\":1,\"410\":1,\"459\":1}}],[\"c++\",{\"1\":{\"365\":1}}],[\"c语言\",{\"1\":{\"365\":1}}],[\"crlf\",{\"1\":{\"421\":1}}],[\"crc16\",{\"1\":{\"343\":1}}],[\"creator\",{\"1\":{\"85\":1,\"86\":1}}],[\"createsocketaccepthandler\",{\"1\":{\"462\":1}}],[\"create\",{\"0\":{\"393\":1},\"1\":{\"49\":1,\"68\":3,\"127\":1,\"132\":1,\"155\":1,\"157\":1,\"158\":1,\"159\":1,\"163\":3,\"176\":1,\"177\":2,\"195\":1,\"196\":1,\"232\":1,\"240\":2,\"246\":1,\"254\":1,\"341\":3,\"385\":2,\"393\":4,\"407\":1,\"459\":1,\"462\":1}}],[\"c参数才可以\",{\"1\":{\"342\":1}}],[\"customize\",{\"1\":{\"334\":1}}],[\"current\",{\"1\":{\"447\":3}}],[\"cur\",{\"1\":{\"432\":5}}],[\"curenc\",{\"1\":{\"432\":2}}],[\"cursor\",{\"1\":{\"252\":1,\"454\":1}}],[\"curtime\",{\"1\":{\"55\":1}}],[\"curdate\",{\"1\":{\"55\":1}}],[\"c模块\",{\"1\":{\"307\":1}}],[\"centos\",{\"1\":{\"305\":2}}],[\"ceil\",{\"1\":{\"54\":1}}],[\"cpath\",{\"1\":{\"307\":1,\"309\":1}}],[\"cp\",{\"1\":{\"295\":4,\"331\":3,\"339\":1}}],[\"cpu\",{\"1\":{\"136\":1,\"228\":1,\"319\":1,\"403\":2,\"404\":2,\"458\":1}}],[\"cd\",{\"1\":{\"295\":1,\"331\":1,\"339\":3,\"340\":1,\"341\":1}}],[\"c\",{\"1\":{\"286\":1,\"288\":1,\"291\":1,\"304\":1,\"309\":1,\"342\":1,\"421\":2,\"425\":5,\"426\":1,\"428\":1,\"459\":1,\"462\":24}}],[\"cn\",{\"1\":{\"281\":1,\"304\":1,\"542\":1}}],[\"cnf\",{\"1\":{\"227\":1,\"242\":1}}],[\"cluster或者\",{\"1\":{\"341\":1}}],[\"cluster\",{\"1\":{\"339\":3,\"341\":4,\"344\":4,\"345\":2,\"346\":1}}],[\"class\",{\"1\":{\"334\":1,\"347\":1,\"353\":1,\"360\":1,\"422\":1,\"482\":1,\"494\":1,\"512\":1,\"517\":1,\"543\":3}}],[\"climbstairs2\",{\"1\":{\"529\":1}}],[\"climbstairs\",{\"1\":{\"523\":3,\"526\":1}}],[\"cli的交互控制台\",{\"1\":{\"372\":1}}],[\"cli客户端查看\",{\"1\":{\"352\":1}}],[\"cli客户端连接redis服务时\",{\"1\":{\"372\":1}}],[\"cli客户端连接对应的redis服务器后\",{\"1\":{\"352\":1}}],[\"cli客户端连接到redis服务\",{\"1\":{\"297\":1}}],[\"client1\",{\"1\":{\"381\":1}}],[\"client5\",{\"1\":{\"381\":1}}],[\"client2\",{\"1\":{\"381\":1}}],[\"clients\",{\"1\":{\"374\":1,\"462\":2}}],[\"clients<\",{\"1\":{\"351\":1}}],[\"client\",{\"1\":{\"349\":1,\"421\":1,\"460\":3,\"462\":3}}],[\"clientconfigurationbuilder\",{\"1\":{\"334\":4}}],[\"cli加上\",{\"1\":{\"342\":1}}],[\"cli中\",{\"1\":{\"341\":2}}],[\"cli连接7003\",{\"1\":{\"298\":1}}],[\"cli连接7002\",{\"1\":{\"298\":1}}],[\"cli连接7001\",{\"1\":{\"298\":1}}],[\"cli命令连接7003\",{\"1\":{\"297\":1}}],[\"cli命令连接7002\",{\"1\":{\"297\":1}}],[\"cli\",{\"1\":{\"296\":1,\"297\":3,\"340\":1,\"341\":3,\"342\":2,\"344\":4,\"372\":2}}],[\"close\",{\"1\":{\"252\":1,\"307\":2,\"351\":1,\"422\":3}}],[\"cleaner\",{\"1\":{\"73\":1}}],[\"clean\",{\"1\":{\"61\":1}}],[\"cannot\",{\"1\":{\"432\":1}}],[\"can\",{\"1\":{\"432\":2,\"447\":1}}],[\"catch\",{\"1\":{\"422\":2}}],[\"caltback触发时\",{\"1\":{\"407\":1}}],[\"callback\",{\"1\":{\"407\":1}}],[\"call\",{\"1\":{\"240\":1,\"462\":2}}],[\"capture\",{\"1\":{\"307\":1}}],[\"caffeine缓存驱逐策略\",{\"0\":{\"283\":1}}],[\"caffeine示例\",{\"0\":{\"282\":1}}],[\"caffeine\",{\"0\":{\"281\":1},\"1\":{\"280\":3,\"281\":6,\"282\":1,\"283\":4}}],[\"caching\",{\"1\":{\"275\":1}}],[\"cache<string\",{\"1\":{\"282\":1,\"283\":2}}],[\"cache\",{\"1\":{\"269\":2,\"275\":1,\"281\":2,\"282\":4,\"283\":2,\"307\":2}}],[\"cabinet\",{\"1\":{\"109\":1}}],[\"cassandra\",{\"1\":{\"109\":1}}],[\"case\",{\"0\":{\"247\":1},\"1\":{\"56\":2,\"247\":5,\"422\":5,\"432\":1}}],[\"cascaded会强制检查当前视图和其依赖的视图的筛选条件\",{\"1\":{\"164\":1}}],[\"cascaded\",{\"1\":{\"163\":3,\"164\":1}}],[\"cascade\",{\"1\":{\"50\":3}}],[\"cost\",{\"1\":{\"532\":6,\"534\":8,\"536\":8,\"538\":8}}],[\"core<\",{\"1\":{\"353\":1}}],[\"copy\",{\"1\":{\"319\":1}}],[\"coder\",{\"1\":{\"310\":1,\"354\":2}}],[\"codermast\",{\"1\":{\"282\":1,\"334\":1,\"347\":1,\"351\":3,\"352\":2,\"354\":1,\"360\":3,\"369\":2,\"422\":2}}],[\"count的用法\",{\"0\":{\"221\":1}}],[\"count优化\",{\"0\":{\"219\":1}}],[\"count\",{\"1\":{\"132\":4,\"166\":1,\"185\":1,\"189\":1,\"221\":9,\"387\":2,\"390\":3,\"391\":3,\"392\":3,\"394\":4,\"396\":4,\"447\":5}}],[\"couchdb\",{\"1\":{\"109\":1}}],[\"collision\",{\"1\":{\"435\":1}}],[\"collate\",{\"1\":{\"176\":1,\"177\":1}}],[\"column\",{\"1\":{\"132\":1}}],[\"column1\",{\"1\":{\"98\":2}}],[\"col\",{\"1\":{\"127\":1,\"514\":4}}],[\"computer\",{\"0\":{\"583\":1}}],[\"comp\",{\"1\":{\"447\":1}}],[\"compression\",{\"1\":{\"447\":1}}],[\"compress\",{\"1\":{\"447\":5,\"448\":2}}],[\"compressed\",{\"1\":{\"447\":2}}],[\"commonds为命令\",{\"1\":{\"372\":1}}],[\"commonds\",{\"1\":{\"372\":1}}],[\"commons<groupid>\",{\"1\":{\"360\":1}}],[\"common\",{\"1\":{\"307\":1}}],[\"command\",{\"1\":{\"361\":1}}],[\"comma\",{\"1\":{\"291\":2}}],[\"comment\",{\"1\":{\"177\":5,\"178\":2}}],[\"community\",{\"1\":{\"106\":1}}],[\"committed\",{\"1\":{\"259\":2}}],[\"commited\",{\"1\":{\"86\":1}}],[\"commit\",{\"1\":{\"63\":1,\"81\":1,\"200\":1,\"256\":1}}],[\"com\",{\"1\":{\"105\":1,\"171\":2,\"226\":5,\"266\":2,\"280\":1,\"281\":1,\"291\":2,\"350\":1,\"351\":2,\"373\":2,\"546\":2,\"549\":2}}],[\"connread\",{\"1\":{\"462\":1}}],[\"conngetprivatedata\",{\"1\":{\"462\":1}}],[\"connsetreadhandler\",{\"1\":{\"462\":1}}],[\"conncreatesocket\",{\"1\":{\"462\":1}}],[\"conn\",{\"1\":{\"462\":5}}],[\"connection\",{\"1\":{\"462\":3}}],[\"connections\",{\"1\":{\"306\":1}}],[\"connect\",{\"1\":{\"307\":1}}],[\"conf中的注释部分删除\",{\"1\":{\"306\":1}}],[\"conf中添加一行配置\",{\"1\":{\"297\":1}}],[\"conf\",{\"1\":{\"295\":11,\"296\":3,\"306\":1,\"309\":2,\"319\":1,\"320\":3,\"331\":5,\"332\":3,\"339\":4,\"340\":1,\"344\":2,\"369\":1,\"370\":1}}],[\"conf文件中的配置项\",{\"1\":{\"369\":1}}],[\"conf文件中指定每一个实例的绑定ip信息\",{\"1\":{\"295\":1}}],[\"conf文件拷贝到s2\",{\"1\":{\"331\":1}}],[\"conf文件拷贝到三个目录中\",{\"1\":{\"295\":1}}],[\"conf文件\",{\"0\":{\"309\":1},\"1\":{\"295\":1,\"306\":1,\"331\":1,\"339\":1}}],[\"configuration\",{\"1\":{\"353\":1}}],[\"config\",{\"1\":{\"273\":1,\"305\":1,\"339\":1,\"448\":1}}],[\"container\",{\"1\":{\"447\":1}}],[\"contents\",{\"1\":{\"430\":2,\"431\":1}}],[\"content\",{\"1\":{\"309\":1,\"311\":1,\"442\":2}}],[\"continue\",{\"1\":{\"253\":1,\"482\":3,\"543\":4}}],[\"controller\",{\"1\":{\"334\":1}}],[\"control\",{\"1\":{\"79\":1,\"174\":1,\"194\":1}}],[\"condition2\",{\"1\":{\"247\":1}}],[\"condition1\",{\"1\":{\"247\":1}}],[\"condition\",{\"1\":{\"131\":1,\"253\":3,\"289\":2}}],[\"concurrentmap\",{\"1\":{\"281\":2}}],[\"concurrency\",{\"1\":{\"79\":1}}],[\"concat\",{\"1\":{\"53\":1,\"157\":1,\"158\":1,\"159\":1}}],[\"consumername\",{\"1\":{\"393\":1}}],[\"consumer\",{\"1\":{\"385\":3,\"393\":2,\"394\":4}}],[\"const\",{\"1\":{\"229\":1,\"447\":1}}],[\"constraint\",{\"1\":{\"49\":2,\"50\":1}}],[\"consistency\",{\"1\":{\"74\":1,\"257\":1}}],[\"channel2\",{\"1\":{\"381\":1}}],[\"channel1\",{\"1\":{\"381\":3}}],[\"channel\",{\"1\":{\"381\":4}}],[\"change\",{\"0\":{\"62\":1},\"1\":{\"62\":2,\"178\":1}}],[\"char\",{\"1\":{\"202\":2,\"244\":1,\"426\":10,\"447\":6,\"462\":1}}],[\"characteristic说明\",{\"1\":{\"254\":1}}],[\"characteristic\",{\"1\":{\"254\":1}}],[\"character\",{\"1\":{\"177\":1,\"385\":1}}],[\"charset\",{\"1\":{\"176\":1}}],[\"checkarri\",{\"1\":{\"517\":3}}],[\"checkvalidgrid\",{\"1\":{\"517\":1}}],[\"check\",{\"1\":{\"47\":1,\"163\":3,\"164\":1,\"305\":1,\"432\":1}}],[\"保护模式\",{\"1\":{\"339\":1}}],[\"保存不同数据\",{\"1\":{\"337\":1}}],[\"保存数据时\",{\"1\":{\"47\":1}}],[\"保留有效部分\",{\"1\":{\"306\":1}}],[\"保留y位小数\",{\"1\":{\"54\":1}}],[\"保持与\",{\"1\":{\"300\":1}}],[\"保持数据的一致性\",{\"1\":{\"73\":1}}],[\"保证元素唯一\",{\"1\":{\"418\":1}}],[\"保证最终一致\",{\"1\":{\"275\":1}}],[\"保证一致性\",{\"1\":{\"272\":1}}],[\"保证读写的正确性\",{\"1\":{\"144\":1}}],[\"保证读者能够对知识点进行刨根问题\",{\"1\":{\"3\":1}}],[\"保证数据的完整性和正确性\",{\"1\":{\"234\":1}}],[\"保证数据的完整性\",{\"1\":{\"138\":1}}],[\"保证数据的一致性和完整性\",{\"1\":{\"47\":1}}],[\"保证所需要的所有数据都能够通过索引查询到\",{\"1\":{\"131\":1}}],[\"保证事务在不受外部并发操作影响的独立环境下运行\",{\"1\":{\"74\":1,\"257\":1}}],[\"保证字段值满足指定的条件\",{\"1\":{\"47\":1}}],[\"保证该字段的所有数据都是唯一\",{\"1\":{\"47\":1}}],[\"主动挑选部分\",{\"1\":{\"456\":1}}],[\"主动更新策略\",{\"0\":{\"275\":1}}],[\"主动更新\",{\"1\":{\"274\":2}}],[\"主节点的ip和端口\",{\"1\":{\"331\":1}}],[\"主节点名称\",{\"1\":{\"331\":1}}],[\"主观下线\",{\"1\":{\"325\":1}}],[\"主进程得到一个子进程\",{\"1\":{\"319\":1}}],[\"主进程得到子进程\",{\"1\":{\"319\":1}}],[\"主进程来执行\",{\"1\":{\"319\":1}}],[\"主\",{\"1\":{\"301\":1}}],[\"主从和哨兵可以解决高可用\",{\"1\":{\"337\":1}}],[\"主从集群\",{\"1\":{\"301\":1,\"334\":1}}],[\"主从第一次同步是全量同步\",{\"1\":{\"300\":1,\"301\":1}}],[\"主从复制\",{\"0\":{\"87\":1},\"1\":{\"170\":1}}],[\"主查询\",{\"1\":{\"229\":1}}],[\"主机名可以使用\",{\"1\":{\"195\":1}}],[\"主机名\",{\"1\":{\"195\":3,\"196\":3}}],[\"主表字段名\",{\"1\":{\"50\":1}}],[\"主表名\",{\"1\":{\"50\":1}}],[\"主表列名\",{\"1\":{\"49\":2}}],[\"主表\",{\"1\":{\"49\":2}}],[\"主键不可能为null\",{\"1\":{\"221\":1}}],[\"主键\",{\"1\":{\"221\":2}}],[\"主键设计原则\",{\"0\":{\"207\":1}}],[\"主键有序插入比主键乱序插入的速度要快\",{\"1\":{\"201\":1}}],[\"主键有序\",{\"1\":{\"201\":1}}],[\"主键乱序插入\",{\"1\":{\"205\":3}}],[\"主键乱序\",{\"1\":{\"201\":1}}],[\"主键顺序插入数据\",{\"1\":{\"205\":1}}],[\"主键顺序插入\",{\"0\":{\"201\":1},\"1\":{\"205\":2}}],[\"主键即使为bigint\",{\"1\":{\"126\":1}}],[\"主键索引就是聚集索引\",{\"1\":{\"124\":1}}],[\"主键索引\",{\"1\":{\"124\":2}}],[\"主键是一行数据的唯一标识\",{\"1\":{\"47\":1}}],[\"主键约束\",{\"1\":{\"47\":1}}],[\"主要以第二种方法为主\",{\"1\":{\"480\":1}}],[\"主要还是减少开销的权衡\",{\"1\":{\"432\":1}}],[\"主要由\",{\"1\":{\"304\":1}}],[\"主要是磁盘io资源但aof重写时会占用大量cpu和内存资源\",{\"1\":{\"321\":1}}],[\"主要是将数据存储在文件系统之上\",{\"1\":{\"231\":1}}],[\"主要是mysql中的ibd文件\",{\"1\":{\"58\":1}}],[\"主要完成大多书的核心服务功能\",{\"1\":{\"231\":1}}],[\"主要完成一些类似于连接处理\",{\"1\":{\"231\":1}}],[\"主要的性能瓶颈在命令的读写处理和命令的响应输出两个方面\",{\"1\":{\"461\":1}}],[\"主要的工作就落在创建这条sql查询语句上\",{\"1\":{\"162\":1}}],[\"主要的存储结构有\",{\"1\":{\"33\":1}}],[\"主要应用在innodb存储引擎中\",{\"1\":{\"146\":1}}],[\"主要用于消息队列\",{\"1\":{\"385\":1}}],[\"主要用于地理空间数据类型\",{\"1\":{\"115\":1}}],[\"主要用于回收事务已经提交了的\",{\"1\":{\"73\":1}}],[\"主要包含以下几种\",{\"1\":{\"115\":1}}],[\"主要有以下几个\",{\"1\":{\"459\":1}}],[\"主要有\",{\"1\":{\"109\":4}}],[\"主要负责调度其他线程\",{\"1\":{\"73\":1}}],[\"主要分为以下三类\",{\"1\":{\"146\":1}}],[\"主要分为以下三种类型\",{\"1\":{\"142\":1}}],[\"主要分为三个部分\",{\"1\":{\"60\":1}}],[\"主要分为\",{\"1\":{\"33\":1}}],[\"描述\",{\"1\":{\"47\":1,\"100\":1,\"115\":1,\"258\":1,\"288\":1,\"361\":1,\"376\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1,\"396\":1,\"397\":1,\"398\":1}}],[\"概念介绍\",{\"0\":{\"78\":1}}],[\"概念\",{\"0\":{\"45\":1,\"113\":1}}],[\"约束是作用于表中字段上的\",{\"1\":{\"47\":1}}],[\"约束是作用于表中字段上的规则\",{\"1\":{\"45\":1}}],[\"约束\",{\"0\":{\"44\":1},\"1\":{\"47\":1,\"170\":1,\"178\":2}}],[\"静态链表\",{\"0\":{\"40\":1},\"1\":{\"40\":1}}],[\"循环进行\",{\"1\":{\"516\":1}}],[\"循环遍历\",{\"1\":{\"488\":1}}],[\"循环监听事件\",{\"1\":{\"462\":1}}],[\"循环语句是由循环体及循环的终止条件两部分组成的\",{\"1\":{\"289\":1}}],[\"循环结构是在一定条件下反复执行某段程序的流程结构\",{\"1\":{\"289\":1}}],[\"循环结束的条件为\",{\"1\":{\"22\":1}}],[\"循环\",{\"0\":{\"248\":1,\"289\":1},\"1\":{\"250\":1,\"289\":1,\"506\":1,\"529\":2}}],[\"循环链表\",{\"0\":{\"39\":1},\"1\":{\"39\":1}}],[\"双端链表\",{\"1\":{\"444\":1,\"466\":1}}],[\"双端队列示意图\",{\"1\":{\"378\":1}}],[\"双写缓冲区\",{\"0\":{\"71\":1},\"1\":{\"71\":1}}],[\"双链表\",{\"0\":{\"38\":1},\"1\":{\"38\":1}}],[\"双方都可以进行数据的发送\",{\"1\":{\"15\":1}}],[\"总花费为\",{\"1\":{\"532\":2}}],[\"总共有\",{\"1\":{\"509\":1}}],[\"总等于\",{\"1\":{\"436\":1}}],[\"总结\",{\"0\":{\"302\":1,\"410\":1}}],[\"总结的一份有自己思考成分的笔记\",{\"1\":{\"3\":1}}],[\"总时间复杂度为\",{\"1\":{\"37\":1}}],[\"赋指针\",{\"1\":{\"37\":1}}],[\"赋值给dict\",{\"1\":{\"438\":2}}],[\"赋值\",{\"1\":{\"37\":1,\"243\":1,\"244\":1}}],[\"创建serversocket\",{\"1\":{\"462\":1}}],[\"创建多路复用程序\",{\"1\":{\"459\":1}}],[\"创建dictht\",{\"1\":{\"438\":2}}],[\"创建消费者组\",{\"1\":{\"385\":1,\"393\":1}}],[\"创建序列化对象\",{\"1\":{\"353\":1}}],[\"创建redistemplate对象\",{\"1\":{\"353\":1}}],[\"创建实例目录\",{\"1\":{\"344\":1}}],[\"创建集群\",{\"0\":{\"341\":1},\"1\":{\"341\":1}}],[\"创建目录\",{\"1\":{\"295\":2,\"331\":1,\"339\":1}}],[\"创建缓存对象\",{\"1\":{\"282\":1,\"283\":2}}],[\"创建一张名为users的表\",{\"1\":{\"232\":1}}],[\"创建一张表并且指定引擎\",{\"1\":{\"232\":1}}],[\"创建数据库\",{\"1\":{\"196\":1}}],[\"创建用户\",{\"1\":{\"195\":1}}],[\"创建\",{\"1\":{\"155\":1,\"163\":1,\"176\":1,\"177\":1,\"240\":1,\"319\":1,\"344\":1,\"406\":1,\"462\":1}}],[\"创建索引\",{\"1\":{\"127\":1}}],[\"创建表并且指定表空间\",{\"1\":{\"68\":1}}],[\"创建表空间\",{\"1\":{\"68\":1}}],[\"创建新节点\",{\"1\":{\"37\":1}}],[\"创建头结点\",{\"1\":{\"37\":1}}],[\"输出的顺序和三元组的顺序并不重要\",{\"1\":{\"477\":1}}],[\"输出\",{\"1\":{\"477\":3,\"491\":2,\"496\":3,\"509\":4,\"514\":2,\"519\":2,\"532\":2,\"541\":3}}],[\"输出操作\",{\"1\":{\"35\":1}}],[\"输入数据\",{\"0\":{\"552\":1}}],[\"输入流\",{\"1\":{\"422\":1}}],[\"输入\",{\"1\":{\"37\":1,\"477\":3,\"491\":2,\"496\":3,\"509\":4,\"514\":2,\"519\":2,\"532\":2,\"541\":3}}],[\"输入结点的值\",{\"1\":{\"37\":1}}],[\"h文件中实现如下\",{\"1\":{\"465\":1}}],[\"hz影响\",{\"1\":{\"455\":1}}],[\"hz\",{\"1\":{\"455\":1}}],[\"hi\",{\"1\":{\"427\":1}}],[\"hincrby\",{\"1\":{\"377\":1}}],[\"hvals\",{\"1\":{\"377\":1}}],[\"hkeys\",{\"1\":{\"377\":1}}],[\"hmget\",{\"1\":{\"377\":1}}],[\"hmset\",{\"1\":{\"377\":2}}],[\"hgetall\",{\"1\":{\"377\":1}}],[\"hget\",{\"1\":{\"377\":1}}],[\"hsetnx\",{\"1\":{\"377\":1}}],[\"hset\",{\"1\":{\"377\":2}}],[\"hyperloglog类型\",{\"0\":{\"398\":1}}],[\"hyperloglog\",{\"1\":{\"375\":1,\"395\":1,\"398\":4}}],[\"h\",{\"1\":{\"372\":1,\"426\":1,\"436\":2}}],[\"host\",{\"1\":{\"360\":1,\"422\":2}}],[\"however\",{\"1\":{\"426\":1}}],[\"how\",{\"1\":{\"344\":1}}],[\"home=\",{\"1\":{\"305\":1}}],[\"home\",{\"1\":{\"281\":1,\"305\":2}}],[\"ht\",{\"1\":{\"417\":1,\"418\":1,\"419\":2,\"436\":1,\"437\":1,\"438\":21,\"439\":2,\"466\":1,\"467\":3}}],[\"htm\",{\"1\":{\"306\":1}}],[\"html\",{\"1\":{\"291\":1,\"306\":5}}],[\"http\",{\"1\":{\"304\":1,\"306\":2,\"307\":5,\"308\":1,\"309\":1,\"334\":2}}],[\"https\",{\"1\":{\"105\":1,\"171\":2,\"266\":3,\"280\":1,\"281\":1,\"286\":1,\"291\":1,\"304\":1,\"305\":1,\"350\":1,\"351\":2,\"358\":1,\"366\":1,\"373\":2,\"374\":1,\"542\":1,\"546\":2,\"549\":2}}],[\"here\",{\"1\":{\"426\":1}}],[\"header\",{\"1\":{\"426\":4,\"452\":1}}],[\"head\",{\"1\":{\"407\":1,\"415\":1,\"447\":1}}],[\"headinsert\",{\"1\":{\"37\":1}}],[\"help\",{\"1\":{\"361\":2}}],[\"help指令\",{\"1\":{\"361\":1}}],[\"help指令查看\",{\"1\":{\"344\":1}}],[\"hello字符串\",{\"1\":{\"421\":1}}],[\"hello\",{\"1\":{\"282\":1,\"287\":5,\"288\":1}}],[\"handleresponse\",{\"1\":{\"422\":6}}],[\"handler\",{\"1\":{\"253\":3}}],[\"have\",{\"1\":{\"228\":1}}],[\"having\",{\"1\":{\"166\":1,\"184\":1,\"190\":3,\"193\":1}}],[\"hashtable\",{\"1\":{\"417\":1,\"437\":1}}],[\"hash表\",{\"1\":{\"380\":1,\"466\":1}}],[\"hash的常见命令有\",{\"1\":{\"377\":1}}],[\"hash结构可以将对象中的每个字段独立存储\",{\"1\":{\"377\":1}}],[\"hash类型的数据\",{\"1\":{\"377\":1}}],[\"hash类型\",{\"1\":{\"377\":1}}],[\"hashoperations\",{\"1\":{\"359\":1}}],[\"hashvalue\",{\"1\":{\"353\":1}}],[\"hashkey\",{\"1\":{\"353\":1}}],[\"hashmap\",{\"1\":{\"280\":1}}],[\"hash索引是存储引擎根据b+tree索引在指定条件下自动构建的\",{\"1\":{\"121\":1}}],[\"hash索引只能用于对等比较\",{\"1\":{\"121\":1}}],[\"hash索引\",{\"1\":{\"115\":1,\"123\":1,\"236\":1}}],[\"hash\",{\"0\":{\"64\":1,\"121\":1,\"377\":1},\"1\":{\"33\":1,\"64\":1,\"343\":2,\"356\":1,\"375\":1,\"395\":1,\"417\":5,\"435\":2,\"436\":3,\"467\":1}}],[\"hbase\",{\"1\":{\"109\":1,\"364\":1}}],[\"该数列由\",{\"1\":{\"496\":1}}],[\"该字节的后六位表示entry中存储的string长度\",{\"1\":{\"442\":1}}],[\"该类型\",{\"1\":{\"396\":1}}],[\"该类参数作为输出\",{\"1\":{\"246\":1}}],[\"该类参数作为输入\",{\"1\":{\"246\":1}}],[\"该参数是可选的指定函数是全局函数还是局部函数\",{\"1\":{\"291\":1}}],[\"该参数有三个值\",{\"1\":{\"63\":1}}],[\"该sql代表的意思是\",{\"1\":{\"232\":1}}],[\"该值为索引字段最大可能长度\",{\"1\":{\"229\":1}}],[\"该日志文件由两部分组成\",{\"1\":{\"72\":1,\"75\":1}}],[\"该方法从一个空表开始\",{\"1\":{\"37\":1}}],[\"该项目主要记录了本人在计算机技术学习道路上的收获和总结\",{\"1\":{\"1\":1}}],[\"头插法建立单链表\",{\"1\":{\"37\":1}}],[\"浪费内存\",{\"1\":{\"441\":1}}],[\"浪费大量的磁盘io\",{\"1\":{\"132\":1}}],[\"浪费了存储空间\",{\"1\":{\"37\":1}}],[\"浪费更多的资源\",{\"1\":{\"16\":1}}],[\"指令追加消息时自动创建\",{\"1\":{\"385\":1}}],[\"指令\",{\"1\":{\"361\":1}}],[\"指定redis的访问密码\",{\"1\":{\"372\":1}}],[\"指定要连接的redis节点的端口\",{\"1\":{\"372\":1}}],[\"指定要连接的redis节点的ip地址\",{\"1\":{\"372\":1}}],[\"指定分片集群的每一个节点信息\",{\"1\":{\"346\":1}}],[\"指定集群中每个master的副本个数为1\",{\"1\":{\"341\":1}}],[\"指定主节点信息\",{\"1\":{\"331\":1}}],[\"指定函数名称\",{\"1\":{\"291\":1}}],[\"指定字段\",{\"1\":{\"186\":1}}],[\"指定字段添加数据\",{\"1\":{\"180\":1}}],[\"指在insert\",{\"1\":{\"153\":1}}],[\"指针\",{\"1\":{\"465\":1}}],[\"指针的跨度不同\",{\"1\":{\"451\":1}}],[\"指针位置\",{\"1\":{\"415\":1}}],[\"指针跟着减少\",{\"1\":{\"122\":1}}],[\"指针域\",{\"1\":{\"37\":1}}],[\"指向数组的开头\",{\"1\":{\"481\":1}}],[\"指向数据的真实存储空间地址\",{\"1\":{\"465\":1}}],[\"指向真实数据\",{\"1\":{\"456\":1}}],[\"指向\",{\"1\":{\"113\":1}}],[\"指向的一的一方的主键\",{\"1\":{\"91\":1}}],[\"指向上一个版本\",{\"1\":{\"82\":1}}],[\"指向这条记录的上一个版本\",{\"1\":{\"82\":1}}],[\"指维护一个数据的多个版本\",{\"1\":{\"79\":1}}],[\"指出运算的具体操作步骤\",{\"1\":{\"33\":1}}],[\"指出运算的功能\",{\"1\":{\"33\":1}}],[\"通信设备和相应的网络协议组成\",{\"1\":{\"571\":1}}],[\"通信子网由各种传输介质\",{\"1\":{\"571\":1}}],[\"通信链路\",{\"1\":{\"569\":1}}],[\"通信一般分两步\",{\"1\":{\"421\":1}}],[\"通信协议resp\",{\"0\":{\"420\":1},\"1\":{\"265\":1}}],[\"通知用户进程\",{\"1\":{\"412\":1}}],[\"通知\",{\"1\":{\"324\":1,\"328\":1}}],[\"通配\",{\"1\":{\"195\":1}}],[\"通用\",{\"1\":{\"459\":1}}],[\"通用命令\",{\"1\":{\"359\":1}}],[\"通用语法\",{\"0\":{\"173\":1}}],[\"通用表空间需要通过\",{\"1\":{\"68\":1}}],[\"通用表空间\",{\"0\":{\"68\":1}}],[\"通过通信设备与线路连接起来\",{\"1\":{\"564\":1}}],[\"通过骑士的站位\",{\"1\":{\"516\":1}}],[\"通过前面的描述\",{\"1\":{\"468\":1}}],[\"通过对单线程网络模型的分析\",{\"1\":{\"461\":1}}],[\"通过配置项\",{\"1\":{\"448\":1}}],[\"通过首字节的字符来区分不同数据类型\",{\"1\":{\"421\":1}}],[\"通过编码实现\",{\"1\":{\"419\":1}}],[\"通过命令可以查看集群状态\",{\"1\":{\"341\":1}}],[\"通过ps查看状态\",{\"1\":{\"340\":1}}],[\"通过执行\",{\"1\":{\"320\":1}}],[\"通过实现\",{\"1\":{\"318\":1}}],[\"通过汇聚各种设计精良的\",{\"1\":{\"304\":1}}],[\"通过redis\",{\"1\":{\"297\":2}}],[\"通过一个迭代器函数来遍历所有值\",{\"1\":{\"289\":1}}],[\"通过have\",{\"1\":{\"228\":1}}],[\"通过慢查询日志\",{\"1\":{\"227\":1}}],[\"通过以下指令重新启动mysql服务器进行测试\",{\"1\":{\"227\":1}}],[\"通过以下sql\",{\"1\":{\"145\":1}}],[\"通过如下指令\",{\"1\":{\"226\":1}}],[\"通过\",{\"1\":{\"226\":1,\"305\":1,\"459\":1}}],[\"通过创建覆盖索引能够比较好地提高性能\",{\"1\":{\"218\":1}}],[\"通过有序索引顺序扫描直接返回有序数据\",{\"1\":{\"209\":1}}],[\"通过表的索引或全表扫描\",{\"1\":{\"209\":1}}],[\"通过视图用户只能查询和修改他们所能见到的数据\",{\"1\":{\"167\":1}}],[\"通过索引列对数据进行排序\",{\"1\":{\"114\":1}}],[\"通过节点中存储后续节点的指针来进行连接\",{\"1\":{\"37\":1}}],[\"通常用\",{\"1\":{\"496\":1}}],[\"通常用于临时表及缓存\",{\"1\":{\"237\":1}}],[\"通常只需要掌握基本数据类型即可\",{\"1\":{\"375\":1,\"395\":1}}],[\"通常只需要一次检索就可以了\",{\"1\":{\"121\":1}}],[\"通常情况下不会使用\",{\"1\":{\"355\":1}}],[\"通常情况下使用数组来表述线性表的顺序存储结构\",{\"1\":{\"36\":1}}],[\"通常会被配置成自动驱逐缓存中元素\",{\"1\":{\"281\":1}}],[\"通常会给定查询条件\",{\"1\":{\"125\":1}}],[\"通常是dba\",{\"1\":{\"195\":1}}],[\"通常使用较少\",{\"1\":{\"115\":1}}],[\"通常头指针来标示一个单链表\",{\"1\":{\"37\":1}}],[\"通常作为一个整体进行考虑和处理\",{\"1\":{\"32\":1}}],[\"单行字符串\",{\"1\":{\"421\":1,\"422\":1}}],[\"单行注释\",{\"1\":{\"173\":1}}],[\"单个\",{\"1\":{\"399\":1}}],[\"单线程网络模型的整个过程\",{\"1\":{\"460\":1}}],[\"单线程网络模型\",{\"0\":{\"460\":1}}],[\"单线程\",{\"1\":{\"365\":1}}],[\"单点能存储的数据量难以满足海量数据需求\",{\"1\":{\"318\":1}}],[\"单点redis的问题\",{\"1\":{\"318\":1}}],[\"单节点上的内存占用不要太大\",{\"1\":{\"301\":1}}],[\"单节点\",{\"1\":{\"293\":1,\"318\":1}}],[\"单体系统\",{\"1\":{\"275\":1}}],[\"单位是毫秒\",{\"1\":{\"307\":1}}],[\"单位\",{\"1\":{\"227\":1,\"347\":1}}],[\"单独作为一个章节\",{\"1\":{\"179\":1}}],[\"单列\",{\"0\":{\"133\":1}}],[\"单列索引\",{\"1\":{\"127\":1,\"133\":1}}],[\"单链表上基本操作的实现\",{\"1\":{\"37\":1}}],[\"单链表元素离散的分布在存储空间中\",{\"1\":{\"37\":1}}],[\"单链表的特点\",{\"1\":{\"37\":1}}],[\"单链表中节点类型的描述\",{\"1\":{\"37\":1}}],[\"单链表\",{\"0\":{\"37\":1},\"1\":{\"37\":1}}],[\"单层循环相对来讲是比较简单的\",{\"1\":{\"21\":1}}],[\"单层循环\",{\"0\":{\"21\":1},\"1\":{\"20\":1}}],[\">reply\",{\"1\":{\"462\":1}}],[\">buf写不下\",{\"1\":{\"462\":1}}],[\">beforesleep\",{\"1\":{\"462\":1}}],[\">proc\",{\"1\":{\"462\":1}}],[\">ptr\",{\"1\":{\"462\":5}}],[\">lastcmd\",{\"1\":{\"462\":1}}],[\">length\",{\"1\":{\"432\":12}}],[\">cmd\",{\"1\":{\"462\":2}}],[\">conn\",{\"1\":{\"462\":1}}],[\">argv\",{\"1\":{\"462\":3}}],[\">guerybuf+qblen\",{\"1\":{\"462\":1}}],[\">querybuf\",{\"1\":{\"462\":2}}],[\">querybuf缓冲区大小\",{\"1\":{\"462\":1}}],[\">stop\",{\"1\":{\"462\":2}}],[\">ht\",{\"1\":{\"435\":1}}],[\">hashfunction\",{\"1\":{\"435\":1}}],[\">type\",{\"1\":{\"435\":1}}],[\">>\",{\"1\":{\"432\":1}}],[\">encoding\",{\"1\":{\"432\":3}}],[\">data\",{\"1\":{\"37\":1}}],[\">next\",{\"1\":{\"37\":4}}],[\">\",{\"1\":{\"36\":1,\"86\":1,\"99\":1,\"121\":1,\"129\":3,\"139\":1,\"140\":1,\"187\":1,\"190\":2,\"205\":2,\"254\":1,\"282\":1,\"291\":2,\"334\":1,\"351\":2,\"353\":1,\"360\":2,\"394\":1,\"432\":3,\"437\":1,\"481\":2,\"482\":5,\"496\":1,\"509\":6,\"543\":1}}],[\">=\",{\"1\":{\"24\":1,\"36\":4,\"99\":1,\"187\":1,\"432\":1,\"437\":1,\"482\":1,\"491\":1,\"494\":1,\"517\":16,\"543\":2}}],[\"用这种消耗去换取内存空间\",{\"1\":{\"469\":1}}],[\"用当前时间减去最后一次访问时间\",{\"1\":{\"456\":1}}],[\"用以节省内存\",{\"1\":{\"417\":1}}],[\"用最少的命令达到相同效果\",{\"1\":{\"320\":1}}],[\"用新的\",{\"1\":{\"319\":1}}],[\"用标准的\",{\"1\":{\"286\":1}}],[\"用法\",{\"1\":{\"246\":1}}],[\"用户使用网络就像使用一台单一的超级计算机\",{\"1\":{\"567\":1}}],[\"用户透明性观点\",{\"0\":{\"567\":1}}],[\"用户进程调用完异步\",{\"1\":{\"412\":1}}],[\"用户进程无需遍历所有\",{\"1\":{\"410\":1}}],[\"用户进程判断\",{\"1\":{\"406\":1}}],[\"用户进程在两个阶段都是非阻塞的状态\",{\"1\":{\"412\":1}}],[\"用户进程在两个阶段都是阻塞状态\",{\"1\":{\"402\":1}}],[\"用户进程在第一个阶段是非阻塞的\",{\"1\":{\"403\":1}}],[\"用户应用在一阶段都是需要调用\",{\"1\":{\"404\":1}}],[\"用户应用与内核是分离的\",{\"1\":{\"401\":1}}],[\"用户线程才解除阻塞状态\",{\"1\":{\"402\":1}}],[\"用户线程处于阻塞状态\",{\"1\":{\"402\":1}}],[\"用户线程发出\",{\"1\":{\"402\":1}}],[\"用户空间中执行\",{\"1\":{\"405\":1}}],[\"用户空间中创建\",{\"1\":{\"405\":1}}],[\"用户空间内只能执行受限的指令\",{\"1\":{\"401\":1}}],[\"用户空间\",{\"1\":{\"401\":1}}],[\"用户空间与内核空间\",{\"0\":{\"401\":1}}],[\"用户定义的变量无需对其进行声明或者初始化\",{\"1\":{\"243\":1}}],[\"用户变量不用提前声明\",{\"1\":{\"243\":1}}],[\"用户自定义变量是用户根据需要自己定义的变量\",{\"1\":{\"243\":1}}],[\"用户自定义变量\",{\"0\":{\"243\":1}}],[\"用户名\",{\"1\":{\"195\":3,\"196\":3}}],[\"用户控制\",{\"0\":{\"195\":1}}],[\"用户\",{\"1\":{\"194\":1}}],[\"用户数据报协议是同一层内另一个重要的传输协议\",{\"1\":{\"14\":1}}],[\"用or分割开的条件\",{\"1\":{\"129\":1}}],[\"用来进行通信和资源共享\",{\"1\":{\"570\":1}}],[\"用来rehash\",{\"1\":{\"439\":1}}],[\"用来存储元素\",{\"1\":{\"418\":1}}],[\"用来关联\",{\"1\":{\"404\":1}}],[\"用来获取不同类型的请求参数\",{\"1\":{\"311\":1}}],[\"用来迭代数组\",{\"1\":{\"289\":1}}],[\"用来创建一个空表\",{\"1\":{\"288\":1}}],[\"用来创建数据库用户\",{\"1\":{\"174\":1}}],[\"用来管理数据库\",{\"1\":{\"194\":1}}],[\"用来对数据库中的数据进行查询操作\",{\"1\":{\"174\":1}}],[\"用来对数据库表中的数据进行增删改\",{\"1\":{\"174\":1}}],[\"用来定义数据库对象\",{\"1\":{\"174\":1}}],[\"用来保存要写入到磁盘中的log日志数据\",{\"1\":{\"63\":1}}],[\"用来让两张表的数据之间建立连接\",{\"1\":{\"47\":1}}],[\"用于记录对象引用数量\",{\"1\":{\"470\":1}}],[\"用于记录数据被修改前的信息\",{\"1\":{\"76\":1}}],[\"用于对键处理的命令占据一大部分\",{\"1\":{\"464\":1}}],[\"用于\",{\"1\":{\"446\":1}}],[\"用于接收就绪的\",{\"1\":{\"407\":1}}],[\"用于监听多个fd的集合\",{\"1\":{\"405\":1}}],[\"用于方便地搭建能够处理超高并发\",{\"1\":{\"304\":1}}],[\"用于配合undo\",{\"1\":{\"82\":1}}],[\"用于在刷新脏页到磁盘\",{\"1\":{\"75\":1}}],[\"用于在刷新脏页到磁盘时\",{\"1\":{\"72\":1}}],[\"用于存储undo\",{\"1\":{\"69\":1}}],[\"用于存储记录\",{\"1\":{\"58\":1}}],[\"用于优化对buffer\",{\"1\":{\"64\":1}}],[\"用于限制存储在表中的数据\",{\"1\":{\"45\":1}}],[\"用字符串pad对str的右边进行填充\",{\"1\":{\"53\":1}}],[\"用字符串pad对str的左边进行填充\",{\"1\":{\"53\":1}}],[\"用引用变量\",{\"1\":{\"36\":1}}],[\"中仅存的\",{\"1\":{\"541\":1}}],[\"中没有元素\",{\"1\":{\"541\":1}}],[\"中有\",{\"1\":{\"470\":1}}],[\"中根据存储的数据类型不同\",{\"1\":{\"467\":1}}],[\"中会根据存储的数据类型不同\",{\"1\":{\"466\":1}}],[\"中四种实现方式\",{\"1\":{\"459\":1}}],[\"中尝试做内存淘汰\",{\"1\":{\"456\":1}}],[\"中抽样的索引位置\",{\"1\":{\"454\":1}}],[\"中间节点可以压缩\",{\"1\":{\"449\":1}}],[\"中间节点压缩\",{\"1\":{\"448\":2}}],[\"中间某条指令的失败不会导致前面已做指令的回滚\",{\"1\":{\"399\":1}}],[\"中每个\",{\"1\":{\"441\":1}}],[\"中解决哈希冲的方法是\",{\"1\":{\"435\":1}}],[\"中所有的整数按照升序依次保存在\",{\"1\":{\"430\":1}}],[\"中并没有直接使用\",{\"1\":{\"425\":1}}],[\"中保存的\",{\"1\":{\"425\":1}}],[\"中文字符\",{\"1\":{\"421\":1}}],[\"中采用的是\",{\"1\":{\"421\":1}}],[\"中相邻的两个\",{\"1\":{\"417\":1}}],[\"中最常见的一种数据结构\",{\"1\":{\"425\":1}}],[\"中最常见的数据存储类型\",{\"1\":{\"415\":1}}],[\"中最早的\",{\"1\":{\"405\":1}}],[\"中监听\",{\"1\":{\"410\":1}}],[\"中一切皆文件\",{\"1\":{\"404\":1}}],[\"中⼼点是由给定的位置元素决定\",{\"1\":{\"396\":1}}],[\"中使用\",{\"0\":{\"360\":1}}],[\"中提供了\",{\"1\":{\"359\":1}}],[\"中操作数据的模块\",{\"1\":{\"358\":1}}],[\"中不包含\",{\"1\":{\"343\":1}}],[\"中至少包含\",{\"1\":{\"343\":1}}],[\"中包含数百万的\",{\"1\":{\"438\":1}}],[\"中包含\",{\"1\":{\"343\":1}}],[\"中选择一个作为新的\",{\"1\":{\"326\":1}}],[\"中能找到\",{\"1\":{\"302\":1}}],[\"中从\",{\"1\":{\"302\":1}}],[\"中的所有整数\",{\"1\":{\"514\":1}}],[\"中的命令\",{\"1\":{\"462\":1}}],[\"中的命令发送给\",{\"1\":{\"300\":1}}],[\"中的每一个\",{\"1\":{\"448\":1}}],[\"中的每一个dictentry都rehash到dict\",{\"1\":{\"438\":1}}],[\"中的entry\",{\"1\":{\"441\":1}}],[\"中的元素\",{\"1\":{\"541\":1}}],[\"中的元素数目\",{\"1\":{\"541\":1}}],[\"中的元素数量超过了\",{\"1\":{\"417\":1}}],[\"中的元素按照升序进行排列存储\",{\"1\":{\"451\":1}}],[\"中的元素唯一\",{\"1\":{\"433\":1}}],[\"中的实现在\",{\"1\":{\"426\":1}}],[\"中的集合\",{\"1\":{\"418\":1}}],[\"中的单列集合\",{\"1\":{\"418\":1}}],[\"中的任意数据类型的键和值都会被封装为一个\",{\"1\":{\"465\":1}}],[\"中的任意\",{\"1\":{\"417\":1}}],[\"中的事件类型\",{\"1\":{\"406\":1}}],[\"中的一个文件\",{\"1\":{\"404\":1}}],[\"中的指定元素的排名\",{\"1\":{\"380\":1}}],[\"中的部分是有效部分\",{\"1\":{\"343\":1}}],[\"中的\",{\"1\":{\"302\":1,\"417\":1,\"418\":1,\"437\":1,\"442\":1,\"484\":1}}],[\"中的表\",{\"1\":{\"288\":1}}],[\"中的数据增多而逐渐增大\",{\"1\":{\"300\":1}}],[\"中的数据类型有个简单的了解\",{\"1\":{\"288\":1}}],[\"中的数据\",{\"1\":{\"73\":1}}],[\"中配置\",{\"1\":{\"242\":1,\"301\":1,\"320\":1}}],[\"中配置如下信息\",{\"1\":{\"227\":1}}],[\"中等\",{\"1\":{\"236\":1}}],[\"中等难度\",{\"0\":{\"23\":1}}],[\"中创建名为index\",{\"1\":{\"127\":1}}],[\"中是可以访问该版本的\",{\"1\":{\"86\":1}}],[\"中记录下每一次操作的原数据\",{\"1\":{\"84\":1}}],[\"中\",{\"1\":{\"62\":2,\"310\":1,\"421\":1,\"430\":1,\"443\":1,\"448\":1,\"464\":1,\"541\":3}}],[\"中查找值与\",{\"1\":{\"432\":1}}],[\"中查找位序为\",{\"1\":{\"36\":1}}],[\"中查找第一个元素值等于\",{\"1\":{\"36\":1}}],[\"中第\",{\"1\":{\"36\":1}}],[\"pwd=45nc\",{\"1\":{\"546\":1}}],[\"pwd=nrtj\",{\"1\":{\"171\":1}}],[\"plain==1\",{\"1\":{\"447\":1}}],[\"plan\",{\"1\":{\"344\":1}}],[\"pfmerge\",{\"1\":{\"398\":1}}],[\"pfcount\",{\"1\":{\"398\":1}}],[\"pfadd\",{\"1\":{\"398\":1}}],[\"pending\",{\"1\":{\"385\":2,\"462\":2}}],[\"percentage\",{\"1\":{\"320\":1}}],[\"per\",{\"1\":{\"234\":2}}],[\"performance\",{\"1\":{\"144\":1,\"145\":1,\"349\":1}}],[\"psubscribe\",{\"1\":{\"381\":1}}],[\"ps\",{\"1\":{\"340\":2}}],[\"ping\",{\"1\":{\"325\":1,\"328\":1,\"337\":1,\"372\":1}}],[\"pi​\",{\"1\":{\"36\":3}}],[\"pcre\",{\"1\":{\"305\":1}}],[\"python等\",{\"1\":{\"365\":1}}],[\"python\",{\"1\":{\"288\":1}}],[\"punsubscribe\",{\"1\":{\"381\":1}}],[\"pubsub\",{\"1\":{\"381\":1,\"421\":1}}],[\"publish\",{\"1\":{\"381\":2}}],[\"public\",{\"1\":{\"334\":6,\"347\":2,\"351\":1,\"353\":2,\"354\":1,\"360\":1,\"422\":1,\"482\":1,\"488\":1,\"494\":1,\"500\":1,\"503\":1,\"506\":1,\"512\":1,\"517\":3,\"523\":1,\"526\":1,\"529\":1,\"536\":1,\"538\":1,\"543\":3}}],[\"pub\",{\"1\":{\"381\":2,\"385\":2}}],[\"put\",{\"1\":{\"282\":1}}],[\"purge\",{\"1\":{\"73\":1}}],[\"pdai\",{\"1\":{\"266\":1}}],[\"pdf下载\",{\"1\":{\"171\":1}}],[\"p\",{\"1\":{\"202\":1,\"296\":1,\"297\":3,\"340\":1,\"341\":1,\"342\":2,\"372\":1,\"456\":1}}],[\"p1234\",{\"1\":{\"139\":1,\"140\":1}}],[\"ptr\",{\"1\":{\"82\":2,\"415\":1,\"456\":1,\"465\":1}}],[\"problems\",{\"1\":{\"542\":1}}],[\"protocol\",{\"1\":{\"421\":1}}],[\"protected\",{\"1\":{\"339\":1}}],[\"product\",{\"1\":{\"376\":2}}],[\"product相关的key\",{\"1\":{\"376\":1}}],[\"prohects\",{\"1\":{\"358\":1}}],[\"proposed\",{\"1\":{\"344\":1}}],[\"prority\",{\"1\":{\"326\":1}}],[\"processinputbuffer\",{\"1\":{\"462\":1}}],[\"processcommand\",{\"1\":{\"456\":1,\"462\":3}}],[\"processes\",{\"1\":{\"306\":1}}],[\"proceed\",{\"1\":{\"344\":1}}],[\"procedure\",{\"1\":{\"240\":3,\"246\":1}}],[\"profiling\",{\"1\":{\"228\":1}}],[\"profiling参数\",{\"1\":{\"228\":1}}],[\"profiles\",{\"1\":{\"228\":1}}],[\"profiles分析能够在做sql优化时帮助我们了解时间都耗费到哪去了\",{\"1\":{\"228\":1}}],[\"profile\",{\"1\":{\"228\":3,\"305\":2}}],[\"profile分析\",{\"0\":{\"228\":1}}],[\"profession\",{\"1\":{\"130\":3}}],[\"pro\",{\"1\":{\"130\":3}}],[\"prevent\",{\"1\":{\"447\":1}}],[\"prev\",{\"1\":{\"447\":1}}],[\"previous\",{\"1\":{\"443\":1,\"447\":1}}],[\"prelen\",{\"1\":{\"441\":1}}],[\"present\",{\"1\":{\"432\":1}}],[\"prepend\",{\"1\":{\"432\":3}}],[\"prefix\",{\"1\":{\"422\":2}}],[\"preferred\",{\"1\":{\"334\":2}}],[\"pre\",{\"0\":{\"67\":1},\"1\":{\"67\":1}}],[\"price\",{\"1\":{\"376\":1}}],[\"privdata\",{\"1\":{\"436\":1}}],[\"privatetmp=true\",{\"1\":{\"370\":1}}],[\"private\",{\"1\":{\"334\":1,\"347\":1,\"351\":1,\"360\":2,\"422\":3}}],[\"privileges\",{\"1\":{\"196\":1}}],[\"priority值\",{\"1\":{\"326\":1}}],[\"printstacktrace\",{\"1\":{\"422\":2}}],[\"printwriter\",{\"1\":{\"422\":2}}],[\"printf\",{\"1\":{\"295\":1,\"296\":1,\"339\":1,\"340\":2}}],[\"print\",{\"1\":{\"287\":1,\"289\":1,\"291\":1,\"340\":1}}],[\"println\",{\"1\":{\"282\":2,\"351\":2,\"354\":1,\"360\":1,\"422\":7}}],[\"printlist\",{\"1\":{\"35\":1}}],[\"primery\",{\"0\":{\"203\":1}}],[\"primary\",{\"1\":{\"47\":1,\"124\":1,\"229\":1,\"232\":1}}],[\"pauserehash\",{\"1\":{\"436\":1}}],[\"packed==2\",{\"1\":{\"447\":1}}],[\"packed\",{\"1\":{\"426\":5}}],[\"package\",{\"1\":{\"305\":1,\"307\":2,\"309\":2}}],[\"parseint\",{\"1\":{\"422\":2}}],[\"parselong\",{\"1\":{\"422\":1}}],[\"params\",{\"1\":{\"291\":2,\"307\":2}}],[\"pattern\",{\"1\":{\"275\":3,\"381\":4}}],[\"pathvariable\",{\"1\":{\"334\":3}}],[\"path=$\",{\"1\":{\"305\":1}}],[\"path\",{\"1\":{\"66\":1,\"202\":2,\"307\":5,\"309\":1}}],[\"pan\",{\"1\":{\"171\":1,\"546\":1,\"557\":1}}],[\"password\",{\"1\":{\"157\":2,\"158\":2,\"159\":2,\"195\":1,\"360\":1}}],[\"page2\",{\"1\":{\"205\":1}}],[\"page1\",{\"1\":{\"205\":1}}],[\"page3\",{\"1\":{\"205\":2}}],[\"page\",{\"1\":{\"61\":3,\"73\":1,\"204\":1,\"306\":1}}],[\"pad\",{\"1\":{\"53\":2}}],[\"pong是\",{\"1\":{\"462\":1}}],[\"pong\",{\"1\":{\"462\":3}}],[\"points\",{\"1\":{\"447\":1}}],[\"pointer\",{\"1\":{\"58\":1}}],[\"poli\",{\"1\":{\"407\":1}}],[\"poll函数\",{\"1\":{\"406\":1}}],[\"pollnval\",{\"1\":{\"406\":1}}],[\"pollerr\",{\"1\":{\"406\":1}}],[\"pollout\",{\"1\":{\"406\":1}}],[\"pollin\",{\"1\":{\"406\":1}}],[\"pollfd数组\",{\"1\":{\"406\":1}}],[\"pollfd结构\",{\"1\":{\"406\":1}}],[\"pollfd\",{\"1\":{\"406\":8}}],[\"poll\",{\"0\":{\"406\":1},\"1\":{\"73\":1,\"404\":2,\"406\":3,\"407\":1,\"410\":2,\"459\":1,\"462\":1}}],[\"pom\",{\"1\":{\"334\":1}}],[\"position\",{\"1\":{\"432\":4}}],[\"pos+1\",{\"1\":{\"432\":1}}],[\"pos\",{\"1\":{\"432\":21}}],[\"post表单参数\",{\"1\":{\"311\":2}}],[\"postgresql\",{\"1\":{\"304\":1}}],[\"possible\",{\"1\":{\"229\":1}}],[\"port\",{\"1\":{\"294\":1,\"307\":2,\"330\":1,\"331\":2,\"338\":1,\"339\":1,\"360\":1,\"422\":2,\"462\":1}}],[\"pool2<\",{\"1\":{\"360\":1}}],[\"pool刷新到磁盘前\",{\"1\":{\"71\":1}}],[\"pool中\",{\"1\":{\"62\":1}}],[\"pool\",{\"0\":{\"61\":1},\"1\":{\"62\":1,\"64\":1,\"307\":4,\"360\":1}}],[\"假如我们要给\",{\"1\":{\"427\":1}}],[\"假如要监听\",{\"1\":{\"405\":1}}],[\"假如是两次握手时\",{\"1\":{\"16\":1}}],[\"假设你正在爬楼梯\",{\"1\":{\"519\":1}}],[\"假设你是一位很棒的家长\",{\"1\":{\"491\":1}}],[\"假设一个客户端\",{\"1\":{\"408\":1}}],[\"假设\",{\"1\":{\"36\":3,\"126\":1}}],[\"最终\",{\"1\":{\"541\":1}}],[\"最终都会被转发到正确节点\",{\"1\":{\"337\":1}}],[\"最少频率使用\",{\"1\":{\"456\":1}}],[\"最少最近使用\",{\"1\":{\"456\":1}}],[\"最多支持\",{\"1\":{\"451\":1}}],[\"最多丢失1秒数据\",{\"1\":{\"320\":1}}],[\"最佳的上限该怎么办\",{\"1\":{\"444\":1}}],[\"最简单的构造表达式是\",{\"1\":{\"288\":1}}],[\"最根本的区别是\",{\"1\":{\"281\":1}}],[\"最大\",{\"1\":{\"484\":1}}],[\"最大支持\",{\"1\":{\"421\":1}}],[\"最大不超过\",{\"1\":{\"410\":1}}],[\"最大的连接数\",{\"1\":{\"360\":1}}],[\"最大空闲连接\",{\"1\":{\"347\":1,\"360\":1}}],[\"最大连接\",{\"1\":{\"347\":1}}],[\"最大缓存设置多少\",{\"1\":{\"273\":1}}],[\"最大值\",{\"1\":{\"189\":1}}],[\"最后编写一个释放资源的方法\",{\"1\":{\"351\":1}}],[\"最后是确定下线\",{\"1\":{\"345\":1}}],[\"最后是判断\",{\"1\":{\"326\":1}}],[\"最后\",{\"1\":{\"327\":1}}],[\"最后返回累计值\",{\"1\":{\"221\":1}}],[\"最后以分号结尾\",{\"1\":{\"177\":1}}],[\"最小等于\",{\"1\":{\"534\":1}}],[\"最小空闲连接\",{\"1\":{\"347\":1,\"360\":1}}],[\"最小值\",{\"1\":{\"189\":1}}],[\"最小活跃事务id\",{\"1\":{\"85\":1}}],[\"最左前缀法则指的是查询从索引的最左列开始\",{\"1\":{\"129\":1}}],[\"最左前缀法则\",{\"1\":{\"129\":1}}],[\"最常见的解释就是nosql\",{\"1\":{\"109\":1}}],[\"最近修改事务的id\",{\"1\":{\"82\":1}}],[\"最坏和平均复杂度都是\",{\"1\":{\"36\":1}}],[\"最坏情况\",{\"1\":{\"36\":3}}],[\"最好情况\",{\"1\":{\"36\":3}}],[\"判断其8个点位中合法点位的值\",{\"1\":{\"516\":1}}],[\"判断三者之和是否为0\",{\"1\":{\"482\":1}}],[\"判断sum\",{\"1\":{\"481\":1}}],[\"判断是否能满足目前尚未满足的胃口最小的孩子\",{\"1\":{\"492\":1}}],[\"判断是否存在三元组\",{\"1\":{\"477\":1}}],[\"判断是否就绪\",{\"1\":{\"406\":1}}],[\"判断元素是大于\",{\"1\":{\"432\":1}}],[\"判断编码是不是超过了当前\",{\"1\":{\"432\":1}}],[\"判断数据类型标示\",{\"1\":{\"422\":1}}],[\"判断一个元素是否存在于set中\",{\"1\":{\"379\":1}}],[\"判断key是否存在\",{\"1\":{\"361\":1}}],[\"判断相等的运算符是\",{\"1\":{\"243\":1}}],[\"判断条件不同\",{\"1\":{\"190\":1}}],[\"判断\",{\"1\":{\"36\":2}}],[\"判空操作\",{\"1\":{\"35\":1}}],[\"返回false\",{\"1\":{\"516\":1}}],[\"返回生成数组\",{\"1\":{\"484\":1}}],[\"返回数据结构的操作结果作为命令的返回值\",{\"1\":{\"468\":1}}],[\"返回类型错误\",{\"1\":{\"468\":1}}],[\"返回响应结果给客户端\",{\"1\":{\"421\":1}}],[\"返回对应的句柄epfd\",{\"1\":{\"407\":1}}],[\"返回就绪\",{\"1\":{\"406\":1}}],[\"返回输⼊的各个元素\",{\"1\":{\"398\":1}}],[\"返回两个给定位置之间的距离\",{\"1\":{\"396\":1}}],[\"返回⼀个或多个位置元素的\",{\"1\":{\"396\":1}}],[\"返回⼀个或多个位置对象的\",{\"1\":{\"396\":1}}],[\"返回set中元素的个数\",{\"1\":{\"379\":1}}],[\"返回一段角标范围内的所有元素\",{\"1\":{\"378\":1}}],[\"返回一个日期\",{\"1\":{\"55\":1}}],[\"返回值类型\",{\"1\":{\"359\":1}}],[\"返回的结果是无\",{\"1\":{\"352\":1}}],[\"返回假数据\",{\"1\":{\"310\":1}}],[\"返回404\",{\"1\":{\"307\":1}}],[\"返回给服务层\",{\"1\":{\"221\":3}}],[\"返回res2\",{\"1\":{\"56\":1}}],[\"返回res1\",{\"1\":{\"56\":1}}],[\"返回起始时间date1和结束时间\",{\"1\":{\"55\":1}}],[\"返回当前时间\",{\"1\":{\"55\":1}}],[\"返回当前日期和时间\",{\"1\":{\"55\":1}}],[\"返回当前日期\",{\"1\":{\"55\":1}}],[\"返回0～1之间的随机数\",{\"1\":{\"54\":1}}],[\"返回字符串str从start位置开始的len个长度的字符串\",{\"1\":{\"53\":1}}],[\"返回其位序\",{\"1\":{\"36\":1}}],[\"返回\",{\"1\":{\"36\":2,\"217\":1,\"514\":1}}],[\"返回线性表l的长度\",{\"1\":{\"35\":1}}],[\"插入新的哈希表\",{\"1\":{\"438\":1}}],[\"插入新元素\",{\"1\":{\"432\":2}}],[\"插入队尾\",{\"1\":{\"432\":1}}],[\"插入队首\",{\"1\":{\"432\":1}}],[\"插入元素\",{\"1\":{\"432\":1}}],[\"插入和删除快\",{\"1\":{\"378\":1}}],[\"插入一条\",{\"1\":{\"354\":1,\"360\":1}}],[\"插入了一个\",{\"1\":{\"352\":1}}],[\"插入到page3的末尾\",{\"1\":{\"205\":1}}],[\"插入数据时\",{\"1\":{\"207\":1}}],[\"插入数据时指定的字段顺序需要于值的顺序是一一对应的\",{\"1\":{\"180\":1}}],[\"插入数据权限\",{\"1\":{\"196\":1}}],[\"插入的数据大小\",{\"1\":{\"180\":1}}],[\"插入\",{\"1\":{\"164\":1,\"226\":1}}],[\"插入触发器\",{\"0\":{\"157\":1}}],[\"插入或者删除许多行的事务\",{\"1\":{\"63\":1}}],[\"插入结点操作\",{\"1\":{\"37\":1}}],[\"插入成功\",{\"1\":{\"36\":1}}],[\"插入操作\",{\"1\":{\"35\":1,\"36\":1}}],[\"腾出一个空位置插入新元素\",{\"1\":{\"36\":1}}],[\"否则会回到步骤二\",{\"1\":{\"516\":1}}],[\"否则会从行锁升级为表锁\",{\"1\":{\"223\":1}}],[\"否则结束\",{\"1\":{\"455\":2}}],[\"否则不执行\",{\"1\":{\"376\":1,\"377\":1}}],[\"否则不加\",{\"1\":{\"221\":1}}],[\"否则\",{\"1\":{\"249\":1}}],[\"否则为using\",{\"1\":{\"210\":1}}],[\"否则返回\",{\"1\":{\"514\":1}}],[\"否则返回0\",{\"1\":{\"398\":1}}],[\"否则返回defult\",{\"1\":{\"56\":2}}],[\"否则返回value2\",{\"1\":{\"56\":1}}],[\"否则返回f\",{\"1\":{\"56\":1}}],[\"否则返回false\",{\"1\":{\"35\":1}}],[\"否则将第\",{\"1\":{\"36\":1}}],[\"个人区域网\",{\"1\":{\"557\":1}}],[\"个人理解\",{\"1\":{\"239\":1}}],[\"个阶梯所的最小花费\",{\"1\":{\"536\":1,\"538\":1}}],[\"个台阶向上爬需要支付的费用\",{\"1\":{\"532\":1}}],[\"个台阶\",{\"1\":{\"519\":1}}],[\"个单元格\",{\"1\":{\"514\":1}}],[\"个斐波那契数\",{\"1\":{\"503\":1,\"506\":1}}],[\"个比特位\",{\"1\":{\"465\":1}}],[\"个节点不压缩\",{\"1\":{\"448\":2}}],[\"个字节来保存这个长度\",{\"1\":{\"443\":1}}],[\"个字节\",{\"1\":{\"441\":1,\"442\":1,\"465\":1}}],[\"个字符\",{\"1\":{\"343\":1}}],[\"个数的最大值\",{\"1\":{\"448\":1}}],[\"个数\",{\"1\":{\"436\":1}}],[\"个数据\",{\"1\":{\"126\":2}}],[\"个不同元素的基\",{\"1\":{\"398\":1}}],[\"个插槽分配到不同的实例\",{\"1\":{\"343\":1}}],[\"个插槽\",{\"1\":{\"343\":1,\"344\":1}}],[\"个\",{\"1\":{\"319\":3,\"410\":1,\"465\":1}}],[\"个值\",{\"1\":{\"93\":1,\"529\":2}}],[\"个undo\",{\"1\":{\"76\":1}}],[\"个位置结点的概率\",{\"1\":{\"36\":1}}],[\"个位置后的元素前移\",{\"1\":{\"36\":1}}],[\"个位置的元素\",{\"1\":{\"36\":1}}],[\"个位置上插入的一个结点的概率\",{\"1\":{\"36\":2}}],[\"个位置插入新元素\",{\"1\":{\"36\":1}}],[\"个元素为\",{\"1\":{\"541\":1}}],[\"个元素表示应合并的元素\",{\"1\":{\"541\":1}}],[\"个元素的值\",{\"1\":{\"36\":1}}],[\"个元素的存储位置后面紧接着存储的是第\",{\"1\":{\"36\":1}}],[\"个元素及之后的元素后移\",{\"1\":{\"36\":1}}],[\"个元素及其后的所有元素依次往后移动一个位置\",{\"1\":{\"36\":1}}],[\"个元素\",{\"1\":{\"36\":1}}],[\"说明对象的个性较大\",{\"1\":{\"469\":1}}],[\"说明是替换原来的视图\",{\"1\":{\"163\":1}}],[\"说明\",{\"1\":{\"36\":1,\"50\":1,\"144\":1,\"177\":2,\"179\":1,\"196\":1,\"256\":1,\"274\":1,\"300\":1,\"359\":1,\"375\":1,\"395\":1,\"466\":1,\"467\":1}}],[\"每种数据类型使用的编码方式如下\",{\"1\":{\"467\":1}}],[\"每部分占用的字节大小为\",{\"1\":{\"430\":1}}],[\"每一次插入数据时都会判断数据是否为整数\",{\"1\":{\"418\":1}}],[\"每一个\",{\"1\":{\"300\":1}}],[\"每隔\",{\"1\":{\"325\":1,\"328\":1}}],[\"每秒刷盘\",{\"1\":{\"320\":1}}],[\"每秒将日志写入并刷新到磁盘一次\",{\"1\":{\"63\":1}}],[\"每页显示的记录数\",{\"1\":{\"192\":1}}],[\"每次你可以爬\",{\"1\":{\"519\":1}}],[\"每次访问dict时执行一次rehash\",{\"1\":{\"439\":1}}],[\"每次执行新增\",{\"1\":{\"438\":1}}],[\"每次收缩是根据已使用空间缩小一倍创建一个新的哈希表\",{\"1\":{\"437\":1}}],[\"每次删除元素时\",{\"1\":{\"437\":1}}],[\"每次都要遍历所有\",{\"1\":{\"410\":1}}],[\"每次\",{\"1\":{\"410\":1}}],[\"每次遍历消耗的时间也越久\",{\"1\":{\"406\":1}}],[\"每次操作锁住对应的行数据\",{\"1\":{\"146\":1}}],[\"每次操作锁住整张表\",{\"1\":{\"142\":1}}],[\"每次select\",{\"1\":{\"81\":1}}],[\"每次对某条引记录进行改动时\",{\"1\":{\"58\":1}}],[\"每次对某条记录产生改动时\",{\"1\":{\"58\":1}}],[\"每次递归时\",{\"1\":{\"30\":2}}],[\"每个孩子最多只能给一块饼干\",{\"1\":{\"491\":1}}],[\"每个执行周期100ms\",{\"1\":{\"455\":1}}],[\"每个节点都可以包含多层指针\",{\"1\":{\"453\":1}}],[\"每个节点都包含\",{\"1\":{\"453\":1}}],[\"每个元素都小于\",{\"1\":{\"419\":1}}],[\"每个bit位代表一个fd\",{\"1\":{\"405\":1}}],[\"每个消费组会有个游标\",{\"1\":{\"385\":1}}],[\"每个消息都有一个唯一的\",{\"1\":{\"385\":1}}],[\"每个命令具备原子性\",{\"1\":{\"365\":1}}],[\"每个master包含一个slave节点\",{\"1\":{\"338\":1}}],[\"每个\",{\"1\":{\"337\":2,\"385\":1,\"398\":1,\"410\":1,\"448\":5}}],[\"每个目录都要改\",{\"1\":{\"295\":1}}],[\"每个值以逗号隔开\",{\"1\":{\"291\":1}}],[\"每个页包含了\",{\"1\":{\"205\":1}}],[\"每个页的大小默认为16kb\",{\"1\":{\"58\":1}}],[\"每个page页占据16k\",{\"1\":{\"204\":1}}],[\"每个extent区占据1m\",{\"1\":{\"204\":1}}],[\"每个表的文件表空间包含单个innodb表的数据和索引\",{\"1\":{\"67\":1}}],[\"每个区的大小为1m\",{\"1\":{\"58\":1}}],[\"每个结点插入的时间为\",{\"1\":{\"37\":1}}],[\"每个结点只存储数据元素\",{\"1\":{\"36\":1}}],[\"称为内存预分配\",{\"1\":{\"427\":1}}],[\"称为简单动态字符串\",{\"1\":{\"425\":1}}],[\"称之为自适应哈希索引\",{\"1\":{\"64\":1}}],[\"称\",{\"1\":{\"36\":1}}],[\"所需要支付的最小体力花费\",{\"1\":{\"534\":1}}],[\"所需要移动结点的平均次数为\",{\"1\":{\"36\":2}}],[\"所存储的\",{\"1\":{\"352\":1}}],[\"所设置的全局参数会失效\",{\"1\":{\"242\":1}}],[\"所有网格我们分成了3个类型\",{\"1\":{\"511\":1}}],[\"所有键值对都迁徙完毕后\",{\"1\":{\"437\":1}}],[\"所有其它客户端\",{\"1\":{\"404\":1}}],[\"所有没有被sqlwarning或者not\",{\"1\":{\"253\":1}}],[\"所有以02开头的sqlstate代码的简写\",{\"1\":{\"253\":1}}],[\"所有以01开头的sqlstate代码的简写\",{\"1\":{\"253\":1}}],[\"所有存储引擎的功能也在这一层实现\",{\"1\":{\"231\":1}}],[\"所有不是通过索引直接返回排序结果的排序都叫做filesort排序\",{\"1\":{\"209\":1}}],[\"所有权限\",{\"1\":{\"196\":1}}],[\"所有字段\",{\"1\":{\"186\":1}}],[\"所有的排名默认都是升序\",{\"1\":{\"380\":1}}],[\"所有的用户信息和用户权限信息都存储于mysql数据库内的表中\",{\"1\":{\"195\":1}}],[\"所有的刨根问底都造成了真实伤害\",{\"1\":{\"2\":1}}],[\"所有的技术和知识点笔记都是基于官方文档展开编写的\",{\"1\":{\"2\":1}}],[\"所以到第三层楼梯的状态可以由第⼆层楼梯\",{\"1\":{\"521\":1}}],[\"所以你应该输出2\",{\"1\":{\"491\":1}}],[\"所以你应该输出1\",{\"1\":{\"491\":1}}],[\"所以首尾是不压缩的\",{\"1\":{\"448\":1}}],[\"所以entry中存储的string长度不能超过63\",{\"1\":{\"442\":1}}],[\"所以为了解决遍历\",{\"1\":{\"441\":1}}],[\"所以不需要考虑这个问题\",{\"1\":{\"441\":1}}],[\"所以不需要回表查询数据\",{\"1\":{\"131\":1}}],[\"所以增加了\",{\"1\":{\"441\":1}}],[\"所以增加\",{\"1\":{\"441\":1}}],[\"所以读一行\",{\"1\":{\"422\":1}}],[\"所以\",{\"1\":{\"399\":1,\"438\":1,\"441\":1,\"464\":1,\"541\":1}}],[\"所以hyperloglog\",{\"1\":{\"398\":1}}],[\"所以市面上就出现了很多的客户端\",{\"1\":{\"371\":1}}],[\"所以在使用之前需要导入\",{\"1\":{\"353\":1}}],[\"所以在更新操作时\",{\"1\":{\"223\":1}}],[\"所以可以直接启动服务\",{\"1\":{\"340\":1}}],[\"所以运行方式与nginx基本一致\",{\"1\":{\"306\":1}}],[\"所以需要数据淘汰策略\",{\"1\":{\"273\":1}}],[\"所以推荐使用\",{\"1\":{\"243\":1}}],[\"所以存储引擎也可以被称为表的类型\",{\"1\":{\"232\":1}}],[\"所以我们在创建视图的时候\",{\"1\":{\"162\":1}}],[\"所以一共能存储\",{\"1\":{\"126\":1}}],[\"所以这里通过位序或者索引进行查找的最好\",{\"1\":{\"36\":1}}],[\"所以插入和删除操作需要移动大量元素\",{\"1\":{\"36\":1}}],[\"dp\",{\"1\":{\"503\":14,\"506\":11,\"526\":10,\"529\":11,\"534\":23,\"536\":17,\"538\":15}}],[\"dynamic\",{\"1\":{\"425\":1}}],[\"driven\",{\"1\":{\"401\":1}}],[\"drop\",{\"1\":{\"49\":1,\"127\":1,\"155\":1,\"163\":1,\"176\":1,\"177\":1,\"178\":1,\"195\":1,\"196\":1,\"240\":1}}],[\"dump\",{\"1\":{\"319\":2}}],[\"durability\",{\"1\":{\"257\":1}}],[\"durablity\",{\"1\":{\"74\":1}}],[\"duration\",{\"1\":{\"144\":1,\"283\":1}}],[\"d+\",{\"1\":{\"311\":1}}],[\"dcl全称为data\",{\"1\":{\"194\":1}}],[\"dcl语句\",{\"0\":{\"194\":1}}],[\"dcl\",{\"1\":{\"174\":1}}],[\"dql语法\",{\"0\":{\"184\":1}}],[\"dql语句\",{\"0\":{\"183\":1}}],[\"dql\",{\"1\":{\"174\":1}}],[\"dml操作遵循acid模型\",{\"1\":{\"234\":1}}],[\"dml语句\",{\"0\":{\"179\":1}}],[\"dml\",{\"1\":{\"174\":1}}],[\"ddl\",{\"1\":{\"174\":1}}],[\"ddl语句\",{\"0\":{\"175\":1},\"1\":{\"138\":1}}],[\"dict采用渐进式rehash\",{\"1\":{\"439\":1}}],[\"dict收缩\",{\"1\":{\"439\":1}}],[\"dict扩容\",{\"1\":{\"439\":1}}],[\"dict包含两个哈希表\",{\"1\":{\"439\":1}}],[\"dict小结\",{\"0\":{\"439\":1}}],[\"dict的伸缩\",{\"1\":{\"439\":1}}],[\"dict的结构\",{\"1\":{\"439\":1}}],[\"dict的\",{\"1\":{\"438\":1}}],[\"dict在每次新增键值对时都会检查负载因子\",{\"1\":{\"437\":1}}],[\"dicttype\",{\"1\":{\"436\":1}}],[\"dictht\",{\"1\":{\"436\":3}}],[\"dicthashtable\",{\"1\":{\"435\":1}}],[\"dictentry\",{\"1\":{\"435\":1,\"436\":4}}],[\"dictionary\",{\"1\":{\"365\":1}}],[\"dict\",{\"1\":{\"307\":1,\"417\":1,\"418\":2,\"419\":1,\"435\":6,\"436\":4,\"437\":2,\"438\":7,\"454\":10}}],[\"discard\",{\"1\":{\"399\":1}}],[\"diskless\",{\"1\":{\"301\":1}}],[\"distanct\",{\"1\":{\"132\":1}}],[\"distinct\",{\"1\":{\"132\":1,\"166\":1,\"186\":1}}],[\"direction\",{\"1\":{\"447\":1}}],[\"directly\",{\"1\":{\"426\":1}}],[\"dir\",{\"1\":{\"295\":6,\"319\":1,\"331\":1,\"339\":1}}],[\"dirty\",{\"1\":{\"61\":1}}],[\"dont\",{\"1\":{\"447\":1}}],[\"done\",{\"1\":{\"344\":1}}],[\"document\",{\"1\":{\"426\":1}}],[\"docs\",{\"1\":{\"366\":1,\"374\":1}}],[\"down\",{\"1\":{\"326\":1,\"331\":1}}],[\"downloads\",{\"1\":{\"105\":1}}],[\"do\",{\"1\":{\"249\":1,\"250\":1,\"289\":4,\"344\":2,\"432\":1}}],[\"double\",{\"0\":{\"71\":1},\"1\":{\"436\":1,\"452\":1}}],[\"dbfilename\",{\"1\":{\"319\":1}}],[\"dbms\",{\"1\":{\"104\":1}}],[\"db\",{\"1\":{\"82\":6,\"104\":1}}],[\"daemon\",{\"1\":{\"370\":1}}],[\"daemonize\",{\"1\":{\"339\":1,\"369\":1}}],[\"day\",{\"1\":{\"55\":1}}],[\"datebind\",{\"1\":{\"353\":1}}],[\"date2\",{\"1\":{\"55\":2}}],[\"date1\",{\"1\":{\"55\":1}}],[\"datediff\",{\"1\":{\"55\":1}}],[\"date\",{\"1\":{\"55\":5,\"244\":1}}],[\"databind<\",{\"1\":{\"353\":1}}],[\"databind\",{\"1\":{\"353\":1}}],[\"databases\",{\"1\":{\"176\":1,\"339\":1}}],[\"database\",{\"1\":{\"104\":1,\"176\":3,\"195\":1,\"319\":1,\"454\":2}}],[\"datafile\",{\"1\":{\"68\":1}}],[\"data\",{\"1\":{\"36\":9,\"37\":1,\"66\":1,\"142\":1,\"145\":2,\"174\":4,\"202\":1,\"254\":1,\"334\":1,\"354\":1,\"358\":1,\"360\":1,\"441\":1}}],[\"d\",{\"1\":{\"37\":2,\"436\":1}}],[\"decay\",{\"1\":{\"456\":1}}],[\"declear\",{\"1\":{\"252\":1}}],[\"declare\",{\"1\":{\"244\":1,\"253\":1}}],[\"depth命令查看\",{\"1\":{\"448\":1}}],[\"depth\",{\"1\":{\"447\":1,\"448\":1}}],[\"dependency>\",{\"1\":{\"334\":1,\"351\":2,\"353\":1,\"360\":2}}],[\"devel\",{\"1\":{\"305\":2}}],[\"determinsric\",{\"1\":{\"254\":1}}],[\"delconsumer\",{\"1\":{\"385\":1,\"393\":1}}],[\"delivered\",{\"1\":{\"385\":3}}],[\"delimiter\",{\"1\":{\"240\":1}}],[\"del\",{\"1\":{\"361\":1,\"407\":1}}],[\"delete操作的访问频次\",{\"1\":{\"226\":1}}],[\"delete语句只能按行删除数据\",{\"1\":{\"182\":1}}],[\"delete型触发器\",{\"1\":{\"154\":1}}],[\"delete之前或者之后\",{\"1\":{\"153\":1}}],[\"delete时\",{\"1\":{\"114\":1}}],[\"delete的时候\",{\"1\":{\"83\":1}}],[\"delete的时候产生的便于数据回滚的日志\",{\"1\":{\"83\":1}}],[\"delete\",{\"1\":{\"50\":1,\"80\":1,\"98\":1,\"144\":1,\"145\":1,\"155\":1,\"159\":3,\"182\":1,\"196\":1,\"226\":1}}],[\"destroy\",{\"1\":{\"385\":1,\"393\":1}}],[\"destroylist\",{\"1\":{\"35\":1}}],[\"desktop\",{\"1\":{\"373\":2}}],[\"designed\",{\"1\":{\"349\":1}}],[\"descriptor\",{\"1\":{\"404\":1}}],[\"description=redis\",{\"1\":{\"370\":1}}],[\"desc\",{\"1\":{\"177\":1,\"191\":1,\"211\":1,\"229\":2}}],[\"defrag\",{\"1\":{\"454\":1}}],[\"definition\",{\"1\":{\"174\":1}}],[\"define\",{\"1\":{\"36\":1,\"406\":4}}],[\"default\",{\"1\":{\"50\":1,\"177\":2,\"244\":1,\"306\":1,\"309\":1,\"422\":1}}],[\"defult\",{\"1\":{\"47\":1,\"56\":2,\"176\":1}}],[\"他还会检查依赖视图中的规则以保持一致性\",{\"1\":{\"164\":1}}],[\"他是一个不可分隔的工作单位\",{\"1\":{\"255\":1}}],[\"他是通过一组任意的存储单元来存储线性表中的数据元素\",{\"1\":{\"37\":1}}],[\"他是用一组地址连续的存储单元依次存储线性表中的数据元素\",{\"1\":{\"36\":1}}],[\"他们存在着某种关系\",{\"1\":{\"32\":1}}],[\"顺序插入时\",{\"1\":{\"116\":1}}],[\"顺序表与链表的比较和选择\",{\"0\":{\"41\":1}}],[\"顺序表长度增加\",{\"1\":{\"36\":1}}],[\"顺序表上基本操作的实现\",{\"1\":{\"36\":1}}],[\"顺序表最重要的特点是支持随机访问\",{\"1\":{\"36\":1}}],[\"顺序表中第一个元素存储在线性表的起始位置\",{\"1\":{\"36\":1}}],[\"顺序表中元素的逻辑顺序和实际的物理顺序相同\",{\"1\":{\"36\":1}}],[\"顺序表的存储密度高\",{\"1\":{\"36\":1}}],[\"顺序表的特点\",{\"1\":{\"36\":1}}],[\"顺序表的类型定义\",{\"1\":{\"36\":1}}],[\"顺序表的元素\",{\"1\":{\"36\":1}}],[\"顺序表当前的长度\",{\"1\":{\"36\":1}}],[\"顺序表\",{\"0\":{\"36\":1},\"1\":{\"36\":1}}],[\"顺序存储\",{\"1\":{\"33\":2}}],[\"销毁线性表\",{\"1\":{\"35\":1}}],[\"销毁操作\",{\"1\":{\"35\":1}}],[\"按传输介质分类\",{\"0\":{\"562\":1}}],[\"按传输技术分类\",{\"0\":{\"558\":1}}],[\"按交换技术分类\",{\"0\":{\"561\":1}}],[\"按使用者分类\",{\"0\":{\"560\":1}}],[\"按拓扑结构分类\",{\"0\":{\"559\":1}}],[\"按分布范围分类\",{\"0\":{\"557\":1}}],[\"按下述规则生成一个长度为\",{\"1\":{\"484\":1}}],[\"按照新的realesize申请内存空间\",{\"1\":{\"438\":2}}],[\"按照新的编码方式及元素的个数进行数组扩容\",{\"1\":{\"432\":1}}],[\"按照\",{\"1\":{\"419\":1,\"455\":1}}],[\"按照score排序后\",{\"1\":{\"380\":2}}],[\"按道理来讲get\",{\"1\":{\"352\":1}}],[\"按序号查找结点值\",{\"1\":{\"37\":1}}],[\"按序号查询\",{\"1\":{\"36\":1}}],[\"按序号查询操作的算法\",{\"1\":{\"36\":1}}],[\"按值查找表节点\",{\"1\":{\"37\":1}}],[\"按值查找操作\",{\"1\":{\"35\":1}}],[\"按值查询\",{\"1\":{\"36\":2}}],[\"按前后顺序输出线性表l的所有元素值\",{\"1\":{\"35\":1}}],[\"按位查找操作\",{\"1\":{\"35\":1}}],[\"et\",{\"1\":{\"408\":3}}],[\"etc\",{\"1\":{\"227\":1,\"242\":1,\"305\":2,\"370\":1}}],[\"edgetriggered\",{\"1\":{\"408\":1}}],[\"edition\",{\"1\":{\"106\":1}}],[\"epfd\",{\"1\":{\"407\":2}}],[\"epoll实例的句柄\",{\"1\":{\"407\":1}}],[\"epoll\",{\"0\":{\"407\":1},\"1\":{\"404\":2,\"407\":6,\"408\":5,\"409\":1,\"410\":4,\"459\":4,\"462\":1}}],[\"ewouldblock\",{\"1\":{\"403\":1}}],[\"evport\",{\"1\":{\"459\":2}}],[\"evalsha\",{\"1\":{\"384\":1}}],[\"eval\",{\"1\":{\"382\":1,\"383\":2,\"384\":1}}],[\"eventloop\",{\"1\":{\"462\":9}}],[\"event\",{\"1\":{\"407\":3}}],[\"eventpoll\",{\"1\":{\"407\":2}}],[\"events\",{\"1\":{\"306\":1,\"406\":1,\"407\":2,\"462\":1}}],[\"everysec\",{\"1\":{\"320\":2}}],[\"ease\",{\"1\":{\"349\":1}}],[\"each\",{\"1\":{\"155\":1,\"157\":1,\"158\":1,\"159\":1}}],[\"ef\",{\"1\":{\"340\":2}}],[\"err\",{\"1\":{\"307\":11}}],[\"errors\",{\"1\":{\"421\":1}}],[\"error\",{\"1\":{\"306\":3,\"421\":1}}],[\"echo\",{\"1\":{\"295\":1,\"331\":1,\"339\":1}}],[\"eq\",{\"1\":{\"229\":1}}],[\"exec\",{\"1\":{\"399\":3}}],[\"execstart=\",{\"1\":{\"370\":1}}],[\"exit\",{\"1\":{\"253\":1,\"307\":1}}],[\"exists\",{\"1\":{\"163\":1,\"176\":2,\"177\":1,\"240\":1,\"384\":1}}],[\"extra\",{\"1\":{\"229\":1,\"447\":1}}],[\"extent\",{\"1\":{\"204\":1}}],[\"excluding\",{\"1\":{\"426\":4}}],[\"exclusive\",{\"1\":{\"144\":1}}],[\"exceptfds\",{\"1\":{\"405\":1}}],[\"excute\",{\"1\":{\"157\":1,\"158\":1,\"159\":1}}],[\"expires\",{\"1\":{\"454\":2}}],[\"expire\",{\"1\":{\"361\":1,\"454\":1}}],[\"expireafterwrite\",{\"1\":{\"283\":1}}],[\"export\",{\"1\":{\"305\":2}}],[\"exp3\",{\"1\":{\"289\":1}}],[\"exp2\",{\"1\":{\"289\":1}}],[\"explain执行计划各字段的含义\",{\"1\":{\"229\":1}}],[\"explain执行计划\",{\"0\":{\"229\":1}}],[\"explain\",{\"1\":{\"130\":3,\"229\":3}}],[\"expr的值等于val2\",{\"1\":{\"56\":1}}],[\"expr\",{\"1\":{\"55\":1,\"56\":1,\"243\":6}}],[\"embstr的动态字符串\",{\"1\":{\"466\":1}}],[\"embstr\",{\"1\":{\"415\":1,\"466\":1,\"467\":1}}],[\"email\",{\"1\":{\"132\":2}}],[\"empty\",{\"1\":{\"35\":1,\"432\":1}}],[\"esists\",{\"1\":{\"361\":1}}],[\"es\",{\"1\":{\"115\":1}}],[\"enc\",{\"1\":{\"430\":1}}],[\"encoding编码\",{\"0\":{\"442\":1}}],[\"encoding\",{\"1\":{\"419\":1,\"430\":1,\"431\":1,\"432\":2,\"441\":2,\"442\":4,\"447\":1,\"456\":1,\"465\":1,\"466\":10}}],[\"entries时\",{\"1\":{\"418\":1}}],[\"entries\",{\"1\":{\"417\":1,\"419\":1,\"447\":1}}],[\"entry\",{\"1\":{\"417\":2,\"419\":1,\"436\":4,\"438\":1,\"441\":1,\"443\":2,\"444\":1,\"447\":3,\"448\":2}}],[\"enterprise\",{\"1\":{\"106\":1}}],[\"enable\",{\"1\":{\"370\":1}}],[\"enabled\",{\"1\":{\"339\":1}}],[\"engine=innodb\",{\"1\":{\"232\":1}}],[\"engines\",{\"1\":{\"232\":1}}],[\"engine\",{\"1\":{\"68\":2}}],[\"end块\",{\"1\":{\"244\":1}}],[\"end\",{\"1\":{\"56\":2,\"155\":1,\"157\":1,\"158\":1,\"159\":1,\"240\":1,\"245\":1,\"246\":1,\"247\":2,\"249\":1,\"250\":1,\"251\":2,\"254\":1,\"289\":3,\"290\":2,\"291\":1,\"307\":8,\"378\":1,\"390\":2,\"391\":2,\"397\":1,\"447\":1,\"552\":1}}],[\"el=\",{\"1\":{\"462\":1}}],[\"el\",{\"1\":{\"462\":2}}],[\"ele\",{\"1\":{\"419\":1,\"452\":1,\"453\":2}}],[\"element在前\",{\"1\":{\"419\":1}}],[\"element\",{\"1\":{\"378\":2,\"398\":1,\"419\":1,\"447\":1}}],[\"elemetype\",{\"1\":{\"36\":1,\"37\":1}}],[\"elemtype\",{\"1\":{\"36\":4}}],[\"elseif\",{\"1\":{\"245\":1}}],[\"else\",{\"1\":{\"56\":2,\"245\":1,\"247\":2,\"290\":1,\"432\":7,\"482\":2,\"543\":2}}],[\"e\",{\"1\":{\"35\":3,\"36\":13,\"291\":2,\"295\":6,\"331\":4,\"422\":4}}],[\"求交集\",{\"1\":{\"418\":1}}],[\"求差集\",{\"1\":{\"380\":1}}],[\"求key1和key2的并集\",{\"1\":{\"379\":1}}],[\"求key1与key2的差集\",{\"1\":{\"379\":1}}],[\"求key1与key2的交集\",{\"1\":{\"379\":1}}],[\"求参数x的四舍五入值\",{\"1\":{\"54\":1}}],[\"求表长操作\",{\"1\":{\"37\":1}}],[\"求表长\",{\"1\":{\"35\":1}}],[\"求和\",{\"1\":{\"25\":1,\"26\":1,\"27\":1,\"189\":1}}],[\"lzf\",{\"1\":{\"447\":1}}],[\"lzf==2\",{\"1\":{\"447\":1}}],[\"lsb\",{\"1\":{\"426\":5}}],[\"lt\",{\"1\":{\"408\":3}}],[\"lrange\",{\"1\":{\"378\":1}}],[\"lru\",{\"1\":{\"276\":2,\"283\":1,\"456\":7,\"465\":3}}],[\"lpop\",{\"1\":{\"378\":1}}],[\"lpush\",{\"1\":{\"378\":1}}],[\"lpad\",{\"1\":{\"53\":1}}],[\"lcoal\",{\"1\":{\"311\":1}}],[\"lfu\",{\"1\":{\"276\":2,\"456\":7}}],[\"lua文件\",{\"0\":{\"310\":1}}],[\"lualib\",{\"1\":{\"307\":2,\"309\":2}}],[\"lua函数可以返回多个结果值\",{\"1\":{\"291\":1}}],[\"lua语言函数可以返回多个值\",{\"1\":{\"291\":1}}],[\"lua语法\",{\"0\":{\"285\":1},\"1\":{\"264\":1}}],[\"lua认为false和nil为假\",{\"1\":{\"290\":1}}],[\"lua\",{\"0\":{\"286\":1},\"1\":{\"286\":2,\"287\":4,\"288\":7,\"291\":3,\"304\":4,\"307\":6,\"309\":10,\"310\":6,\"311\":3,\"382\":2,\"384\":1}}],[\"lua脚本\",{\"0\":{\"382\":1},\"1\":{\"262\":1}}],[\"lan\",{\"1\":{\"557\":1}}],[\"language\",{\"1\":{\"104\":1,\"174\":4,\"194\":1}}],[\"later\",{\"1\":{\"447\":1,\"454\":1}}],[\"latitude\",{\"1\":{\"396\":3}}],[\"larger\",{\"1\":{\"432\":1}}],[\"layout\",{\"1\":{\"426\":1}}],[\"last\",{\"1\":{\"385\":3}}],[\"lable\",{\"1\":{\"251\":4}}],[\"leifengyang\",{\"1\":{\"549\":2}}],[\"leetcode509\",{\"1\":{\"497\":1}}],[\"leetcode\",{\"0\":{\"544\":1},\"1\":{\"478\":1,\"493\":1,\"510\":1,\"515\":1,\"520\":1,\"533\":1,\"542\":1}}],[\"lettuceclientconfigurationbuilder\",{\"1\":{\"334\":1}}],[\"lettuceclientconfigurationbuildercustomizer\",{\"1\":{\"334\":4}}],[\"lettuceclientconfiguration\",{\"1\":{\"334\":1}}],[\"lettuce\",{\"1\":{\"334\":1,\"346\":1,\"358\":2,\"360\":1}}],[\"leveltriggered\",{\"1\":{\"408\":1}}],[\"level\",{\"1\":{\"259\":1,\"452\":2}}],[\"least\",{\"1\":{\"456\":2}}],[\"leave和iterate相当于编程语言中的\",{\"1\":{\"251\":1}}],[\"leave\",{\"1\":{\"251\":2}}],[\"leaf\",{\"1\":{\"58\":2}}],[\"left\",{\"1\":{\"95\":1,\"512\":4}}],[\"len\",{\"1\":{\"53\":1,\"229\":1,\"422\":7,\"425\":1,\"426\":4,\"447\":1,\"462\":1,\"517\":18}}],[\"length+prepend\",{\"1\":{\"432\":1}}],[\"length\",{\"1\":{\"35\":1,\"36\":10,\"37\":3,\"422\":2,\"426\":1,\"430\":1,\"431\":1,\"432\":3,\"441\":1,\"443\":1,\"452\":1,\"477\":1,\"481\":2,\"482\":4,\"494\":2,\"503\":1,\"514\":2,\"516\":2,\"517\":4,\"526\":1,\"532\":1,\"534\":3,\"536\":5,\"538\":2,\"541\":2,\"543\":2}}],[\"l为头指针\",{\"1\":{\"37\":1}}],[\"lib\",{\"1\":{\"227\":1}}],[\"linkedlist<>\",{\"1\":{\"482\":2}}],[\"linkedlist和ziplist\",{\"1\":{\"467\":1}}],[\"linkedlist\",{\"1\":{\"416\":1,\"446\":1,\"466\":1}}],[\"linklist\",{\"1\":{\"37\":5}}],[\"linux\",{\"1\":{\"287\":1,\"373\":1,\"401\":3,\"404\":2,\"405\":1}}],[\"line\",{\"1\":{\"202\":2}}],[\"lines\",{\"1\":{\"202\":1}}],[\"like\",{\"1\":{\"187\":1,\"226\":1,\"234\":1,\"242\":1}}],[\"limit优化\",{\"0\":{\"215\":1}}],[\"limit\",{\"1\":{\"184\":1,\"185\":1,\"192\":1,\"193\":1}}],[\"list<integer>\",{\"1\":{\"482\":1}}],[\"list<list<integer>>\",{\"1\":{\"482\":2}}],[\"list<object>\",{\"1\":{\"422\":1}}],[\"listaddnodehead\",{\"1\":{\"462\":1}}],[\"listpacks\",{\"1\":{\"447\":1}}],[\"listpack\",{\"1\":{\"447\":2}}],[\"listoperations\",{\"1\":{\"359\":1}}],[\"listentoport\",{\"1\":{\"462\":1}}],[\"listen\",{\"1\":{\"306\":1}}],[\"list3\",{\"1\":{\"200\":1}}],[\"list2\",{\"1\":{\"200\":1,\"247\":2}}],[\"list1\",{\"1\":{\"200\":1,\"247\":2}}],[\"list\",{\"0\":{\"378\":1},\"1\":{\"37\":1,\"199\":1,\"247\":2,\"356\":1,\"375\":1,\"395\":1,\"407\":1,\"416\":2,\"422\":3,\"446\":1,\"448\":4,\"454\":1,\"467\":1,\"482\":5}}],[\"listdelete\",{\"1\":{\"35\":1,\"36\":1}}],[\"listinsert\",{\"1\":{\"35\":1,\"36\":1}}],[\"lnode\",{\"1\":{\"37\":7}}],[\"lookupcommand\",{\"1\":{\"462\":1}}],[\"loop\",{\"1\":{\"251\":2}}],[\"loop可以配合以下两个语句使用\",{\"1\":{\"251\":1}}],[\"loop实现简单的循环\",{\"1\":{\"251\":1}}],[\"loop循环\",{\"0\":{\"251\":1}}],[\"long类型的整数的字符串\",{\"1\":{\"466\":1}}],[\"longval\",{\"1\":{\"447\":1}}],[\"longitude\",{\"1\":{\"396\":3}}],[\"long\",{\"1\":{\"227\":2,\"405\":2,\"415\":1,\"422\":1,\"436\":4,\"447\":5,\"452\":2,\"454\":3,\"462\":1}}],[\"loadingcache\",{\"1\":{\"281\":1}}],[\"load\",{\"1\":{\"202\":1,\"384\":1}}],[\"load指令可以将文件内的数据\",{\"1\":{\"202\":1}}],[\"location\",{\"1\":{\"306\":2,\"307\":1,\"309\":1,\"311\":1}}],[\"locateelem\",{\"1\":{\"35\":1,\"36\":1}}],[\"localfactor\",{\"1\":{\"437\":3}}],[\"localhost\",{\"1\":{\"227\":1,\"306\":1,\"334\":2}}],[\"local会检查当前视图\",{\"1\":{\"164\":1}}],[\"local\",{\"1\":{\"163\":3,\"164\":1,\"202\":4,\"288\":5,\"291\":1,\"305\":2,\"306\":1,\"307\":12,\"309\":2,\"370\":2}}],[\"locks\",{\"1\":{\"144\":1,\"145\":1}}],[\"lock\",{\"1\":{\"80\":1,\"139\":1,\"142\":1,\"143\":3,\"144\":4,\"145\":4,\"146\":3}}],[\"logs\",{\"1\":{\"157\":1,\"158\":1,\"159\":1,\"306\":1}}],[\"log记录事务回滚的数据\",{\"1\":{\"84\":1}}],[\"log记录物理日志不一样\",{\"1\":{\"76\":1}}],[\"log采用段的方式进行管理和记录\",{\"1\":{\"76\":1}}],[\"log存储\",{\"1\":{\"76\":1}}],[\"log在事务执行时产生\",{\"1\":{\"76\":1}}],[\"log销毁\",{\"1\":{\"76\":1}}],[\"log中的逻辑记录读取到相应的内容并进行回滚\",{\"1\":{\"76\":1}}],[\"log中会记录一条对应的insert记录\",{\"1\":{\"76\":1}}],[\"log和redo\",{\"1\":{\"76\":1}}],[\"logo\",{\"1\":{\"75\":1}}],[\"logfile\",{\"1\":{\"339\":1}}],[\"logfile1\",{\"1\":{\"72\":1}}],[\"logfile0\",{\"1\":{\"72\":1}}],[\"log日志\",{\"1\":{\"69\":1}}],[\"log等\",{\"1\":{\"66\":1}}],[\"log\",{\"0\":{\"63\":1,\"72\":1,\"75\":1,\"76\":1,\"83\":1,\"84\":1},\"1\":{\"63\":4,\"73\":3,\"75\":1,\"76\":2,\"79\":1,\"82\":1,\"83\":2,\"84\":3,\"86\":3,\"227\":2,\"300\":1,\"306\":2,\"307\":5,\"339\":1,\"456\":2}}],[\"log2​n\",{\"1\":{\"23\":1}}],[\"lower\",{\"1\":{\"53\":1}}],[\"l\",{\"1\":{\"35\":10,\"36\":25,\"37\":9}}],[\"若中央处理器之间的距离非常近\",{\"1\":{\"557\":1}}],[\"若仅仅更新j\",{\"1\":{\"481\":1}}],[\"若超过指定数量\",{\"1\":{\"325\":1}}],[\"若缓冲池中没有所需数据\",{\"1\":{\"61\":1}}],[\"若\",{\"1\":{\"36\":1}}],[\"若l表为空\",{\"1\":{\"35\":1}}],[\"若用l命名线性表\",{\"1\":{\"35\":1}}],[\"若服务端还有数据未完成传输\",{\"1\":{\"17\":1}}],[\"其占用\",{\"1\":{\"465\":1}}],[\"其它操作在两个哈希表\",{\"1\":{\"439\":1}}],[\"其它节点都是slave节点\",{\"1\":{\"341\":1}}],[\"其基本编码方式是\",{\"1\":{\"415\":1}}],[\"其系统内核都是\",{\"1\":{\"401\":1}}],[\"其余的命令依然被执行\",{\"1\":{\"399\":1}}],[\"其余全是冲突的\",{\"1\":{\"147\":1}}],[\"其value是一个无序字典\",{\"1\":{\"377\":1}}],[\"其value是字符串\",{\"1\":{\"376\":1}}],[\"其节点会因为自动故障转移而发生变化\",{\"1\":{\"334\":1}}],[\"其实是放入连接池\",{\"1\":{\"307\":1}}],[\"其实是一个\",{\"1\":{\"288\":1}}],[\"其内部集成了大量精良的\",{\"1\":{\"304\":1}}],[\"其内存储的是数据行\",{\"1\":{\"204\":1}}],[\"其内存储的是row行\",{\"1\":{\"204\":1}}],[\"其返回匹配串\",{\"1\":{\"291\":1}}],[\"其设计的目的是为了嵌入应用程序中\",{\"1\":{\"286\":1}}],[\"其语法如下\",{\"1\":{\"252\":1}}],[\"其作用域为当前的连接\",{\"1\":{\"243\":1}}],[\"其中斜体加粗标注的为\",{\"1\":{\"541\":1}}],[\"其中前\",{\"1\":{\"541\":1}}],[\"其中\",{\"1\":{\"496\":1,\"514\":1,\"532\":1}}],[\"其中值本身又是字符串对象\",{\"1\":{\"469\":1}}],[\"其中一个是当前数据\",{\"1\":{\"436\":1}}],[\"其中每一个元素都需要指定一个score\",{\"1\":{\"419\":1}}],[\"其中的commonds就是redis的操作命令\",{\"1\":{\"372\":1}}],[\"其中常见的options有\",{\"1\":{\"372\":1}}],[\"其中封装了各种对\",{\"1\":{\"359\":1}}],[\"其中对\",{\"1\":{\"358\":1}}],[\"其中只有分片集群的配置方式略有差异\",{\"1\":{\"346\":1}}],[\"其中有id和username两个字段\",{\"1\":{\"232\":1}}],[\"其中n为表长\",{\"1\":{\"35\":1}}],[\"其存储的是page页\",{\"1\":{\"204\":1}}],[\"其存储的是extent区\",{\"1\":{\"204\":1}}],[\"其典型的使用场景是做全库的逻辑备份\",{\"1\":{\"138\":1}}],[\"其他网格\",{\"1\":{\"511\":1}}],[\"其他办法\",{\"1\":{\"435\":1}}],[\"其他客户端提交的命令请求不会插入到事务执行命令序列中\",{\"1\":{\"399\":1}}],[\"其他安装\",{\"1\":{\"366\":1}}],[\"其他数据全部丢弃\",{\"1\":{\"217\":1}}],[\"其他引擎不支持\",{\"1\":{\"121\":1}}],[\"其他5种约束的适用方法较为简单\",{\"1\":{\"48\":1}}],[\"其结果都是相同的\",{\"1\":{\"96\":1}}],[\"其一般表示为\",{\"1\":{\"35\":1}}],[\"其值为前两个数值之和\",{\"1\":{\"498\":1}}],[\"其值可以在分解为若干变量的数据类型\",{\"1\":{\"32\":1}}],[\"其值不可再分的数据类型\",{\"1\":{\"32\":1}}],[\"施加在数据上的运算包括运算的定义和实现\",{\"1\":{\"33\":1}}],[\"根据redisobject的encoding属性所指定的编码\",{\"1\":{\"468\":1}}],[\"根据命令名称\",{\"1\":{\"462\":1}}],[\"根据不同的操作系统\",{\"1\":{\"459\":1}}],[\"根据新元素的数据类型\",{\"1\":{\"432\":1}}],[\"根据储存在位置集合⾥⾯的某个地点获取指定范围内的地理位置集合\",{\"1\":{\"396\":1}}],[\"根据⽤户给定的经纬度坐标来获取指定范围内的地理位置集合\",{\"1\":{\"396\":1}}],[\"根据给定的key\",{\"1\":{\"468\":1}}],[\"根据给定的\",{\"1\":{\"384\":1}}],[\"根据多个key获取多个string类型的value\",{\"1\":{\"376\":1}}],[\"根据key获取string类型的value\",{\"1\":{\"376\":1}}],[\"根据数据类型的不同获取对应的操作对象\",{\"1\":{\"359\":1}}],[\"根据\",{\"1\":{\"343\":1}}],[\"根据商品id对tomcat集群负载均衡\",{\"0\":{\"314\":1}}],[\"根据淘汰策略去选择要淘汰的数据\",{\"1\":{\"273\":1}}],[\"根据排序字段建立合适的索引\",{\"1\":{\"211\":1}}],[\"根据主键排序\",{\"1\":{\"205\":1}}],[\"根据索引关联字段的个数\",{\"1\":{\"127\":1}}],[\"根据索引的存储形式\",{\"1\":{\"124\":1}}],[\"根据自己的操作系统下载安装即可\",{\"1\":{\"105\":1}}],[\"根据子查询的结果不同\",{\"1\":{\"98\":1}}],[\"根据状态\",{\"1\":{\"61\":1}}],[\"根据元素的关键字直接计算出该元素的存储位置\",{\"1\":{\"33\":1}}],[\"根据循环的层次不同\",{\"1\":{\"20\":1}}],[\"索引和数据均存储在内存中\",{\"1\":{\"236\":1}}],[\"索引字段进行更新\",{\"1\":{\"223\":1}}],[\"索引的使用也是满足最左前缀法则的\",{\"1\":{\"214\":1}}],[\"索引越多\",{\"1\":{\"134\":1}}],[\"索引并不是多多益善\",{\"1\":{\"134\":1}}],[\"索引设计原则\",{\"0\":{\"134\":1}}],[\"索引选择性越高则查询效率越高\",{\"1\":{\"132\":1}}],[\"索引不会失效\",{\"1\":{\"129\":1}}],[\"索引将失效\",{\"1\":{\"129\":2}}],[\"索引将部分失效\",{\"1\":{\"129\":1}}],[\"索引失效场景\",{\"0\":{\"129\":1}}],[\"索引使用\",{\"0\":{\"128\":1}}],[\"索引列运算\",{\"1\":{\"129\":1}}],[\"索引列表只有一个字段\",{\"1\":{\"127\":1}}],[\"索引列也是要占用空间的\",{\"1\":{\"114\":1}}],[\"索引语法\",{\"0\":{\"127\":1}}],[\"索引主要分为4个类型\",{\"1\":{\"124\":1}}],[\"索引分类\",{\"0\":{\"124\":1}}],[\"索引结构的叶子结点关联的是对应的主键\",{\"1\":{\"124\":1}}],[\"索引结构的叶子结点保存了行数据\",{\"1\":{\"124\":1}}],[\"索引结构\",{\"0\":{\"115\":1},\"1\":{\"115\":1}}],[\"索引是一种典型的使用空间换时间的例子\",{\"1\":{\"114\":1}}],[\"索引是帮助mysql的数据结构\",{\"1\":{\"113\":1}}],[\"索引大大提高了查询效率\",{\"1\":{\"114\":1}}],[\"索引概述\",{\"0\":{\"112\":1}}],[\"索引\",{\"0\":{\"111\":1},\"1\":{\"123\":1,\"170\":1}}],[\"索引段即为b+树的非叶子结点\",{\"1\":{\"58\":1}}],[\"索引段\",{\"1\":{\"58\":1}}],[\"索引等数据\",{\"1\":{\"58\":1}}],[\"索引项的一般形式为\",{\"1\":{\"33\":1}}],[\"索引表中的每项称为索引项\",{\"1\":{\"33\":1}}],[\"索引存储\",{\"1\":{\"33\":2}}],[\"还可以对节点的\",{\"1\":{\"448\":1}}],[\"还可以使用开放地址法\",{\"1\":{\"435\":1}}],[\"还可以作为缓冲区\",{\"1\":{\"428\":1}}],[\"还可以是数组\",{\"1\":{\"421\":1}}],[\"还可以根据实际情况选择多种存储引擎进行组合\",{\"1\":{\"237\":1}}],[\"还采用\",{\"1\":{\"419\":1}}],[\"还是队尾\",{\"1\":{\"432\":1}}],[\"还是\",{\"1\":{\"432\":1}}],[\"还是非阻塞\",{\"1\":{\"404\":1}}],[\"还是以\",{\"1\":{\"240\":1}}],[\"还能保证消息不丢失\",{\"1\":{\"385\":1}}],[\"还包含很多的更新\",{\"1\":{\"237\":1}}],[\"还包括脏页的刷新\",{\"1\":{\"73\":1}}],[\"还阅读了\",{\"1\":{\"171\":1}}],[\"还依靠readview\",{\"1\":{\"84\":1}}],[\"还需要申请新的空间等问题\",{\"1\":{\"443\":1}}],[\"还需要调整页间指针的方向\",{\"1\":{\"205\":1}}],[\"还需要依赖于数据库记录中的三个隐藏字段\",{\"1\":{\"79\":1}}],[\"还需要向服务端发送一个报文段\",{\"1\":{\"15\":1}}],[\"还负责将缓冲池中的数据异步刷新到磁盘中\",{\"1\":{\"73\":1}}],[\"还存储指针域\",{\"1\":{\"37\":1}}],[\"还建立附加的索引表\",{\"1\":{\"33\":1}}],[\"借助指针存储地址来表示元素之间的逻辑关系\",{\"1\":{\"33\":1}}],[\"两次备份之间会丢失\",{\"1\":{\"321\":1}}],[\"两次\",{\"1\":{\"319\":1}}],[\"两个的数值\",{\"1\":{\"534\":1}}],[\"两个或多个不同的键\",{\"1\":{\"435\":1}}],[\"两个从节点\",{\"1\":{\"294\":1}}],[\"两个集合a和b的所有组合情况\",{\"1\":{\"93\":1}}],[\"两种\",{\"1\":{\"33\":1}}],[\"两层循环\",{\"0\":{\"25\":1},\"1\":{\"20\":1}}],[\"非递减顺序\",{\"1\":{\"541\":2}}],[\"非二进制安全\",{\"1\":{\"425\":1}}],[\"非常类似\",{\"1\":{\"417\":1}}],[\"非常感谢大家的支持\",{\"1\":{\"3\":1}}],[\"非阻塞io\",{\"0\":{\"403\":1}}],[\"非阻塞\",{\"1\":{\"401\":1,\"403\":2,\"404\":1}}],[\"非sql查询\",{\"1\":{\"364\":1}}],[\"非结构化\",{\"1\":{\"364\":1}}],[\"非\",{\"1\":{\"187\":1}}],[\"非关系型可以分为以下几种类型\",{\"1\":{\"109\":1}}],[\"非关系型的\",{\"1\":{\"109\":1}}],[\"非关系型数据库\",{\"0\":{\"109\":1}}],[\"非空约束\",{\"1\":{\"47\":1}}],[\"非线性结构\",{\"1\":{\"33\":1}}],[\"分工协作\",{\"1\":{\"574\":1}}],[\"分布在不同地理位置的多台独立的\",{\"1\":{\"566\":1}}],[\"分布式处理\",{\"0\":{\"575\":1}}],[\"分布式缓存\",{\"1\":{\"280\":1}}],[\"分布式系统\",{\"1\":{\"275\":1}}],[\"分布式的\",{\"1\":{\"109\":1}}],[\"分析工具\",{\"0\":{\"550\":1}}],[\"分配给孩子\",{\"1\":{\"491\":1}}],[\"分发饼干\",{\"0\":{\"490\":1},\"1\":{\"493\":1}}],[\"分钟\",{\"1\":{\"456\":1}}],[\"分两种情况\",{\"1\":{\"343\":1}}],[\"分片集群\",{\"1\":{\"365\":1}}],[\"分片集群需要的节点数量较多\",{\"1\":{\"338\":1}}],[\"分片集群特征\",{\"1\":{\"337\":1}}],[\"分别表示\",{\"1\":{\"541\":1}}],[\"分别记录\",{\"1\":{\"454\":1}}],[\"分别是\",{\"1\":{\"435\":1}}],[\"分别保存\",{\"1\":{\"417\":1}}],[\"分别启动3个redis实例\",{\"1\":{\"296\":1,\"332\":1}}],[\"分别添加缓存\",{\"1\":{\"279\":1}}],[\"分别为创建唯一索引和全文索引\",{\"1\":{\"127\":1}}],[\"分别为\",{\"1\":{\"33\":1}}],[\"分页查询是数据库的方言\",{\"1\":{\"192\":1}}],[\"分页查询\",{\"0\":{\"192\":1},\"1\":{\"185\":1}}],[\"分页参数\",{\"1\":{\"184\":1,\"193\":1}}],[\"分组操作时\",{\"1\":{\"214\":1}}],[\"分组以后\",{\"1\":{\"190\":1}}],[\"分组后的过滤条件\",{\"1\":{\"190\":1}}],[\"分组后条件列表\",{\"1\":{\"184\":1,\"193\":1}}],[\"分组字段名\",{\"1\":{\"190\":1}}],[\"分组字段列表\",{\"1\":{\"184\":1,\"193\":1}}],[\"分组查询\",{\"0\":{\"190\":1},\"1\":{\"185\":1}}],[\"分组\",{\"1\":{\"134\":1}}],[\"分为5种情况\",{\"1\":{\"448\":1}}],[\"分为全面变量\",{\"1\":{\"242\":1}}],[\"分为\",{\"1\":{\"98\":1}}],[\"分为三个类别\",{\"1\":{\"20\":1}}],[\"分库分表\",{\"0\":{\"51\":1},\"1\":{\"170\":1}}],[\"分类\",{\"0\":{\"47\":1},\"1\":{\"124\":2,\"143\":1}}],[\"对每个孩子\",{\"1\":{\"491\":1}}],[\"对两个指针的操作是同时的\",{\"1\":{\"481\":1}}],[\"对流进行修剪\",{\"1\":{\"385\":1,\"387\":1}}],[\"对性能要求高\",{\"1\":{\"364\":1}}],[\"对一致性\",{\"1\":{\"364\":1}}],[\"对象共享\",{\"0\":{\"469\":1}}],[\"对象引用计数器\",{\"1\":{\"465\":1}}],[\"对象起码就应该包含3个属性\",{\"1\":{\"464\":1}}],[\"对象类型\",{\"1\":{\"456\":1}}],[\"对象\",{\"1\":{\"359\":1,\"360\":1,\"465\":1}}],[\"对象即可操作\",{\"1\":{\"356\":1}}],[\"对象时\",{\"1\":{\"355\":1}}],[\"对象存储至\",{\"1\":{\"354\":1}}],[\"对象实例内的各个属性值\",{\"1\":{\"32\":1}}],[\"对\",{\"1\":{\"343\":1}}],[\"对数据库进行事务操作\",{\"1\":{\"258\":1}}],[\"对数据库的任何操作都是安全的\",{\"1\":{\"258\":1}}],[\"对limit来讲\",{\"1\":{\"216\":1}}],[\"对应pingcommand\",{\"1\":{\"462\":1}}],[\"对应值\",{\"1\":{\"426\":1}}],[\"对应的底层实现有两种\",{\"1\":{\"417\":1}}],[\"对应的\",{\"1\":{\"408\":1}}],[\"对应的时间复杂度为\",{\"1\":{\"26\":1}}],[\"对应sql\",{\"1\":{\"144\":1}}],[\"对所有的表进行锁定\",{\"1\":{\"138\":1}}],[\"对于所有的网格就只有这两种方式到达\",{\"1\":{\"511\":1}}],[\"对于于一个单链表来讲\",{\"1\":{\"450\":1}}],[\"对于github访问慢的⽤户\",{\"1\":{\"373\":1}}],[\"对于\",{\"1\":{\"273\":1}}],[\"对于提高数据处理的效率是有好处的\",{\"1\":{\"239\":1}}],[\"对于复杂的应用系统\",{\"1\":{\"237\":1}}],[\"对于返回的结果集\",{\"1\":{\"221\":1}}],[\"对于数据的变动\",{\"1\":{\"220\":1}}],[\"对于满足排序列表的索引\",{\"1\":{\"209\":1}}],[\"对于行级锁\",{\"1\":{\"146\":1}}],[\"对于表锁\",{\"1\":{\"143\":1}}],[\"对于表级锁\",{\"1\":{\"142\":1}}],[\"对于hash索引\",{\"1\":{\"122\":1}}],[\"对于b树\",{\"1\":{\"122\":1}}],[\"对于联合查询而言\",{\"1\":{\"97\":1}}],[\"对于union查询\",{\"1\":{\"97\":1}}],[\"对于我们日常的操作\",{\"1\":{\"80\":1}}],[\"对某一节点进行前插操作\",{\"1\":{\"37\":1}}],[\"结尾\",{\"1\":{\"421\":2}}],[\"结论\",{\"1\":{\"408\":1}}],[\"结果中\",{\"1\":{\"354\":1}}],[\"结果悲剧了\",{\"1\":{\"342\":1}}],[\"结束值\",{\"1\":{\"390\":1,\"391\":1}}],[\"结束\",{\"1\":{\"344\":1}}],[\"结构体中\",{\"1\":{\"454\":1}}],[\"结构图如下\",{\"1\":{\"430\":1}}],[\"结构\",{\"1\":{\"421\":1,\"441\":1}}],[\"结构来节省内存\",{\"1\":{\"419\":1}}],[\"结构会转换为\",{\"1\":{\"417\":1}}],[\"结构默认采用了\",{\"1\":{\"417\":1}}],[\"结构类似一个双端链表\",{\"1\":{\"416\":1}}],[\"结构类型\",{\"1\":{\"32\":1}}],[\"结构化\",{\"1\":{\"364\":1}}],[\"结构如下\",{\"1\":{\"338\":1}}],[\"结构与windows中安装的nginx基本一致\",{\"1\":{\"306\":1}}],[\"结构中\",{\"1\":{\"454\":1}}],[\"结构中的数据元素之间存在多对多的关系\",{\"1\":{\"33\":1}}],[\"结构中的数据元素之间存在一对多的关系\",{\"1\":{\"33\":1}}],[\"结构中的数据元素之间只存在一对一的关系\",{\"1\":{\"33\":1}}],[\"结构中元素同属于同一个集合\",{\"1\":{\"33\":1}}],[\"结合自己的想法\",{\"1\":{\"2\":1}}],[\"基于整数数组来实现\",{\"1\":{\"430\":1}}],[\"基于简单动态字符串\",{\"1\":{\"415\":1}}],[\"基于\",{\"1\":{\"409\":1,\"410\":1,\"422\":1}}],[\"基于心跳机制监测服务状态\",{\"1\":{\"325\":1}}],[\"基于内存\",{\"1\":{\"318\":1}}],[\"基于引用\",{\"1\":{\"283\":1}}],[\"基于时间\",{\"1\":{\"283\":1}}],[\"基于容量\",{\"1\":{\"283\":1}}],[\"基于字节流的传输层通信协议\",{\"1\":{\"14\":1}}],[\"基础知识\",{\"0\":{\"472\":1}}],[\"基础通用指令\",{\"0\":{\"361\":1},\"1\":{\"262\":1}}],[\"基础篇\",{\"1\":{\"170\":1}}],[\"基础概念\",{\"0\":{\"103\":1}}],[\"基数\",{\"1\":{\"132\":1}}],[\"基本一致\",{\"1\":{\"417\":1}}],[\"基本语法\",{\"0\":{\"240\":1}}],[\"基本查询\",{\"0\":{\"186\":1},\"1\":{\"185\":1}}],[\"基本的结构和节点的变化规律不变\",{\"1\":{\"119\":1}}],[\"基本数据类型\",{\"1\":{\"32\":1}}],[\"基本概念\",{\"0\":{\"32\":1,\"104\":1,\"425\":1,\"430\":1,\"435\":1,\"446\":1,\"451\":1}}],[\"第五章\",{\"0\":{\"581\":1}}],[\"第二章\",{\"0\":{\"580\":1}}],[\"第二种方法\",{\"1\":{\"29\":1}}],[\"第四章\",{\"0\":{\"579\":1}}],[\"第三章\",{\"0\":{\"578\":1}}],[\"第三方模块以及大多数的依赖项\",{\"1\":{\"304\":1}}],[\"第六章\",{\"0\":{\"554\":1}}],[\"第⼆层楼梯再跨⼀步就到第三层\",{\"1\":{\"521\":1}}],[\"第3个\",{\"1\":{\"296\":1,\"332\":1}}],[\"第2个\",{\"1\":{\"296\":1,\"332\":1}}],[\"第1个\",{\"1\":{\"296\":1,\"332\":1}}],[\"第\",{\"1\":{\"36\":1,\"503\":1,\"514\":1}}],[\"第一章\",{\"0\":{\"555\":1}}],[\"第一种方法也是我们能够快速想出来的方法\",{\"1\":{\"480\":1}}],[\"第一种方法我目前也没有理解\",{\"1\":{\"29\":1}}],[\"第一个哈希表没有找到\",{\"1\":{\"438\":1}}],[\"第一条sql使用id查询的效率更高\",{\"1\":{\"126\":1}}],[\"第一次发送的报文段\",{\"1\":{\"16\":1}}],[\"体积公式\",{\"1\":{\"29\":1}}],[\"列表对象\",{\"1\":{\"469\":1}}],[\"列表对象list\",{\"0\":{\"416\":1}}],[\"列表的节点之间并不是通过指针连接的\",{\"1\":{\"444\":1}}],[\"列表\",{\"0\":{\"378\":1},\"1\":{\"454\":1,\"467\":1}}],[\"列类型\",{\"1\":{\"364\":1}}],[\"列名列表\",{\"1\":{\"163\":3}}],[\"列存储数据库\",{\"1\":{\"109\":1}}],[\"列子查询指的是子查询的返回结果是一列\",{\"1\":{\"100\":1}}],[\"列子查询\",{\"0\":{\"100\":1},\"1\":{\"98\":1}}],[\"列式求和\",{\"1\":{\"28\":1}}],[\"列出内层语句的执行次数\",{\"1\":{\"25\":1,\"26\":1,\"27\":1}}],[\"列出外层循环中\",{\"1\":{\"25\":1,\"26\":1,\"27\":1}}],[\"列出循环次数\",{\"1\":{\"21\":1,\"22\":1,\"23\":1,\"24\":1}}],[\"方案二\",{\"1\":{\"356\":1}}],[\"方案一\",{\"1\":{\"356\":1}}],[\"方式\",{\"1\":{\"319\":1,\"355\":1}}],[\"方式二\",{\"1\":{\"295\":1,\"331\":1}}],[\"方式一\",{\"1\":{\"295\":1,\"331\":1}}],[\"方便了人们学习\",{\"1\":{\"577\":1}}],[\"方便我们快速找到想要的节点\",{\"1\":{\"450\":1}}],[\"方便于我们的优化\",{\"1\":{\"227\":1}}],[\"方便自己或者读者进行知识追溯\",{\"1\":{\"3\":1}}],[\"方法3️⃣\",{\"0\":{\"505\":1,\"528\":1}}],[\"方法\",{\"1\":{\"359\":1}}],[\"方法后测试结果\",{\"1\":{\"351\":1}}],[\"方法二\",{\"1\":{\"163\":1}}],[\"方法一\",{\"1\":{\"163\":1}}],[\"方法2️⃣\",{\"0\":{\"502\":1,\"525\":1}}],[\"方法2\",{\"0\":{\"538\":1},\"1\":{\"28\":1}}],[\"方法1️⃣\",{\"0\":{\"488\":1,\"499\":1,\"522\":1}}],[\"方法1\",{\"0\":{\"536\":1},\"1\":{\"28\":1}}],[\"三者之和\",{\"1\":{\"481\":2}}],[\"三者之和为0\",{\"1\":{\"481\":1}}],[\"三者的和\",{\"1\":{\"481\":1}}],[\"三数之和\",{\"0\":{\"476\":1},\"1\":{\"478\":1}}],[\"三个数即为我们所求的三个数\",{\"1\":{\"481\":1}}],[\"三个sentinel实例信息如下\",{\"1\":{\"330\":1}}],[\"三个字段建立联合索引\",{\"1\":{\"129\":1}}],[\"三层循环\",{\"0\":{\"28\":1}}],[\"三次握手是发生在tcp的连接过程中的\",{\"1\":{\"15\":1}}],[\"三次握手\",{\"0\":{\"15\":1}}],[\"$6\",{\"1\":{\"421\":1}}],[\"$4\",{\"1\":{\"421\":1}}],[\"$3\",{\"1\":{\"421\":1}}],[\"$5\",{\"1\":{\"421\":1}}],[\"$0\",{\"1\":{\"421\":1}}],[\"$2\",{\"1\":{\"340\":1}}],[\"$path\",{\"1\":{\"305\":1}}],[\"$$\",{\"1\":{\"240\":2}}],[\"$\",{\"1\":{\"27\":2,\"393\":4,\"421\":2,\"422\":2}}],[\"aeprocessevents\",{\"1\":{\"462\":3}}],[\"aeeventloop\",{\"1\":{\"462\":2}}],[\"aesetbeforesleepproc\",{\"1\":{\"462\":1}}],[\"aecreateeventloop\",{\"1\":{\"462\":1}}],[\"aemain\",{\"1\":{\"462\":3}}],[\"aeapiassociate\",{\"1\":{\"459\":1}}],[\"aeapiaddevent\",{\"1\":{\"459\":1,\"462\":2}}],[\"aeapilookuppending\",{\"1\":{\"459\":1}}],[\"aeapiname\",{\"1\":{\"459\":1}}],[\"aeapipoll\",{\"1\":{\"459\":1,\"460\":1,\"462\":1}}],[\"aeapidelevent\",{\"1\":{\"459\":1}}],[\"aeapifree\",{\"1\":{\"459\":1}}],[\"aeapiresize\",{\"1\":{\"459\":1}}],[\"aeapicreate\",{\"1\":{\"459\":1,\"462\":1}}],[\"ae\",{\"1\":{\"459\":6,\"462\":4}}],[\"amy\",{\"1\":{\"427\":1}}],[\"auth\",{\"1\":{\"351\":1,\"422\":2}}],[\"autowired\",{\"1\":{\"334\":1,\"360\":2}}],[\"autocommit\",{\"1\":{\"256\":3}}],[\"auto\",{\"1\":{\"232\":1,\"320\":2}}],[\"awk\",{\"1\":{\"340\":1}}],[\"aof\",{\"1\":{\"320\":21,\"321\":1,\"428\":1}}],[\"aof持久化\",{\"0\":{\"320\":1}}],[\"aof保持关闭状态\",{\"1\":{\"295\":1}}],[\"apache\",{\"1\":{\"360\":1}}],[\"appendfsync\",{\"1\":{\"320\":3}}],[\"appendfilename\",{\"1\":{\"320\":1}}],[\"append\",{\"1\":{\"320\":1}}],[\"appendonly\",{\"1\":{\"295\":1,\"320\":2}}],[\"application\",{\"1\":{\"306\":1,\"309\":1}}],[\"api\",{\"1\":{\"281\":1,\"309\":2,\"311\":1,\"358\":1,\"359\":1,\"412\":1,\"459\":2,\"462\":1}}],[\"artifactid>\",{\"1\":{\"334\":1,\"351\":2,\"353\":1,\"360\":2}}],[\"argv\",{\"1\":{\"462\":1}}],[\"argc\",{\"1\":{\"462\":1}}],[\"arg\",{\"1\":{\"383\":2,\"384\":4,\"422\":3}}],[\"args\",{\"1\":{\"307\":3,\"422\":4}}],[\"argument\",{\"1\":{\"381\":2}}],[\"argumentn\",{\"1\":{\"291\":2}}],[\"argument3\",{\"1\":{\"291\":2}}],[\"argument2\",{\"1\":{\"291\":2}}],[\"argument1\",{\"1\":{\"291\":2}}],[\"array\",{\"1\":{\"542\":1}}],[\"arraylist\",{\"0\":{\"473\":1}}],[\"arraylist<>\",{\"1\":{\"422\":1}}],[\"arrays\",{\"1\":{\"288\":1,\"482\":1,\"494\":2,\"543\":1}}],[\"arr\",{\"1\":{\"26\":1,\"27\":1,\"29\":1,\"288\":1,\"543\":6}}],[\"a\",{\"1\":{\"236\":1,\"289\":2,\"342\":1,\"349\":1,\"372\":1,\"432\":1}}],[\"age\",{\"1\":{\"210\":2,\"288\":1,\"354\":1,\"376\":1}}],[\"avg\",{\"1\":{\"185\":1,\"189\":1,\"454\":1}}],[\"asynchronous\",{\"1\":{\"401\":1}}],[\"associative\",{\"1\":{\"288\":1}}],[\"aside\",{\"1\":{\"275\":1}}],[\"asc|desc\",{\"1\":{\"396\":2}}],[\"asc\",{\"1\":{\"191\":1,\"211\":1}}],[\"as\",{\"1\":{\"163\":3,\"186\":2}}],[\"after=network\",{\"1\":{\"370\":1}}],[\"aftereach\",{\"1\":{\"351\":1}}],[\"after\",{\"1\":{\"155\":1,\"157\":1,\"158\":1,\"159\":1,\"326\":1,\"331\":1,\"462\":1}}],[\"ab公司开发的一款关系型数据库管理系统\",{\"1\":{\"104\":1}}],[\"always\",{\"1\":{\"320\":2}}],[\"alloc\",{\"1\":{\"426\":4}}],[\"allkeys\",{\"1\":{\"276\":3,\"456\":3}}],[\"all\",{\"1\":{\"97\":2,\"100\":2,\"166\":1,\"196\":2,\"229\":1,\"447\":2,\"462\":1}}],[\"alter\",{\"1\":{\"49\":2,\"50\":1,\"144\":1,\"163\":1,\"177\":2,\"178\":4,\"195\":1,\"196\":1}}],[\"adminstrator数据库管理员\",{\"1\":{\"195\":1}}],[\"adaptive\",{\"0\":{\"64\":1},\"1\":{\"64\":1}}],[\"addreplyprototolist\",{\"1\":{\"462\":1}}],[\"addreplytobuffer\",{\"1\":{\"462\":1}}],[\"addreply\",{\"1\":{\"462\":3}}],[\"add\",{\"1\":{\"49\":1,\"50\":1,\"55\":1,\"68\":1,\"178\":1,\"305\":1,\"344\":1,\"407\":1,\"422\":1,\"482\":4}}],[\"attempted\",{\"1\":{\"447\":1}}],[\"attribute\",{\"1\":{\"426\":5}}],[\"atomicity\",{\"1\":{\"74\":1,\"257\":1}}],[\"at\",{\"1\":{\"63\":1}}],[\"accept\",{\"1\":{\"462\":1}}],[\"accepttcphandler\",{\"1\":{\"462\":3}}],[\"access\",{\"1\":{\"426\":1}}],[\"active\",{\"1\":{\"360\":1}}],[\"action一致\",{\"1\":{\"50\":1}}],[\"action\",{\"1\":{\"50\":1,\"253\":2}}],[\"acid\",{\"1\":{\"74\":1,\"364\":1}}],[\"acknowledge\",{\"1\":{\"385\":1}}],[\"ack置为1\",{\"1\":{\"17\":1}}],[\"ack\",{\"1\":{\"15\":1,\"17\":2,\"385\":1}}],[\"anotherredisdesktopmanager\",{\"1\":{\"373\":2}}],[\"another\",{\"1\":{\"373\":1}}],[\"announce\",{\"1\":{\"295\":5,\"331\":1,\"339\":1}}],[\"anme\",{\"1\":{\"243\":1}}],[\"and\",{\"1\":{\"187\":2,\"349\":1,\"397\":1,\"426\":5,\"432\":3}}],[\"any\",{\"1\":{\"100\":2}}],[\"an\",{\"1\":{\"35\":1,\"432\":1}}],[\"ai+1\",{\"1\":{\"35\":1}}],[\"ai\",{\"1\":{\"35\":1,\"36\":1}}],[\"a2\",{\"1\":{\"35\":1}}],[\"a1\",{\"1\":{\"35\":1}}],[\"j指针指向数组末尾\",{\"1\":{\"481\":1}}],[\"jdkcollection\",{\"1\":{\"358\":1}}],[\"jdk\",{\"1\":{\"352\":1,\"358\":1}}],[\"jdies快速入门\",{\"0\":{\"348\":1},\"1\":{\"263\":1}}],[\"just\",{\"1\":{\"426\":1}}],[\"jupiter<\",{\"1\":{\"351\":2}}],[\"junit\",{\"1\":{\"351\":1}}],[\"jedis的官方地址\",{\"1\":{\"350\":1}}],[\"jedis是redis\",{\"1\":{\"349\":1}}],[\"jedis\",{\"1\":{\"347\":1,\"349\":1,\"350\":1,\"351\":10,\"358\":1}}],[\"jedispollconfig\",{\"1\":{\"347\":5}}],[\"jedispoolconfig\",{\"1\":{\"347\":3}}],[\"jedispool\",{\"1\":{\"347\":5}}],[\"jedisconnectionfactory\",{\"1\":{\"347\":1}}],[\"jedis本身是线程不安全的\",{\"1\":{\"347\":1}}],[\"jedis连接池\",{\"0\":{\"347\":1},\"1\":{\"263\":1}}],[\"json的\",{\"1\":{\"353\":1}}],[\"json参数\",{\"1\":{\"311\":2}}],[\"json\",{\"1\":{\"309\":2,\"354\":2,\"355\":1,\"356\":2,\"358\":1}}],[\"jsr\",{\"1\":{\"281\":2}}],[\"jackson\",{\"1\":{\"353\":4}}],[\"jack\",{\"1\":{\"288\":1,\"376\":1}}],[\"java语言的redis客户端\",{\"1\":{\"374\":1}}],[\"java8\",{\"1\":{\"280\":1,\"281\":1}}],[\"java全栈知识体系\",{\"1\":{\"266\":1}}],[\"java\",{\"0\":{\"8\":1,\"472\":1,\"474\":1,\"475\":1},\"1\":{\"281\":1,\"288\":2,\"349\":2,\"355\":1,\"365\":1}}],[\"jvm\",{\"1\":{\"283\":1}}],[\"jvm进程缓存\",{\"0\":{\"279\":1},\"1\":{\"264\":1}}],[\"jcache\",{\"1\":{\"281\":1}}],[\"join\",{\"1\":{\"94\":1,\"95\":2,\"96\":1}}],[\"j++\",{\"1\":{\"29\":1,\"494\":1,\"512\":1}}],[\"j\",{\"1\":{\"26\":5,\"27\":5,\"29\":4,\"36\":10,\"462\":3,\"477\":4,\"480\":1,\"481\":3,\"482\":14,\"491\":4,\"494\":3,\"512\":13,\"516\":2,\"517\":50,\"541\":1,\"543\":16}}],[\"mb\",{\"1\":{\"415\":1,\"421\":1}}],[\"multiplexing\",{\"1\":{\"401\":1}}],[\"multi\",{\"1\":{\"399\":1}}],[\"m|km|ft|mi\",{\"1\":{\"396\":3}}],[\"mq\",{\"1\":{\"385\":1}}],[\"mget\",{\"1\":{\"376\":1,\"422\":1}}],[\"msb\",{\"1\":{\"426\":1}}],[\"msg\",{\"1\":{\"422\":1}}],[\"mset\",{\"1\":{\"376\":1}}],[\"ms\",{\"1\":{\"347\":1}}],[\"mid+1\",{\"1\":{\"432\":1}}],[\"mid\",{\"1\":{\"432\":5}}],[\"milliseconds\",{\"1\":{\"326\":1,\"331\":1,\"392\":2,\"394\":2}}],[\"mime\",{\"1\":{\"306\":1}}],[\"mincostclimbingstairs2\",{\"1\":{\"538\":1}}],[\"mincostclimbingstairs\",{\"1\":{\"536\":1}}],[\"min\",{\"1\":{\"85\":1,\"86\":2,\"166\":1,\"185\":1,\"189\":1,\"320\":1,\"360\":1,\"380\":3,\"432\":5,\"534\":6,\"536\":3,\"538\":3}}],[\"mkdir\",{\"1\":{\"295\":1,\"310\":1,\"331\":1,\"339\":1,\"344\":1}}],[\"mdl锁主要作用是维护元数据的数据一致性\",{\"1\":{\"144\":1}}],[\"mdl加锁过程是系统自动控制\",{\"1\":{\"144\":1}}],[\"mdl\",{\"1\":{\"142\":1}}],[\"message\",{\"1\":{\"381\":1,\"385\":1,\"421\":1}}],[\"method\",{\"1\":{\"307\":1}}],[\"metadate\",{\"1\":{\"144\":1}}],[\"meta\",{\"1\":{\"142\":1}}],[\"member2\",{\"1\":{\"396\":1}}],[\"member1\",{\"1\":{\"396\":1}}],[\"member\",{\"1\":{\"379\":3,\"380\":5,\"396\":7,\"419\":4}}],[\"memcache\",{\"1\":{\"363\":1}}],[\"memcached\",{\"1\":{\"304\":1}}],[\"memory的缺陷就是对表的大小有限制\",{\"1\":{\"237\":1}}],[\"memory存储引擎的表数据存储在内存中\",{\"1\":{\"236\":1}}],[\"memory\",{\"0\":{\"236\":1},\"1\":{\"123\":1,\"236\":1,\"237\":1}}],[\"merge\",{\"1\":{\"206\":1,\"542\":1,\"543\":3}}],[\"myredisclient\",{\"1\":{\"422\":1}}],[\"myblog\",{\"1\":{\"376\":5}}],[\"mymaster\",{\"1\":{\"331\":5,\"334\":1}}],[\"myi\",{\"1\":{\"235\":1}}],[\"myisam是mysql早期的默认存储引擎\",{\"1\":{\"235\":1}}],[\"myisam引擎把一个表的总行数存在了磁盘上\",{\"1\":{\"219\":1}}],[\"myisam\",{\"0\":{\"235\":1},\"1\":{\"123\":1,\"236\":1,\"237\":1}}],[\"myd\",{\"1\":{\"235\":1}}],[\"my\",{\"1\":{\"227\":1,\"242\":1}}],[\"mystream\",{\"1\":{\"393\":2,\"394\":1}}],[\"mysaldump\",{\"1\":{\"140\":1}}],[\"mysql服务重新启动之后\",{\"1\":{\"242\":1}}],[\"mysql认为必须要执行查询的行数\",{\"1\":{\"229\":1}}],[\"mysql客户端连接成功后\",{\"1\":{\"226\":1}}],[\"mysql中默认不开启慢查询日志\",{\"1\":{\"227\":1}}],[\"mysql中定义了很多种权限\",{\"1\":{\"196\":1}}],[\"mysql中使用的是limit子句实现\",{\"1\":{\"192\":1}}],[\"mysql中内置了很多的字符串函数\",{\"1\":{\"53\":1}}],[\"mysql特有的语法\",{\"1\":{\"173\":1}}],[\"mysql数据库的sql语言不区分大小写\",{\"1\":{\"173\":1}}],[\"mysql数据模型\",{\"0\":{\"110\":1},\"1\":{\"110\":1}}],[\"mysql必知必会\",{\"1\":{\"171\":1}}],[\"mysql从入门到精通\",{\"1\":{\"171\":1}}],[\"mysql提供了两个选项\",{\"1\":{\"164\":1}}],[\"mysql允许基于另一个视图创建视图\",{\"1\":{\"164\":1}}],[\"mysql会通过视图检查正在更改的每个行\",{\"1\":{\"164\":1}}],[\"mysql目前只支持行级触发器\",{\"1\":{\"155\":1}}],[\"mysql管理\",{\"0\":{\"151\":1},\"1\":{\"170\":1}}],[\"mysqldump\",{\"1\":{\"139\":1}}],[\"mysql优化全囊括\",{\"1\":{\"171\":1}}],[\"mysql优化器会评估哪个字段的索引效率更高\",{\"1\":{\"133\":1}}],[\"mysql优化的b+树\",{\"1\":{\"120\":1}}],[\"mysql也不一定就会使用\",{\"1\":{\"133\":1}}],[\"mysql索引数据结构对经典的b+tree进行了优化\",{\"1\":{\"120\":1}}],[\"mysql的事务要么全部执行\",{\"1\":{\"399\":1}}],[\"mysql的体系结构示意图\",{\"1\":{\"231\":1}}],[\"mysql的体系结构\",{\"0\":{\"231\":1}}],[\"mysql的索引是在存储引擎层实现的\",{\"1\":{\"115\":1}}],[\"mysql的安装\",{\"0\":{\"105\":1}}],[\"mysql版本\",{\"0\":{\"106\":1}}],[\"mysql官方下载地址\",{\"1\":{\"105\":1}}],[\"mysql\",{\"0\":{\"169\":1},\"1\":{\"104\":1,\"105\":1,\"106\":2,\"195\":2,\"202\":1,\"227\":1,\"304\":1}}],[\"mysql实例在初始化时会自动创建两个默认的undo表空间\",{\"1\":{\"69\":1}}],[\"mysql5\",{\"1\":{\"59\":1}}],[\"mysql进阶\",{\"0\":{\"57\":1,\"77\":1,\"111\":1,\"135\":1,\"151\":1,\"152\":1,\"160\":1,\"197\":1,\"225\":1,\"230\":1,\"238\":1}}],[\"mysql运维\",{\"0\":{\"51\":1,\"87\":1,\"150\":1,\"168\":1}}],[\"mysql基础\",{\"0\":{\"44\":1,\"52\":1,\"88\":1,\"103\":1,\"172\":1,\"255\":1},\"1\":{\"170\":1}}],[\"mvcc的具体实现\",{\"1\":{\"79\":1}}],[\"mvcc全称为multi\",{\"1\":{\"79\":1}}],[\"mvcc多版本并发控制\",{\"0\":{\"77\":1}}],[\"mvcc\",{\"0\":{\"79\":1},\"1\":{\"76\":1,\"86\":2}}],[\"more\",{\"1\":{\"447\":1}}],[\"move\",{\"1\":{\"344\":1}}],[\"monitor\",{\"1\":{\"331\":2}}],[\"mongodb等\",{\"1\":{\"363\":1}}],[\"mongodb\",{\"1\":{\"109\":1,\"364\":1}}],[\"month\",{\"1\":{\"55\":1}}],[\"modify\",{\"1\":{\"178\":1}}],[\"mode\",{\"1\":{\"80\":1,\"144\":1,\"145\":2,\"339\":1}}],[\"mod\",{\"1\":{\"54\":1,\"407\":1}}],[\"math\",{\"1\":{\"488\":1,\"534\":5,\"536\":3,\"538\":3}}],[\"main\",{\"1\":{\"422\":1,\"462\":2}}],[\"mail\",{\"1\":{\"129\":5}}],[\"mask\",{\"1\":{\"405\":3}}],[\"mast\",{\"1\":{\"126\":1,\"310\":1}}],[\"master\",{\"1\":{\"73\":3,\"294\":1,\"300\":11,\"301\":3,\"302\":4,\"322\":2,\"324\":4,\"326\":2,\"327\":5,\"328\":1,\"334\":1,\"337\":4,\"338\":3,\"343\":1,\"344\":2,\"345\":5}}],[\"map\",{\"1\":{\"288\":4}}],[\"man\",{\"1\":{\"557\":1}}],[\"many\",{\"1\":{\"344\":1}}],[\"manager这款\",{\"1\":{\"373\":1}}],[\"manager\",{\"1\":{\"305\":1,\"373\":1}}],[\"management\",{\"1\":{\"104\":2}}],[\"manes\",{\"1\":{\"280\":1,\"281\":1}}],[\"manipulation\",{\"1\":{\"174\":1}}],[\"maxclients+config\",{\"1\":{\"462\":1}}],[\"maxevents\",{\"1\":{\"407\":1}}],[\"maxlen\",{\"1\":{\"387\":2}}],[\"maximumsize\",{\"1\":{\"283\":1}}],[\"maxmemory\",{\"1\":{\"273\":1}}],[\"max\",{\"1\":{\"85\":1,\"86\":2,\"166\":1,\"185\":1,\"189\":1,\"307\":2,\"360\":3,\"380\":3,\"415\":1,\"417\":2,\"418\":1,\"419\":2,\"432\":5,\"448\":2,\"488\":5}}],[\"maxsize\",{\"1\":{\"36\":3}}],[\"malloc\",{\"1\":{\"37\":2}}],[\"m\",{\"1\":{\"26\":10,\"85\":1,\"86\":1,\"307\":2,\"509\":6,\"512\":4,\"541\":11,\"543\":10}}],[\"的算法解决此问题吗\",{\"1\":{\"541\":1}}],[\"的长度为\",{\"1\":{\"541\":1}}],[\"的长度和\",{\"1\":{\"444\":1}}],[\"的初始长度为\",{\"1\":{\"541\":1}}],[\"的初始值\",{\"1\":{\"498\":1}}],[\"的台阶\",{\"1\":{\"532\":5}}],[\"的台阶开始\",{\"1\":{\"532\":2}}],[\"的台阶开始爬楼梯\",{\"1\":{\"532\":1}}],[\"的整数矩阵\",{\"1\":{\"514\":1}}],[\"的整个过程都是非阻塞的\",{\"1\":{\"412\":1}}],[\"的棋盘上巡视\",{\"1\":{\"514\":1}}],[\"的数组\",{\"1\":{\"484\":1}}],[\"的数\",{\"1\":{\"482\":1}}],[\"的数据只减不增\",{\"1\":{\"438\":1}}],[\"的数据\",{\"1\":{\"408\":2}}],[\"的数据到redis\",{\"1\":{\"352\":1}}],[\"的sds对象\",{\"1\":{\"462\":1}}],[\"的sql语句的cpu的使用情况\",{\"1\":{\"228\":1}}],[\"的sql语句各个阶段的耗时情况\",{\"1\":{\"228\":1}}],[\"的fd读事件\",{\"1\":{\"462\":1}}],[\"的影响\",{\"1\":{\"461\":1}}],[\"的影响或者\",{\"1\":{\"461\":1}}],[\"的响应\",{\"1\":{\"460\":1}}],[\"的响应式编程\",{\"1\":{\"358\":1}}],[\"的应用\",{\"1\":{\"460\":1}}],[\"的利用率\",{\"1\":{\"458\":1}}],[\"的版本迭代过程中\",{\"1\":{\"458\":1}}],[\"的核心业务部分\",{\"1\":{\"458\":1}}],[\"的访问次数之所以叫做逻辑访问次数\",{\"1\":{\"456\":1}}],[\"的访问频率\",{\"1\":{\"456\":1}}],[\"的每个事情循环前会调用beforesleep\",{\"1\":{\"455\":1}}],[\"的每一个节点都是一个\",{\"1\":{\"446\":1}}],[\"的频率来执行过期\",{\"1\":{\"455\":1}}],[\"的存活时间\",{\"1\":{\"455\":1}}],[\"的地方\",{\"1\":{\"454\":1}}],[\"的双端列表\",{\"1\":{\"449\":1}}],[\"的首尾各有\",{\"1\":{\"448\":2}}],[\"的最大内存大小\",{\"1\":{\"448\":1}}],[\"的所有数据都rehash到dict\",{\"1\":{\"438\":1}}],[\"的所有sql语句的日志\",{\"1\":{\"227\":1}}],[\"的entry链表rehash到dictht\",{\"1\":{\"438\":1}}],[\"的内存占用不能超过\",{\"1\":{\"448\":5}}],[\"的内存\",{\"1\":{\"438\":2}}],[\"的内存淘汰机制\",{\"1\":{\"274\":1}}],[\"的查询与\",{\"1\":{\"438\":1}}],[\"的哈希表\",{\"1\":{\"437\":1}}],[\"的哈希值hash\",{\"1\":{\"435\":1}}],[\"的进度\",{\"1\":{\"436\":1}}],[\"的指针\",{\"1\":{\"436\":2}}],[\"的编码\",{\"1\":{\"432\":1}}],[\"的范围内\",{\"1\":{\"430\":1}}],[\"的范围是否合法\",{\"1\":{\"36\":1}}],[\"的api\",{\"1\":{\"425\":1}}],[\"的新特性\",{\"1\":{\"421\":1}}],[\"的优势不明显\",{\"1\":{\"419\":1}}],[\"的优点是\",{\"1\":{\"398\":1}}],[\"的信号关联并设置回调\",{\"1\":{\"411\":1}}],[\"的默认模式\",{\"1\":{\"408\":1}}],[\"的作用\",{\"1\":{\"404\":1}}],[\"的监视\",{\"1\":{\"399\":1}}],[\"的状态变量\",{\"1\":{\"385\":1}}],[\"的结构如下所示\",{\"1\":{\"385\":1}}],[\"的操作\",{\"1\":{\"359\":1}}],[\"的发布订阅模型\",{\"1\":{\"358\":1}}],[\"的集成模块就叫做\",{\"1\":{\"358\":1}}],[\"的两种序列化实践方案\",{\"1\":{\"356\":1}}],[\"的过程\",{\"1\":{\"355\":1}}],[\"的序列化器为\",{\"1\":{\"356\":1}}],[\"的序列化方式默认就是\",{\"1\":{\"355\":1}}],[\"的序列化方式可以满足我们存储对象的需求\",{\"1\":{\"354\":1}}],[\"的序列化⽅式\",{\"1\":{\"353\":1}}],[\"的意见\",{\"1\":{\"345\":1}}],[\"的意义是什么\",{\"1\":{\"62\":1}}],[\"的一致性校验\",{\"1\":{\"345\":1}}],[\"的方式是根据\",{\"1\":{\"345\":1}}],[\"的有效部分计算哈希值\",{\"1\":{\"343\":1}}],[\"的有小部分计算插槽值\",{\"1\":{\"343\":1}}],[\"的三个作用是什么\",{\"1\":{\"328\":1}}],[\"的从节点\",{\"1\":{\"327\":1}}],[\"的客户端必须感知这种变化\",{\"1\":{\"334\":1}}],[\"的客户端\",{\"1\":{\"324\":1}}],[\"的命令记录的频率也可以通过\",{\"1\":{\"320\":1}}],[\"的缺点\",{\"1\":{\"319\":1}}],[\"的流程\",{\"1\":{\"319\":1}}],[\"的速度是非常快的\",{\"1\":{\"319\":1}}],[\"的机制\",{\"1\":{\"319\":1}}],[\"的文件名称\",{\"1\":{\"320\":1}}],[\"的文件\",{\"1\":{\"319\":1}}],[\"的非阻塞\",{\"1\":{\"304\":1}}],[\"的目标是让你的web服务直接跑在\",{\"1\":{\"304\":1}}],[\"的高性能\",{\"1\":{\"304\":1}}],[\"的大小\",{\"1\":{\"301\":1,\"448\":1}}],[\"的大小关系\",{\"1\":{\"300\":1}}],[\"的并发能力\",{\"1\":{\"293\":1}}],[\"的并发能力是有上限的\",{\"1\":{\"293\":1}}],[\"的几种方式\",{\"1\":{\"288\":1}}],[\"的创建是通过\",{\"1\":{\"288\":1}}],[\"的原型库并且\",{\"1\":{\"281\":1}}],[\"的\",{\"1\":{\"281\":2,\"288\":1,\"300\":3,\"309\":3,\"320\":1,\"325\":1,\"327\":1,\"334\":1,\"344\":1,\"346\":1,\"349\":1,\"358\":1,\"376\":1,\"385\":1,\"398\":1,\"403\":1,\"415\":1,\"416\":1,\"427\":1,\"438\":1,\"441\":1,\"454\":1}}],[\"的缓存\",{\"1\":{\"281\":1}}],[\"的性能成为整个系统的瓶颈\",{\"1\":{\"279\":1}}],[\"的性能\",{\"1\":{\"273\":1}}],[\"的ttl添加随机值\",{\"1\":{\"271\":1}}],[\"的时候\",{\"1\":{\"219\":1,\"455\":1}}],[\"的时候会直接返回这个数\",{\"1\":{\"219\":1}}],[\"的系列课程\",{\"1\":{\"171\":1,\"266\":1}}],[\"的争用以外\",{\"1\":{\"136\":1}}],[\"的索引\",{\"1\":{\"127\":2}}],[\"的工作压力\",{\"1\":{\"73\":1}}],[\"的元素需要比较的平均次数为\",{\"1\":{\"36\":1}}],[\"的元素\",{\"1\":{\"36\":1}}],[\"的线性表中查找值为\",{\"1\":{\"36\":1}}],[\"的线性表中删除一个结点时\",{\"1\":{\"36\":1}}],[\"的线性表中插入一个结点时\",{\"1\":{\"36\":1}}],[\"的位置\",{\"1\":{\"205\":1}}],[\"的位置是否合法\",{\"1\":{\"36\":1}}],[\"的位置不合法\",{\"1\":{\"36\":1}}],[\"的第\",{\"1\":{\"36\":1}}],[\"的变化量\",{\"1\":{\"25\":1,\"26\":1,\"27\":1}}],[\"的关系式为\",{\"1\":{\"22\":1}}],[\"的关系\",{\"1\":{\"21\":1,\"22\":1,\"23\":1,\"24\":1}}],[\"​=2n+1​\",{\"1\":{\"36\":1}}],[\"​=2n−1​\",{\"1\":{\"36\":1}}],[\"​=2n​\",{\"1\":{\"36\":1}}],[\"​=21​\",{\"1\":{\"29\":1}}],[\"​+2n\",{\"1\":{\"29\":1}}],[\"​\",{\"1\":{\"24\":1,\"29\":1}}],[\"6322\",{\"0\":{\"513\":1},\"1\":{\"515\":1}}],[\"6379\",{\"1\":{\"295\":3,\"339\":5,\"344\":1,\"347\":1,\"351\":1,\"360\":1,\"372\":1,\"422\":1}}],[\"62\",{\"0\":{\"508\":1},\"1\":{\"510\":1}}],[\"64\",{\"1\":{\"416\":1,\"419\":1,\"426\":1,\"448\":1}}],[\"64mb\",{\"1\":{\"320\":1}}],[\"64tb\",{\"1\":{\"236\":1}}],[\"618\",{\"1\":{\"318\":1}}],[\"65\",{\"1\":{\"306\":1}}],[\"666\",{\"1\":{\"298\":1}}],[\"60000\",{\"1\":{\"331\":1}}],[\"60\",{\"1\":{\"295\":1,\"319\":4}}],[\"6版本以后✅\",{\"1\":{\"123\":1}}],[\"6n\",{\"1\":{\"29\":1}}],[\"6\",{\"0\":{\"562\":1},\"1\":{\"24\":1,\"126\":1,\"129\":2,\"193\":1,\"201\":2,\"281\":1,\"295\":6,\"341\":1,\"370\":2,\"382\":1,\"421\":2,\"430\":2,\"460\":1,\"461\":1,\"466\":1,\"509\":1,\"514\":2,\"532\":3,\"541\":4}}],[\"较难\",{\"0\":{\"24\":1}}],[\"objencoding\",{\"1\":{\"466\":1}}],[\"object>\",{\"1\":{\"353\":2}}],[\"object\",{\"1\":{\"144\":3,\"145\":2,\"352\":2,\"354\":2,\"360\":1,\"415\":1,\"422\":3}}],[\"obj\",{\"1\":{\"419\":1,\"422\":12,\"462\":5,\"466\":10,\"467\":5}}],[\"override\",{\"1\":{\"334\":1}}],[\"ok\",{\"1\":{\"307\":4,\"351\":1,\"421\":1,\"462\":1}}],[\"octet\",{\"1\":{\"306\":1}}],[\"of\",{\"1\":{\"349\":1,\"426\":7,\"432\":2,\"447\":5}}],[\"offset\",{\"1\":{\"300\":6,\"302\":4,\"326\":1,\"345\":2,\"397\":1,\"447\":3}}],[\"ofseconds\",{\"1\":{\"283\":1}}],[\"outputstreamwriter\",{\"1\":{\"422\":1}}],[\"out\",{\"1\":{\"246\":2,\"282\":2,\"351\":2,\"354\":1,\"360\":1,\"422\":4}}],[\"outer\",{\"1\":{\"95\":2}}],[\"op\",{\"1\":{\"407\":1}}],[\"opsforzset\",{\"1\":{\"359\":1}}],[\"opsforset\",{\"1\":{\"359\":1}}],[\"opsforlist\",{\"1\":{\"359\":1}}],[\"opsforhash\",{\"1\":{\"359\":1}}],[\"opsforvalue\",{\"1\":{\"334\":2,\"354\":2,\"359\":2,\"360\":2}}],[\"ops\",{\"1\":{\"356\":1}}],[\"opm\",{\"1\":{\"305\":3}}],[\"opm是openresty的一个管理工具\",{\"1\":{\"305\":1}}],[\"openssl\",{\"1\":{\"305\":1}}],[\"openresty获取请求参数\",{\"0\":{\"311\":1}}],[\"openresty快速入门\",{\"0\":{\"308\":1}}],[\"openresty底层是基于nginx的\",{\"1\":{\"306\":1}}],[\"openresty就是在nginx基础上集成了一些lua模块\",{\"1\":{\"305\":1}}],[\"openresty安装的目录是\",{\"1\":{\"305\":1}}],[\"openresty官网\",{\"1\":{\"304\":1}}],[\"openresty®\",{\"1\":{\"304\":3}}],[\"openresty\",{\"1\":{\"304\":3,\"305\":9,\"306\":1,\"307\":2,\"309\":3,\"311\":1}}],[\"open\",{\"1\":{\"252\":2}}],[\"operate\",{\"1\":{\"157\":1,\"158\":1,\"159\":1}}],[\"options\",{\"1\":{\"372\":1}}],[\"optional\",{\"1\":{\"291\":2}}],[\"option\",{\"1\":{\"163\":3,\"164\":1}}],[\"old表示将要或者已经删除的数据\",{\"1\":{\"154\":1}}],[\"old表示修改之前的数据\",{\"1\":{\"154\":1}}],[\"org\",{\"1\":{\"286\":1,\"304\":1,\"305\":1}}],[\"organized\",{\"1\":{\"204\":1}}],[\"or\",{\"1\":{\"163\":2,\"187\":1,\"393\":2,\"397\":2,\"447\":2}}],[\"order\",{\"0\":{\"208\":1},\"1\":{\"134\":1,\"184\":1,\"185\":1,\"191\":1,\"193\":1,\"210\":1}}],[\"or连接的条件\",{\"1\":{\"129\":1}}],[\"oracle\",{\"1\":{\"109\":1}}],[\"one\",{\"1\":{\"289\":1,\"327\":1,\"328\":1}}],[\"only\",{\"1\":{\"109\":1,\"144\":1,\"320\":1,\"363\":1}}],[\"on\",{\"1\":{\"50\":2,\"94\":1,\"95\":2,\"96\":1,\"127\":2,\"132\":1,\"155\":1,\"157\":1,\"158\":1,\"159\":1,\"196\":2,\"306\":1,\"319\":1}}],[\"o\",{\"1\":{\"23\":1,\"24\":1,\"26\":1,\"27\":1,\"29\":1,\"30\":2,\"36\":11,\"37\":2,\"136\":1,\"304\":1,\"405\":1,\"427\":1,\"438\":9,\"440\":1,\"444\":1,\"450\":1,\"489\":2,\"501\":2,\"504\":2,\"507\":2,\"524\":2,\"527\":2,\"530\":2,\"537\":2,\"539\":2,\"541\":1}}],[\"时采用了多线程\",{\"1\":{\"461\":1}}],[\"时执行该语句块\",{\"1\":{\"290\":2}}],[\"时会if中的代码块会被执行\",{\"1\":{\"290\":1}}],[\"时会重复执行循环体语句\",{\"1\":{\"289\":1}}],[\"时\",{\"1\":{\"37\":1,\"132\":1,\"290\":1,\"302\":1,\"319\":1,\"381\":1,\"404\":2,\"437\":1,\"460\":1,\"470\":1,\"482\":2,\"484\":2}}],[\"时复杂度为\",{\"1\":{\"36\":1}}],[\"时间为2秒钟\",{\"1\":{\"227\":1}}],[\"时间值加上一个时间间隔expr后的时间值\",{\"1\":{\"55\":1}}],[\"时间内找到指定的元素\",{\"1\":{\"36\":1}}],[\"时间复杂度会很高\",{\"1\":{\"450\":1}}],[\"时间复杂度为\",{\"1\":{\"36\":5}}],[\"时间复杂度计算这个视频\",{\"1\":{\"20\":1}}],[\"时间复杂度\",{\"0\":{\"20\":1},\"1\":{\"489\":1,\"501\":1,\"504\":1,\"507\":1,\"524\":1,\"527\":1,\"530\":1,\"537\":1,\"539\":1}}],[\"时退出循环\",{\"1\":{\"23\":1}}],[\"当点位的值+1\",{\"1\":{\"516\":1}}],[\"当计算机网络中的某个计算机系统负荷过重时\",{\"1\":{\"575\":1}}],[\"当计算移动到一个网格的路径时需要依赖到达上边网格的路径数\",{\"1\":{\"511\":1}}],[\"当计数器为\",{\"1\":{\"470\":1}}],[\"当走到第一列时\",{\"1\":{\"511\":1}}],[\"当走到第一行时\",{\"1\":{\"511\":1}}],[\"当使用完一个对象后\",{\"1\":{\"470\":1}}],[\"当使用with\",{\"1\":{\"164\":1}}],[\"当新创建一个对象时\",{\"1\":{\"470\":1}}],[\"当客户端可写时\",{\"1\":{\"460\":1}}],[\"当客户端\",{\"1\":{\"460\":2}}],[\"当loadfactor小于0\",{\"1\":{\"439\":1}}],[\"当loadfactor大于5或者loadfactor大于1并且没有子进程任务时\",{\"1\":{\"439\":1}}],[\"当集合中元素较多时\",{\"1\":{\"437\":1}}],[\"当集群中有一个\",{\"1\":{\"345\":1}}],[\"当集群发生故障转移时\",{\"1\":{\"324\":1}}],[\"当哈希表保存的键值对太多或者太少时\",{\"1\":{\"437\":1}}],[\"当我们向\",{\"1\":{\"436\":1}}],[\"当在一个\",{\"1\":{\"432\":1}}],[\"当在父表中删除对应记录时\",{\"1\":{\"50\":1}}],[\"当在父表中删除\",{\"1\":{\"50\":3}}],[\"当一个集合只包含整数值元素\",{\"1\":{\"430\":1}}],[\"当一个缓存元素过期的时候\",{\"1\":{\"283\":1}}],[\"当元素数量不多时\",{\"1\":{\"419\":1}}],[\"当元素数量小于512并且元素大小小于\",{\"1\":{\"416\":1}}],[\"当存储的所有数据都是整数\",{\"1\":{\"418\":1}}],[\"当存储空间已满时\",{\"1\":{\"36\":1}}],[\"当数据量较大时\",{\"1\":{\"417\":1}}],[\"当数据准备就绪以后\",{\"1\":{\"402\":1}}],[\"当有大量\",{\"1\":{\"411\":1}}],[\"当有新消息通过\",{\"1\":{\"381\":1}}],[\"当内核有\",{\"1\":{\"411\":1}}],[\"当内存使用超过配置的时候会返回错误\",{\"1\":{\"276\":1,\"456\":1}}],[\"当内存不足时自动淘汰部分数据\",{\"1\":{\"274\":1}}],[\"当然也包括网络套接字\",{\"1\":{\"404\":1}}],[\"当进程运行在用户空间时称为用户态\",{\"1\":{\"401\":1}}],[\"当要存储\",{\"1\":{\"355\":1}}],[\"当故障节点恢复后会自动成为新的\",{\"1\":{\"327\":1}}],[\"当故障实例恢复后也以新的\",{\"1\":{\"324\":1}}],[\"当选中了其中一个\",{\"1\":{\"327\":1}}],[\"当主进程需要对所有的数据都进行修改时\",{\"1\":{\"319\":1}}],[\"当主进程执行写操作时\",{\"1\":{\"319\":1}}],[\"当主进程执行读操作时\",{\"1\":{\"319\":1}}],[\"当子进程写新的\",{\"1\":{\"319\":1}}],[\"当向缓存中一个已经过时的元素进行访问的时候将会进行异步刷新\",{\"1\":{\"281\":1}}],[\"当达到最大容量的时候可以使用基于就近度和频率的算法进行基于容量的驱逐\",{\"1\":{\"281\":1}}],[\"当满足条件的时候推出循环\",{\"1\":{\"250\":1}}],[\"当页中删除的记录达到merge\",{\"1\":{\"206\":1}}],[\"当删除一行记录时\",{\"1\":{\"206\":1}}],[\"当对一个对象进行共享时\",{\"1\":{\"470\":1}}],[\"当对一张表进行增删改查的时候\",{\"1\":{\"144\":1}}],[\"当对表结构进行变更操作的时候\",{\"1\":{\"144\":1}}],[\"当优化器知道每列是否包含null值时\",{\"1\":{\"134\":1}}],[\"当字段类型为字符串\",{\"1\":{\"132\":1}}],[\"当前\",{\"1\":{\"393\":1,\"432\":1}}],[\"当前表与自身的连接查询\",{\"1\":{\"96\":1}}],[\"当前最大事务id+1\",{\"1\":{\"85\":1}}],[\"当前活跃的事务id集合\",{\"1\":{\"85\":1}}],[\"当前读\",{\"0\":{\"80\":1}}],[\"当insert的时候\",{\"1\":{\"83\":1}}],[\"当执行rolback时\",{\"1\":{\"76\":1}}],[\"当update一条记录时\",{\"1\":{\"76\":1}}],[\"当事务提交之后会把所有的修改信息都存到该日志文件中\",{\"1\":{\"75\":1}}],[\"当事务提交之后会把所有修改信息都存到该日志中\",{\"1\":{\"72\":1}}],[\"当n=0时线性表是一个空表\",{\"1\":{\"35\":1}}],[\"当\",{\"1\":{\"23\":1,\"319\":1,\"408\":3,\"437\":1,\"484\":2}}],[\"45nc\",{\"1\":{\"546\":1}}],[\"45\",{\"1\":{\"519\":1}}],[\"455\",{\"0\":{\"490\":1},\"1\":{\"493\":1}}],[\"44\",{\"1\":{\"415\":1}}],[\"4999\",{\"1\":{\"376\":1}}],[\"4版本\",{\"1\":{\"341\":1}}],[\"404\",{\"1\":{\"307\":1}}],[\"4gb\",{\"1\":{\"273\":2}}],[\"4\",{\"0\":{\"297\":1,\"560\":1,\"576\":1},\"1\":{\"73\":2,\"193\":1,\"201\":2,\"295\":6,\"341\":1,\"353\":1,\"377\":1,\"421\":1,\"422\":3,\"426\":1,\"430\":4,\"442\":1,\"448\":2,\"456\":2,\"465\":3,\"466\":1,\"467\":1,\"477\":3,\"496\":2,\"509\":1,\"514\":2,\"532\":1}}],[\"4n2​\",{\"1\":{\"23\":1}}],[\"4次及4次以上\",{\"1\":{\"16\":1}}],[\"次行动是无效的\",{\"1\":{\"514\":1}}],[\"次行动后的位置\",{\"1\":{\"514\":1}}],[\"次即可得到第\",{\"1\":{\"506\":1}}],[\"次修改则触发\",{\"1\":{\"319\":1}}],[\"次\",{\"1\":{\"22\":1,\"36\":1,\"529\":2}}],[\"和通信处理机\",{\"1\":{\"569\":1}}],[\"和f\",{\"1\":{\"498\":1}}],[\"和dict\",{\"1\":{\"438\":1}}],[\"和linkedlist\",{\"1\":{\"416\":1}}],[\"和对应的内容\",{\"1\":{\"385\":1}}],[\"和非nil为真\",{\"1\":{\"290\":1}}],[\"和asyncloadingcache\",{\"1\":{\"281\":1}}],[\"和缓存雪崩不同的是\",{\"1\":{\"272\":1}}],[\"和前面的数据修改相同\",{\"1\":{\"182\":1}}],[\"和创建视图一致\",{\"1\":{\"163\":1}}],[\"和数据表的记录总数的比值\",{\"1\":{\"132\":1}}],[\"和步骤2合并一起\",{\"1\":{\"26\":1,\"27\":1}}],[\"和\",{\"1\":{\"22\":1,\"33\":1,\"76\":1,\"190\":1,\"205\":1,\"243\":1,\"281\":1,\"288\":1,\"291\":1,\"300\":1,\"324\":1,\"353\":2,\"354\":1,\"355\":2,\"358\":1,\"377\":1,\"381\":1,\"404\":1,\"407\":1,\"417\":1,\"419\":3,\"421\":1,\"438\":1,\"453\":1,\"454\":3,\"477\":1,\"496\":1,\"498\":4,\"521\":5,\"534\":1,\"541\":6}}],[\"k分别指向三个数\",{\"1\":{\"480\":1}}],[\"kqueue\",{\"1\":{\"459\":1}}],[\"know\",{\"1\":{\"432\":2}}],[\"kb\",{\"1\":{\"398\":1,\"448\":5}}],[\"kill\",{\"1\":{\"340\":1,\"384\":1}}],[\"keepalive\",{\"1\":{\"306\":1,\"307\":1}}],[\"key2\",{\"1\":{\"379\":3}}],[\"key1\",{\"1\":{\"379\":3}}],[\"keys\",{\"1\":{\"361\":1,\"454\":3}}],[\"key是查询的key\",{\"1\":{\"307\":1}}],[\"key约束\",{\"1\":{\"234\":1}}],[\"key优化\",{\"0\":{\"203\":1}}],[\"key\",{\"1\":{\"47\":2,\"49\":3,\"50\":1,\"109\":1,\"146\":1,\"229\":3,\"232\":1,\"271\":2,\"272\":2,\"281\":1,\"282\":1,\"288\":2,\"307\":6,\"319\":3,\"320\":1,\"334\":8,\"343\":9,\"344\":1,\"352\":3,\"353\":1,\"355\":2,\"365\":1,\"376\":1,\"377\":2,\"378\":5,\"379\":4,\"380\":9,\"383\":2,\"384\":4,\"385\":1,\"386\":2,\"387\":2,\"388\":2,\"389\":2,\"390\":2,\"391\":2,\"392\":3,\"393\":5,\"394\":3,\"396\":10,\"397\":1,\"398\":1,\"399\":6,\"418\":1,\"419\":1,\"425\":1,\"435\":3,\"436\":2,\"438\":2,\"454\":11,\"455\":5,\"456\":3}}],[\"k++\",{\"1\":{\"29\":1,\"482\":1,\"543\":1}}],[\"k\",{\"1\":{\"22\":1,\"23\":2,\"29\":3,\"477\":4,\"481\":2,\"482\":11,\"543\":4}}],[\"3个孩子的胃口值分别是\",{\"1\":{\"491\":1}}],[\"32\",{\"1\":{\"401\":1,\"405\":2,\"426\":1,\"448\":1,\"451\":1,\"453\":1}}],[\"3600\",{\"1\":{\"295\":1}}],[\"3000\",{\"1\":{\"344\":2,\"477\":1}}],[\"300\",{\"1\":{\"295\":1,\"319\":2}}],[\"30\",{\"1\":{\"273\":1,\"496\":1}}],[\"3种特殊数据类型\",{\"0\":{\"395\":1},\"1\":{\"262\":1}}],[\"3\",{\"0\":{\"28\":1,\"34\":1,\"145\":1,\"296\":1,\"307\":1,\"559\":1,\"567\":1,\"571\":1,\"572\":1,\"573\":1,\"574\":1,\"575\":2,\"576\":1,\"577\":1},\"1\":{\"22\":2,\"23\":1,\"24\":3,\"26\":1,\"27\":2,\"193\":1,\"201\":2,\"272\":2,\"282\":2,\"351\":1,\"353\":1,\"364\":1,\"405\":1,\"407\":1,\"416\":2,\"422\":5,\"426\":6,\"430\":1,\"442\":1,\"448\":1,\"466\":1,\"467\":4,\"477\":3,\"491\":3,\"496\":6,\"503\":1,\"509\":8,\"514\":3,\"519\":2,\"521\":1,\"523\":1,\"526\":1,\"529\":2,\"534\":1,\"541\":7,\"549\":1,\"566\":1}}],[\"<element>\",{\"1\":{\"398\":1}}],[\"<scope>test<\",{\"1\":{\"351\":1}}],[\"<version>5\",{\"1\":{\"351\":1}}],[\"<version>4\",{\"1\":{\"351\":1}}],[\"<artifactid>commons\",{\"1\":{\"360\":1}}],[\"<artifactid>jackson\",{\"1\":{\"353\":1}}],[\"<artifactid>junit\",{\"1\":{\"351\":1}}],[\"<artifactid>jedis<\",{\"1\":{\"351\":1}}],[\"<artifactid>spring\",{\"1\":{\"334\":1,\"360\":1}}],[\"<groupid>com\",{\"1\":{\"353\":1}}],[\"<groupid>redis\",{\"1\":{\"351\":1}}],[\"<groupid>org\",{\"1\":{\"334\":1,\"351\":1,\"360\":2}}],[\"<dependency>\",{\"1\":{\"334\":1,\"351\":2,\"353\":1,\"360\":2}}],[\"<masterport>\",{\"1\":{\"297\":2}}],[\"<masterip>\",{\"1\":{\"297\":2}}],[\"<执行体>\",{\"1\":{\"289\":1}}],[\"<>或者\",{\"1\":{\"187\":1}}],[\"<=\",{\"1\":{\"29\":3,\"36\":1,\"86\":2,\"99\":1,\"187\":1,\"422\":1,\"477\":4,\"484\":4,\"488\":5,\"496\":2,\"509\":2,\"514\":3,\"519\":2,\"532\":4,\"541\":6}}],[\"<\",{\"1\":{\"22\":1,\"24\":1,\"26\":2,\"27\":2,\"36\":4,\"86\":1,\"99\":1,\"121\":1,\"129\":1,\"187\":1,\"221\":2,\"334\":1,\"351\":4,\"353\":2,\"360\":4,\"422\":1,\"432\":4,\"437\":1,\"456\":1,\"462\":1,\"481\":2,\"482\":4,\"494\":2,\"500\":1,\"503\":2,\"506\":2,\"512\":2,\"514\":1,\"517\":16,\"523\":1,\"526\":2,\"529\":2,\"536\":1,\"538\":1,\"543\":6}}],[\"0=off\",{\"1\":{\"447\":1}}],[\"01\",{\"1\":{\"442\":1}}],[\"0001~1101\",{\"1\":{\"442\":1}}],[\"00\",{\"1\":{\"442\":1}}],[\"0则继续\",{\"1\":{\"436\":1}}],[\"0则可以在任意ip访问\",{\"1\":{\"369\":1}}],[\"0结尾的char\",{\"1\":{\"428\":1}}],[\"0结尾\",{\"1\":{\"425\":1}}],[\"0不阻塞\",{\"1\":{\"407\":1}}],[\"0代表未就绪\",{\"1\":{\"405\":1}}],[\"0或1\",{\"1\":{\"397\":1}}],[\"0开始对网络请求启用多线程\",{\"1\":{\"365\":1}}],[\"0<\",{\"1\":{\"351\":1}}],[\"0~16383\",{\"1\":{\"343\":1}}],[\"0之后hmset可以弃用了\",{\"1\":{\"377\":1}}],[\"0之后集群管理命令都集成到了redis\",{\"1\":{\"341\":1}}],[\"0之前集群命令都是用redis安装包下的src\",{\"1\":{\"341\":1}}],[\"0之前\",{\"1\":{\"341\":1}}],[\"0之前创建集群比较麻烦\",{\"1\":{\"341\":1}}],[\"0以后\",{\"1\":{\"341\":1}}],[\"0以后新增命令replicaof\",{\"1\":{\"297\":1}}],[\"0以前\",{\"1\":{\"297\":1}}],[\"0\",{\"1\":{\"22\":3,\"23\":1,\"24\":5,\"26\":5,\"27\":6,\"29\":1,\"36\":7,\"37\":1,\"63\":1,\"256\":2,\"290\":1,\"293\":2,\"326\":1,\"339\":4,\"347\":2,\"351\":1,\"360\":1,\"361\":1,\"369\":11,\"372\":4,\"385\":1,\"393\":2,\"401\":1,\"404\":1,\"405\":1,\"406\":2,\"421\":3,\"422\":5,\"426\":1,\"432\":18,\"437\":2,\"438\":4,\"439\":2,\"448\":1,\"454\":1,\"456\":1,\"458\":2,\"461\":1,\"462\":3,\"465\":1,\"467\":1,\"470\":1,\"477\":21,\"481\":5,\"482\":7,\"484\":2,\"488\":6,\"494\":3,\"496\":6,\"498\":3,\"503\":5,\"506\":6,\"511\":2,\"512\":14,\"514\":5,\"516\":4,\"517\":25,\"529\":4,\"532\":3,\"534\":3,\"536\":3,\"538\":8,\"541\":10,\"543\":8}}],[\"n的平方\",{\"1\":{\"469\":1}}],[\"n$3\",{\"1\":{\"421\":1}}],[\"n小鹏\",{\"1\":{\"421\":1}}],[\"nname\",{\"1\":{\"421\":1}}],[\"nset\",{\"1\":{\"421\":1}}],[\"nhello\",{\"1\":{\"421\":1}}],[\"nfds\",{\"1\":{\"405\":1,\"406\":2}}],[\"nfdbits\",{\"1\":{\"405\":1}}],[\"ngx\",{\"1\":{\"307\":14,\"310\":2,\"311\":2}}],[\"nginx本地缓存\",{\"0\":{\"317\":1}}],[\"nginx的默认配置文件注释太多\",{\"1\":{\"306\":1}}],[\"nginx\",{\"1\":{\"304\":6,\"305\":4,\"306\":6,\"308\":1,\"309\":2,\"310\":2}}],[\"nult\",{\"1\":{\"405\":1}}],[\"null约束\",{\"1\":{\"221\":2}}],[\"null约束它\",{\"1\":{\"134\":1}}],[\"null值不参与所有聚合函数运算\",{\"1\":{\"189\":1}}],[\"null\",{\"1\":{\"37\":2,\"47\":1,\"50\":1,\"157\":1,\"158\":1,\"159\":1,\"187\":1,\"229\":1,\"282\":1,\"307\":1,\"351\":1,\"405\":2,\"418\":1,\"422\":5,\"426\":4,\"517\":3}}],[\"nums2\",{\"1\":{\"541\":9,\"543\":10}}],[\"nums1\",{\"1\":{\"541\":14,\"543\":17}}],[\"nums\",{\"1\":{\"477\":21,\"481\":6,\"482\":26,\"484\":9,\"488\":10}}],[\"numevents\",{\"1\":{\"462\":2}}],[\"numkeys\",{\"1\":{\"383\":1,\"384\":2}}],[\"num\",{\"1\":{\"288\":1,\"298\":5,\"342\":2,\"343\":3,\"344\":2,\"376\":1,\"422\":1,\"506\":2,\"529\":2,\"538\":3}}],[\"number\",{\"1\":{\"288\":1,\"447\":1}}],[\"nil\",{\"1\":{\"288\":2,\"307\":2}}],[\"nage\",{\"1\":{\"421\":1}}],[\"native\",{\"1\":{\"195\":1}}],[\"name这个指令的返回结果应该是\",{\"1\":{\"352\":1}}],[\"name`\",{\"1\":{\"202\":1}}],[\"name字段创建的有索引\",{\"1\":{\"126\":1}}],[\"name\",{\"1\":{\"68\":5,\"126\":1,\"127\":10,\"132\":1,\"144\":1,\"145\":2,\"155\":5,\"199\":1,\"200\":3,\"202\":1,\"210\":2,\"243\":7,\"288\":3,\"291\":2,\"306\":1,\"310\":1,\"334\":2,\"352\":2,\"354\":1,\"360\":4,\"376\":2,\"393\":2,\"394\":2,\"422\":7,\"447\":1}}],[\"nrtj\",{\"1\":{\"171\":1}}],[\"n个指针\",{\"1\":{\"118\":1}}],[\"never\",{\"1\":{\"426\":1,\"432\":1}}],[\"newenc\",{\"1\":{\"432\":2}}],[\"newbuilder\",{\"1\":{\"282\":1,\"283\":2}}],[\"new\",{\"1\":{\"157\":3,\"158\":3,\"159\":3,\"347\":2,\"351\":1,\"353\":3,\"354\":1,\"422\":8,\"482\":2,\"488\":1,\"503\":1,\"506\":1,\"512\":1,\"517\":8,\"526\":1,\"529\":1,\"536\":1,\"538\":1,\"543\":1}}],[\"new表示将要或已经修改后的数据\",{\"1\":{\"154\":1}}],[\"new表示将要或者已经新增的数据\",{\"1\":{\"154\":1}}],[\"new和old\",{\"1\":{\"154\":1}}],[\"neo4j\",{\"1\":{\"109\":1,\"364\":1}}],[\"next\",{\"1\":{\"37\":2,\"146\":1,\"436\":1,\"447\":1}}],[\"noack\",{\"1\":{\"394\":1}}],[\"nosql数据库的常见种类\",{\"1\":{\"364\":1}}],[\"nosql与sql\",{\"0\":{\"364\":1}}],[\"nosql是一项全新的数据库革命性运动\",{\"1\":{\"363\":1}}],[\"nosql仅仅是一个概念\",{\"1\":{\"363\":1}}],[\"nosql最常见的解释是\",{\"1\":{\"363\":1}}],[\"nosql\",{\"1\":{\"363\":1,\"364\":1}}],[\"nobody\",{\"1\":{\"306\":1}}],[\"noeviction\",{\"1\":{\"276\":1,\"456\":1}}],[\"nonblocking\",{\"1\":{\"401\":1}}],[\"non\",{\"1\":{\"58\":1,\"109\":1,\"363\":1}}],[\"now\",{\"1\":{\"55\":1}}],[\"no\",{\"1\":{\"50\":1,\"144\":1,\"254\":1,\"295\":1,\"320\":2,\"327\":1,\"328\":1,\"339\":1,\"344\":1}}],[\"note\",{\"1\":{\"426\":1}}],[\"not\",{\"1\":{\"47\":1,\"100\":2,\"101\":1,\"176\":1,\"187\":1,\"253\":1,\"307\":5,\"363\":1,\"397\":2,\"432\":1,\"447\":1}}],[\"nodes\",{\"1\":{\"334\":1,\"339\":1,\"341\":1,\"346\":1,\"447\":2}}],[\"node\",{\"1\":{\"37\":1,\"58\":2,\"339\":1,\"344\":2,\"447\":4}}],[\"n−2\",{\"1\":{\"521\":1}}],[\"n−1\",{\"1\":{\"36\":1}}],[\"n−i\",{\"1\":{\"36\":3}}],[\"n−i+1\",{\"1\":{\"36\":3}}],[\"n3\",{\"1\":{\"29\":1}}],[\"n+1\",{\"1\":{\"29\":2,\"36\":2}}],[\"nm\",{\"1\":{\"26\":1}}],[\"n21​\",{\"1\":{\"24\":1}}],[\"n2\",{\"1\":{\"23\":1,\"27\":1,\"30\":1}}],[\"n\",{\"1\":{\"22\":6,\"23\":3,\"24\":3,\"26\":6,\"27\":6,\"29\":3,\"30\":1,\"36\":11,\"37\":2,\"53\":2,\"126\":3,\"132\":1,\"205\":1,\"236\":1,\"295\":2,\"296\":1,\"331\":1,\"339\":2,\"340\":2,\"406\":2,\"421\":14,\"444\":1,\"450\":1,\"469\":1,\"484\":4,\"488\":6,\"489\":2,\"496\":11,\"498\":9,\"500\":5,\"501\":2,\"503\":6,\"504\":2,\"506\":6,\"507\":1,\"509\":6,\"512\":5,\"514\":10,\"519\":4,\"521\":7,\"523\":5,\"524\":2,\"526\":5,\"527\":2,\"529\":6,\"530\":1,\"537\":2,\"539\":1,\"541\":12,\"543\":8}}],[\"ftp程序\",{\"1\":{\"569\":1}}],[\"fd未打开\",{\"1\":{\"406\":1}}],[\"fdset\",{\"1\":{\"462\":1}}],[\"fds\",{\"1\":{\"405\":2}}],[\"fd\",{\"1\":{\"404\":7,\"405\":15,\"406\":7,\"407\":4,\"408\":7,\"410\":12,\"411\":1,\"459\":3,\"462\":7}}],[\"found捕获的sqlstate代码的简写\",{\"1\":{\"253\":1}}],[\"found\",{\"1\":{\"253\":1,\"307\":1,\"432\":2}}],[\"forward\",{\"1\":{\"452\":1}}],[\"fork\",{\"1\":{\"319\":8}}],[\"for循环\",{\"1\":{\"289\":1}}],[\"force\",{\"1\":{\"130\":2,\"345\":1}}],[\"foreign\",{\"1\":{\"47\":1,\"49\":3,\"50\":1}}],[\"for\",{\"1\":{\"26\":2,\"27\":2,\"29\":3,\"36\":3,\"37\":1,\"80\":1,\"144\":1,\"145\":1,\"155\":1,\"157\":1,\"158\":1,\"159\":1,\"196\":1,\"228\":2,\"252\":1,\"253\":1,\"289\":3,\"349\":2,\"422\":2,\"432\":2,\"447\":2,\"462\":1,\"482\":1,\"488\":1,\"503\":1,\"506\":1,\"526\":1,\"529\":1,\"536\":1,\"538\":1,\"543\":2}}],[\"fetch\",{\"1\":{\"252\":1}}],[\"fetch和close\",{\"1\":{\"252\":1}}],[\"future\",{\"1\":{\"447\":1}}],[\"fulltext\",{\"1\":{\"124\":1,\"127\":2}}],[\"full\",{\"1\":{\"115\":1,\"123\":1}}],[\"function\",{\"1\":{\"254\":1,\"288\":1,\"291\":7,\"307\":3}}],[\"func\",{\"1\":{\"22\":1,\"23\":1,\"24\":1,\"26\":1,\"27\":1,\"29\":1}}],[\"fib\",{\"1\":{\"500\":3,\"503\":1,\"506\":1}}],[\"field\",{\"1\":{\"377\":2,\"386\":3,\"417\":1}}],[\"fields\",{\"1\":{\"202\":1}}],[\"finish\",{\"1\":{\"509\":1}}],[\"finally\",{\"1\":{\"422\":1}}],[\"final\",{\"1\":{\"347\":1}}],[\"findcontentchildren\",{\"1\":{\"494\":1}}],[\"find\",{\"1\":{\"291\":2,\"432\":1}}],[\"fin报文段即使不携带任何数据\",{\"1\":{\"17\":1}}],[\"fill\",{\"1\":{\"447\":3}}],[\"filtered的值越大越好\",{\"1\":{\"229\":1}}],[\"filtered\",{\"1\":{\"229\":1}}],[\"filename\",{\"1\":{\"82\":1}}],[\"filesort并存\",{\"1\":{\"210\":1}}],[\"filesort\",{\"1\":{\"209\":2}}],[\"files\",{\"0\":{\"71\":1}}],[\"file\",{\"0\":{\"67\":1},\"1\":{\"66\":1,\"67\":1,\"68\":1,\"75\":1,\"202\":2,\"234\":2,\"309\":1,\"311\":1,\"319\":1,\"320\":1,\"339\":1,\"404\":1}}],[\"float\",{\"1\":{\"376\":1}}],[\"floor\",{\"1\":{\"54\":1}}],[\"flags\",{\"1\":{\"426\":6,\"462\":1}}],[\"flag\",{\"1\":{\"288\":1}}],[\"flaged\",{\"1\":{\"206\":1}}],[\"flush\",{\"1\":{\"63\":1,\"139\":1,\"384\":1,\"422\":1}}],[\"frequently\",{\"1\":{\"456\":1}}],[\"free\",{\"1\":{\"61\":1}}],[\"frm\",{\"1\":{\"234\":1}}],[\"from\",{\"1\":{\"94\":2,\"95\":2,\"96\":1,\"97\":2,\"98\":2,\"126\":2,\"127\":1,\"130\":3,\"132\":2,\"144\":1,\"145\":1,\"163\":1,\"177\":1,\"182\":1,\"184\":1,\"186\":4,\"187\":1,\"189\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":1,\"195\":1,\"196\":1,\"210\":1,\"229\":1,\"240\":1,\"243\":1,\"244\":1,\"344\":1}}],[\"frac\",{\"1\":{\"27\":1}}],[\"f\",{\"1\":{\"56\":1,\"496\":16,\"498\":6,\"521\":4}}],[\"factor\",{\"1\":{\"447\":1,\"456\":2}}],[\"factory\",{\"1\":{\"353\":2}}],[\"fast模式规则\",{\"1\":{\"455\":1}}],[\"fasterxml\",{\"1\":{\"353\":1}}],[\"fasle\",{\"1\":{\"36\":1}}],[\"failover\",{\"1\":{\"331\":1,\"345\":3}}],[\"false\",{\"1\":{\"36\":3,\"288\":2,\"290\":2,\"514\":2,\"517\":3}}],[\"解法3\",{\"1\":{\"543\":1}}],[\"解法2\",{\"1\":{\"543\":1}}],[\"解法1\",{\"1\":{\"543\":1}}],[\"解释\",{\"1\":{\"477\":3,\"491\":2,\"496\":3,\"509\":1,\"514\":2,\"519\":2,\"532\":2,\"541\":3}}],[\"解释器来执行脚本\",{\"1\":{\"382\":1}}],[\"解析缓冲区字符串\",{\"1\":{\"462\":1}}],[\"解析客户端命令\",{\"1\":{\"461\":1}}],[\"解析响应\",{\"1\":{\"422\":3}}],[\"解锁\",{\"1\":{\"139\":1}}],[\"解决连续内存空间申请效率问题\",{\"1\":{\"449\":1}}],[\"解决了传统链表的内存占用问题\",{\"1\":{\"449\":1}}],[\"解决了顺序表需要大量连续存储单元的缺点\",{\"1\":{\"37\":1}}],[\"解决方案\",{\"1\":{\"270\":1,\"271\":1,\"272\":2}}],[\"解决哈希碰撞的方法有很多\",{\"1\":{\"121\":1}}],[\"解决思路\",{\"1\":{\"21\":1}}],[\"解题思路\",{\"0\":{\"479\":1,\"486\":1,\"498\":1,\"521\":1,\"534\":1},\"1\":{\"25\":1,\"28\":1}}],[\"解得i=2−1±1+8n​​\",{\"1\":{\"24\":1}}],[\"解得\",{\"1\":{\"23\":1,\"126\":1}}],[\"解方程\",{\"1\":{\"21\":1,\"22\":1,\"23\":1,\"24\":1}}],[\"联合索引很多时候可以覆盖索引\",{\"1\":{\"134\":1}}],[\"联合索引中\",{\"1\":{\"129\":1}}],[\"联合索引\",{\"0\":{\"133\":1},\"1\":{\"127\":1,\"129\":1,\"133\":1}}],[\"联合查询等操作\",{\"1\":{\"162\":1}}],[\"联合查询\",{\"0\":{\"97\":1}}],[\"联立即可得到\",{\"1\":{\"22\":1}}],[\"联立两式\",{\"1\":{\"21\":1,\"22\":1,\"23\":1,\"24\":1}}],[\"联系我\",{\"0\":{\"4\":1}}],[\"确定遍历顺序\",{\"1\":{\"503\":1}}],[\"确定循环的停止条件\",{\"1\":{\"21\":1,\"22\":1,\"23\":1,\"24\":1}}],[\"确保索引记录间隙不变\",{\"1\":{\"146\":1}}],[\"确认字符\",{\"1\":{\"385\":1}}],[\"确认号ack\",{\"1\":{\"17\":1}}],[\"确认号ack=x+1\",{\"1\":{\"15\":1}}],[\"确认报文段不携带数据\",{\"1\":{\"15\":1}}],[\"i<nums1\",{\"1\":{\"543\":1}}],[\"i++\",{\"1\":{\"422\":1,\"482\":3,\"488\":1,\"494\":1,\"503\":1,\"506\":1,\"526\":1,\"529\":1,\"536\":1,\"538\":1,\"543\":1}}],[\"i+1\",{\"1\":{\"24\":1,\"29\":1}}],[\"itcast\",{\"1\":{\"343\":2}}],[\"items\",{\"1\":{\"447\":1}}],[\"item\",{\"1\":{\"307\":2,\"309\":4,\"310\":2,\"311\":3}}],[\"iterate\",{\"1\":{\"251\":2}}],[\"ipfd\",{\"1\":{\"462\":3}}],[\"ip和port是redis地址\",{\"1\":{\"307\":1}}],[\"ip\",{\"1\":{\"294\":1,\"295\":6,\"307\":2,\"330\":1,\"331\":1,\"338\":1,\"339\":1}}],[\"ipairs是lua提供的一个迭代器函数\",{\"1\":{\"289\":1}}],[\"ipairs\",{\"1\":{\"289\":1}}],[\"i是数组索引值\",{\"1\":{\"289\":1}}],[\"ix\",{\"1\":{\"145\":1}}],[\"is\",{\"1\":{\"145\":1,\"187\":1,\"344\":1,\"349\":1,\"426\":2,\"432\":38}}],[\"isolation\",{\"1\":{\"74\":1,\"257\":1,\"259\":2}}],[\"ignore\",{\"1\":{\"130\":2}}],[\"ioexception\",{\"1\":{\"422\":4}}],[\"io多路复用\",{\"0\":{\"404\":1},\"1\":{\"365\":1,\"404\":1}}],[\"io详解\",{\"0\":{\"400\":1},\"1\":{\"265\":1}}],[\"iot\",{\"1\":{\"204\":1}}],[\"io\",{\"1\":{\"73\":1,\"301\":2,\"319\":1,\"358\":1,\"366\":1,\"374\":1,\"401\":11,\"402\":2,\"403\":2,\"404\":5,\"406\":1,\"408\":1,\"411\":2,\"412\":3,\"413\":1,\"459\":1,\"460\":1,\"461\":3}}],[\"ibd\",{\"1\":{\"82\":1,\"234\":1}}],[\"ibd2sdi\",{\"1\":{\"82\":1}}],[\"ibd2sdi指令可以查看ibd文件\",{\"1\":{\"82\":1}}],[\"ibd2sdi指令\",{\"1\":{\"82\":1}}],[\"ib\",{\"1\":{\"72\":2}}],[\"id=1001\",{\"1\":{\"311\":2}}],[\"idle\",{\"1\":{\"307\":2,\"360\":2}}],[\"id不同\",{\"1\":{\"229\":1}}],[\"id相同\",{\"1\":{\"229\":1}}],[\"identified\",{\"1\":{\"195\":2}}],[\"idx\",{\"1\":{\"130\":3,\"132\":1}}],[\"id为主键\",{\"1\":{\"126\":1}}],[\"ids\",{\"1\":{\"85\":1,\"86\":1,\"385\":2}}],[\"id隐藏列\",{\"1\":{\"58\":1}}],[\"id\",{\"1\":{\"58\":1,\"82\":4,\"85\":4,\"86\":11,\"126\":1,\"157\":3,\"158\":3,\"159\":3,\"210\":1,\"221\":1,\"228\":4,\"229\":1,\"232\":1,\"300\":4,\"310\":1,\"311\":3,\"326\":1,\"344\":3,\"345\":1,\"376\":3,\"385\":6,\"386\":3,\"388\":4,\"392\":4,\"393\":2,\"394\":4,\"454\":2}}],[\"i=1∑n+1​pi​\",{\"1\":{\"36\":1}}],[\"i=1∑n​pi​∗i=i=1∑n​n1​∗i=n1​2n\",{\"1\":{\"36\":1}}],[\"i=1∑n​pi​\",{\"1\":{\"36\":1}}],[\"i=1∑n​i2+i=1∑n​i\",{\"1\":{\"29\":1}}],[\"i=1∑n​j=1∑i​k=1∑j​1=i=1∑n​j=1∑i​j=i=1∑n​2i\",{\"1\":{\"29\":1}}],[\"if判断\",{\"0\":{\"245\":1}}],[\"ifnull\",{\"1\":{\"56\":1}}],[\"if\",{\"1\":{\"36\":5,\"56\":1,\"163\":1,\"176\":2,\"177\":1,\"240\":1,\"245\":2,\"290\":2,\"307\":5,\"351\":1,\"422\":6,\"432\":17,\"462\":1,\"482\":8,\"488\":3,\"494\":1,\"500\":1,\"503\":1,\"506\":1,\"512\":4,\"517\":19,\"523\":1,\"526\":1,\"529\":1,\"536\":1,\"538\":1,\"543\":6}}],[\"input\",{\"1\":{\"552\":1}}],[\"inputstreamreader\",{\"1\":{\"422\":1}}],[\"initserver\",{\"1\":{\"462\":3}}],[\"initlist\",{\"1\":{\"35\":1}}],[\"individual\",{\"1\":{\"447\":1}}],[\"index和using\",{\"1\":{\"210\":1}}],[\"index\",{\"0\":{\"64\":1},\"1\":{\"64\":1,\"127\":7,\"130\":6,\"131\":2,\"132\":1,\"145\":1,\"204\":1,\"209\":3,\"210\":2,\"213\":1,\"229\":1,\"306\":3,\"543\":18}}],[\"incrbyfloat\",{\"1\":{\"376\":1}}],[\"incrby\",{\"1\":{\"376\":2}}],[\"incr\",{\"1\":{\"376\":1,\"462\":1}}],[\"increment\",{\"1\":{\"232\":1,\"380\":1}}],[\"increment自增主键\",{\"1\":{\"207\":1}}],[\"include\",{\"1\":{\"306\":1}}],[\"installation\",{\"1\":{\"366\":1}}],[\"install\",{\"1\":{\"305\":4,\"341\":2,\"366\":1,\"370\":1}}],[\"inserted\",{\"1\":{\"432\":1}}],[\"inserts\",{\"1\":{\"432\":1}}],[\"insert优化\",{\"0\":{\"198\":1}}],[\"insert型触发器\",{\"1\":{\"154\":1}}],[\"insert\",{\"1\":{\"73\":1,\"80\":1,\"144\":1,\"145\":1,\"155\":1,\"157\":5,\"158\":2,\"159\":2,\"180\":4,\"196\":1,\"199\":1,\"200\":3,\"226\":1,\"432\":2}}],[\"inout\",{\"1\":{\"246\":2}}],[\"info\",{\"1\":{\"297\":1}}],[\"information\",{\"1\":{\"240\":1}}],[\"infogrid\",{\"1\":{\"109\":1}}],[\"infile\",{\"1\":{\"202\":5}}],[\"infinite\",{\"1\":{\"109\":1}}],[\"inner\",{\"1\":{\"94\":1}}],[\"innodb是默认的mysql存储引擎\",{\"1\":{\"234\":1}}],[\"innodb是一种兼顾高可靠性和高性能的通用存储引擎\",{\"1\":{\"234\":1}}],[\"innodb是索引组织表\",{\"1\":{\"58\":1}}],[\"innodb会开始寻找最靠近的页\",{\"1\":{\"206\":1}}],[\"innodb实现了以下两种类型的行锁\",{\"1\":{\"147\":1}}],[\"innodb的数据是基于索引组织的\",{\"1\":{\"146\":1}}],[\"innodb的指针占用6个字节的空间\",{\"1\":{\"126\":1}}],[\"innodb主键索引的b+tree高度为多高呢\",{\"1\":{\"126\":1}}],[\"innodb引擎的每张表都会对应这样一个表空间文件\",{\"1\":{\"234\":1}}],[\"innodb引擎的存储结构主要包含5个部分\",{\"1\":{\"58\":1}}],[\"innodb引擎中的行锁是针对索引加的锁\",{\"1\":{\"223\":1}}],[\"innodb引擎遍历整张表\",{\"1\":{\"221\":1}}],[\"innodb引擎会遍历整张表\",{\"1\":{\"221\":3}}],[\"innodb引擎\",{\"1\":{\"170\":1}}],[\"innodb引擎将数据页从buffer\",{\"1\":{\"71\":1}}],[\"innodb使用会话临时表和全局临时表空间\",{\"1\":{\"70\":1}}],[\"innodb\",{\"0\":{\"234\":1},\"1\":{\"63\":2,\"66\":1,\"67\":1,\"123\":1,\"142\":1,\"221\":1,\"234\":2,\"236\":1,\"237\":1}}],[\"innodb架构\",{\"1\":{\"59\":1}}],[\"innodb存储引擎会监控对表上各索引页的查询\",{\"1\":{\"64\":1}}],[\"innodb存储引擎数据是按行进行存放的\",{\"1\":{\"58\":1}}],[\"innodb存储引擎每次从磁盘申请4\",{\"1\":{\"58\":1}}],[\"innodb存储引擎页大小为16k\",{\"1\":{\"58\":1}}],[\"innodb存储引擎\",{\"0\":{\"57\":1}}],[\"innodb不支持\",{\"1\":{\"50\":1}}],[\"in\",{\"1\":{\"80\":1,\"100\":4,\"101\":2,\"102\":1,\"121\":1,\"144\":1,\"145\":1,\"187\":1,\"246\":2,\"289\":1,\"432\":2,\"447\":5}}],[\"int32\",{\"1\":{\"442\":1}}],[\"intrev32ifbe\",{\"1\":{\"432\":15}}],[\"int64\",{\"1\":{\"432\":4,\"436\":1,\"442\":1}}],[\"int8\",{\"1\":{\"431\":1,\"432\":1}}],[\"int16\",{\"1\":{\"430\":2,\"432\":2,\"436\":1,\"442\":1}}],[\"intset小结\",{\"0\":{\"433\":1}}],[\"intsetget\",{\"1\":{\"432\":3}}],[\"intsetgetencoded\",{\"1\":{\"432\":1}}],[\"intsetgetencoding按照旧编码方式查找旧元素\",{\"1\":{\"432\":1}}],[\"intsetset按照新编码方式插入新元素\",{\"1\":{\"432\":1}}],[\"intsetset\",{\"1\":{\"432\":4}}],[\"intsetsearch\",{\"1\":{\"432\":2}}],[\"intsetmovetail\",{\"1\":{\"432\":1}}],[\"intsetresize\",{\"1\":{\"432\":2}}],[\"intsetupgradeandadd\",{\"1\":{\"432\":2}}],[\"intsetvalueencoding\",{\"1\":{\"432\":2}}],[\"intsetadd\",{\"1\":{\"432\":1}}],[\"intset\",{\"1\":{\"418\":2,\"430\":3,\"431\":2,\"432\":12,\"433\":2,\"466\":1,\"467\":1}}],[\"integers的默认值是10000\",{\"1\":{\"469\":1}}],[\"integers的所有整数\",{\"1\":{\"469\":1}}],[\"integer\",{\"1\":{\"354\":1,\"422\":2,\"432\":2}}],[\"interval\",{\"1\":{\"55\":1}}],[\"into\",{\"1\":{\"157\":2,\"158\":2,\"159\":2,\"180\":4,\"199\":1,\"200\":3,\"202\":1,\"243\":1,\"244\":1,\"252\":1}}],[\"int\",{\"1\":{\"22\":3,\"23\":3,\"24\":4,\"26\":5,\"27\":4,\"29\":5,\"36\":9,\"37\":3,\"232\":1,\"244\":1,\"376\":1,\"405\":4,\"406\":5,\"407\":10,\"422\":5,\"432\":5,\"447\":12,\"452\":1,\"454\":1,\"456\":1,\"462\":6,\"465\":1,\"466\":1,\"467\":1,\"482\":4,\"488\":6,\"494\":6,\"500\":2,\"503\":5,\"506\":7,\"512\":9,\"517\":16,\"523\":2,\"526\":5,\"529\":6,\"536\":5,\"538\":6,\"543\":22}}],[\"i\",{\"1\":{\"21\":1,\"22\":9,\"23\":9,\"24\":8,\"25\":1,\"26\":6,\"27\":8,\"29\":5,\"35\":3,\"36\":38,\"37\":3,\"136\":1,\"289\":2,\"295\":8,\"296\":1,\"304\":1,\"331\":2,\"339\":2,\"340\":2,\"344\":1,\"405\":1,\"422\":2,\"477\":5,\"481\":2,\"482\":11,\"484\":7,\"488\":12,\"491\":4,\"494\":3,\"503\":10,\"506\":2,\"512\":12,\"514\":1,\"516\":2,\"517\":50,\"526\":5,\"529\":2,\"532\":3,\"534\":20,\"536\":12,\"538\":6,\"541\":1,\"543\":19}}],[\"与单行字符串格式一样\",{\"1\":{\"421\":1}}],[\"与java中的treeset有些类似\",{\"1\":{\"380\":1}}],[\"与lpop和rpop类似\",{\"1\":{\"378\":1}}],[\"与redis服务端做心跳测试\",{\"1\":{\"372\":1}}],[\"与restrict一致\",{\"1\":{\"50\":1}}],[\"与哨兵模式相比\",{\"1\":{\"346\":1}}],[\"与salveof效果一致\",{\"1\":{\"297\":1}}],[\"与shared\",{\"1\":{\"144\":2}}],[\"与表锁排他锁\",{\"1\":{\"145\":1}}],[\"与表锁共享锁\",{\"1\":{\"145\":2}}],[\"与其他的mdl都互斥\",{\"1\":{\"144\":1}}],[\"与exclusive\",{\"1\":{\"144\":2}}],[\"与any等同\",{\"1\":{\"100\":1}}],[\"与聚集索引不同\",{\"1\":{\"62\":1}}],[\"与no\",{\"1\":{\"50\":1}}],[\"与\",{\"1\":{\"21\":1,\"22\":1,\"23\":1,\"24\":1,\"304\":1,\"406\":1,\"415\":1}}],[\"tvp\",{\"1\":{\"462\":1}}],[\"tip\",{\"1\":{\"379\":1}}],[\"timeval\",{\"1\":{\"405\":1}}],[\"timeout\",{\"1\":{\"306\":1,\"331\":1,\"339\":1,\"405\":1,\"406\":1,\"407\":1}}],[\"time等\",{\"1\":{\"244\":1}}],[\"time\",{\"1\":{\"227\":2,\"307\":2,\"456\":1}}],[\"tail\",{\"1\":{\"447\":1,\"452\":1}}],[\"tag\",{\"1\":{\"373\":2}}],[\"target\",{\"1\":{\"370\":2}}],[\"takeover\",{\"1\":{\"345\":1}}],[\"tables\",{\"1\":{\"139\":2,\"143\":2,\"177\":1}}],[\"tablespaces\",{\"0\":{\"67\":1,\"68\":1,\"69\":1,\"70\":1}}],[\"tablespace\",{\"0\":{\"66\":1},\"1\":{\"68\":4,\"204\":1}}],[\"table2\",{\"1\":{\"98\":1}}],[\"table1\",{\"1\":{\"98\":1}}],[\"tabletablespace\",{\"1\":{\"68\":1}}],[\"table\",{\"0\":{\"67\":1},\"1\":{\"49\":3,\"50\":1,\"67\":1,\"68\":2,\"127\":5,\"132\":1,\"144\":2,\"177\":6,\"178\":4,\"199\":1,\"200\":3,\"202\":2,\"204\":1,\"232\":1,\"234\":2,\"288\":7,\"436\":1,\"438\":1}}],[\"tmp下准备一个新的redis\",{\"1\":{\"339\":1}}],[\"tmp\",{\"1\":{\"295\":4,\"331\":2,\"339\":6,\"340\":1,\"341\":1}}],[\"tmp目录执行下列命令\",{\"1\":{\"295\":3,\"331\":1}}],[\"tmp目录\",{\"1\":{\"295\":1,\"331\":1,\"339\":3,\"340\":1}}],[\"tutorial\",{\"1\":{\"291\":1}}],[\"two\",{\"1\":{\"289\":1}}],[\"ttl\",{\"1\":{\"276\":1,\"361\":1,\"454\":6,\"455\":2,\"456\":1}}],[\"tbl\",{\"1\":{\"155\":1}}],[\"tb\",{\"1\":{\"130\":3,\"132\":2,\"139\":2,\"140\":2,\"210\":1}}],[\"total\",{\"1\":{\"447\":1}}],[\"too\",{\"1\":{\"447\":1}}],[\"touch\",{\"1\":{\"287\":1,\"310\":1}}],[\"tomcat\",{\"1\":{\"279\":4}}],[\"to\",{\"1\":{\"177\":2,\"196\":1,\"344\":3,\"426\":1,\"432\":3,\"447\":3}}],[\"todo\",{\"1\":{\"118\":1,\"149\":1}}],[\"tokyo\",{\"1\":{\"109\":1}}],[\"terminator\",{\"1\":{\"426\":4}}],[\"terminated\",{\"1\":{\"202\":2}}],[\"teardown\",{\"1\":{\"351\":1}}],[\"testobject\",{\"1\":{\"354\":1}}],[\"teststring\",{\"1\":{\"351\":1,\"360\":1}}],[\"testcaffeine\",{\"1\":{\"282\":1}}],[\"test\",{\"1\":{\"282\":1,\"351\":1,\"354\":1,\"360\":1}}],[\"tech\",{\"1\":{\"266\":1}}],[\"tel\",{\"1\":{\"129\":5}}],[\"text等\",{\"1\":{\"132\":1}}],[\"text索引\",{\"1\":{\"123\":1}}],[\"text\",{\"1\":{\"115\":1}}],[\"temporary\",{\"0\":{\"70\":1},\"1\":{\"213\":1}}],[\"tyrant\",{\"1\":{\"109\":1}}],[\"type=forking\",{\"1\":{\"370\":1}}],[\"typeid\",{\"1\":{\"343\":1}}],[\"types\",{\"1\":{\"306\":1}}],[\"type\",{\"1\":{\"55\":1,\"144\":2,\"145\":1,\"157\":1,\"158\":1,\"159\":1,\"229\":2,\"254\":1,\"306\":1,\"309\":1,\"426\":11,\"436\":1,\"456\":1,\"465\":1}}],[\"typedef\",{\"1\":{\"36\":1,\"37\":1,\"405\":2,\"431\":1,\"436\":3,\"447\":6,\"452\":2,\"454\":1,\"456\":1,\"465\":1}}],[\"that\",{\"1\":{\"447\":1}}],[\"this\",{\"1\":{\"447\":1}}],[\"the\",{\"1\":{\"344\":2,\"426\":6,\"432\":16,\"447\":1}}],[\"then\",{\"1\":{\"56\":4,\"245\":2,\"247\":4,\"290\":1,\"307\":5}}],[\"throw\",{\"1\":{\"422\":2}}],[\"throws\",{\"1\":{\"422\":2}}],[\"through\",{\"1\":{\"275\":1}}],[\"threesum\",{\"1\":{\"482\":1}}],[\"three\",{\"1\":{\"289\":1}}],[\"threshold\",{\"1\":{\"206\":2}}],[\"thread主要负责这些io请求的回调\",{\"1\":{\"73\":1}}],[\"thread\",{\"1\":{\"73\":10}}],[\"try\",{\"1\":{\"422\":2}}],[\"truncate\",{\"1\":{\"177\":1}}],[\"true\",{\"1\":{\"36\":3,\"288\":2,\"289\":1,\"290\":4,\"514\":2,\"517\":1}}],[\"trib\",{\"1\":{\"341\":4}}],[\"triggers\",{\"1\":{\"155\":1}}],[\"trigger\",{\"1\":{\"155\":5,\"157\":2,\"158\":2,\"159\":2}}],[\"trim\",{\"1\":{\"53\":1}}],[\"transaction\",{\"1\":{\"140\":1,\"200\":1,\"256\":1,\"259\":2}}],[\"transaction参数来完成不加锁的一致性数据备份\",{\"1\":{\"140\":1}}],[\"tree索引\",{\"1\":{\"123\":1}}],[\"tree\",{\"1\":{\"115\":1,\"118\":1}}],[\"trx\",{\"1\":{\"58\":1,\"63\":1,\"82\":2,\"85\":3,\"86\":11}}],[\"t=0∑k​=n=2i∗\",{\"1\":{\"24\":1}}],[\"t=0∑i​\",{\"1\":{\"24\":1}}],[\"t\",{\"1\":{\"21\":2,\"22\":6,\"23\":3,\"24\":6,\"27\":1,\"56\":1,\"295\":2,\"296\":1,\"331\":1,\"339\":2,\"340\":2,\"406\":1,\"426\":8,\"430\":1,\"431\":3,\"432\":11,\"436\":3,\"442\":3,\"447\":4}}],[\"tcpaccepthandler\",{\"1\":{\"460\":1}}],[\"tcp层是位于ip层之上\",{\"1\":{\"14\":1}}],[\"tcp是一种面向连接的\",{\"1\":{\"14\":1}}],[\"tcp连接的3次握手和4次挥手归根结底是在保证连接可靠的情况下尽可能的减少资源的浪费\",{\"1\":{\"17\":1}}],[\"tcp连接提供的是全双工信道\",{\"1\":{\"15\":1}}],[\"tcp连接\",{\"1\":{\"13\":1}}],[\"tcp三次握手和四次挥手图文详解\",{\"0\":{\"13\":1}}],[\"算法得到一个\",{\"1\":{\"343\":1}}],[\"算法复杂度问题\",{\"0\":{\"19\":1}}],[\"算法题解\",{\"0\":{\"5\":1}}],[\"22\",{\"1\":{\"514\":1}}],[\"20\",{\"1\":{\"514\":1,\"532\":1}}],[\"200\",{\"1\":{\"347\":1,\"541\":2}}],[\"200010的数据\",{\"1\":{\"217\":1}}],[\"2000000\",{\"1\":{\"217\":1}}],[\"28\",{\"1\":{\"509\":2}}],[\"2个孩子的胃口值分别是1\",{\"1\":{\"491\":1}}],[\"2以后\",{\"1\":{\"467\":1}}],[\"2以前\",{\"1\":{\"467\":1}}],[\"24\",{\"1\":{\"465\":1,\"514\":1}}],[\"24位有符号整数\",{\"1\":{\"442\":1}}],[\"255\",{\"1\":{\"456\":1}}],[\"25ms\",{\"1\":{\"455\":1}}],[\"254\",{\"1\":{\"443\":2}}],[\"2版本引入了新的数据结构\",{\"1\":{\"444\":1}}],[\"2kb\",{\"1\":{\"408\":1}}],[\"2kn2​\",{\"1\":{\"23\":3}}],[\"23\",{\"1\":{\"514\":1}}],[\"232\",{\"1\":{\"401\":1}}],[\"230\",{\"1\":{\"351\":1}}],[\"2^64\",{\"1\":{\"398\":1}}],[\"2<\",{\"1\":{\"351\":1}}],[\"27003\",{\"1\":{\"330\":1,\"331\":2,\"334\":1}}],[\"27002\",{\"1\":{\"330\":1,\"331\":1,\"334\":1}}],[\"27001\",{\"1\":{\"330\":1,\"331\":4,\"334\":1}}],[\"21\",{\"1\":{\"288\":2,\"376\":1,\"503\":1,\"514\":1}}],[\"21939856\",{\"1\":{\"126\":1}}],[\"2取数据\",{\"1\":{\"282\":1}}],[\"2n\",{\"1\":{\"437\":1,\"438\":2}}],[\"2n+1\",{\"1\":{\"29\":1}}],[\"2n2​\",{\"1\":{\"23\":1}}],[\"2log2​n\",{\"1\":{\"23\":1}}],[\"2\",{\"0\":{\"19\":1,\"25\":1,\"144\":1,\"295\":1,\"306\":1,\"481\":1,\"556\":1,\"557\":1,\"558\":2,\"559\":1,\"560\":1,\"561\":1,\"562\":1,\"566\":1,\"568\":1,\"569\":1,\"570\":2,\"571\":1,\"574\":1},\"1\":{\"22\":2,\"23\":2,\"24\":3,\"26\":1,\"27\":3,\"63\":1,\"145\":1,\"193\":1,\"201\":2,\"205\":1,\"227\":1,\"270\":2,\"272\":3,\"282\":1,\"295\":6,\"311\":1,\"331\":3,\"341\":2,\"351\":3,\"353\":1,\"364\":1,\"370\":1,\"376\":1,\"382\":1,\"405\":1,\"407\":1,\"416\":2,\"421\":4,\"422\":4,\"426\":1,\"430\":1,\"436\":1,\"442\":1,\"446\":1,\"447\":2,\"448\":4,\"466\":1,\"467\":1,\"477\":7,\"481\":2,\"482\":3,\"484\":6,\"488\":8,\"491\":7,\"496\":9,\"498\":4,\"500\":2,\"501\":1,\"503\":5,\"506\":2,\"509\":3,\"514\":3,\"517\":32,\"519\":7,\"521\":4,\"523\":1,\"524\":1,\"526\":4,\"529\":4,\"532\":3,\"534\":10,\"536\":4,\"538\":2,\"541\":9,\"566\":1}}],[\"需要合并的数组是\",{\"1\":{\"541\":1}}],[\"需要合并\",{\"1\":{\"541\":2}}],[\"需要\",{\"1\":{\"519\":1}}],[\"需要更换更大的饼干\",{\"1\":{\"492\":1}}],[\"需要更新\",{\"1\":{\"300\":1}}],[\"需要消耗很大的cpu\",{\"1\":{\"469\":1}}],[\"需要消除无效的笛卡尔积\",{\"1\":{\"93\":1}}],[\"需要判断所执行的数据类型和编码方式\",{\"1\":{\"468\":1}}],[\"需要7次查找\",{\"1\":{\"450\":1}}],[\"需要增加记录上一个元素的\",{\"1\":{\"441\":1}}],[\"需要升级\",{\"1\":{\"432\":1}}],[\"需要申请新的内存空间\",{\"1\":{\"427\":1}}],[\"需要遍历fd\",{\"1\":{\"405\":1}}],[\"需要将大一点的数变小\",{\"1\":{\"481\":1}}],[\"需要将小一点的数变大\",{\"1\":{\"481\":1}}],[\"需要将整个fd\",{\"1\":{\"405\":1}}],[\"需要将所有的元素都进行对比\",{\"1\":{\"36\":1}}],[\"需要用户进程逐个遍历\",{\"1\":{\"404\":1}}],[\"需要保证redis服务是开启的\",{\"1\":{\"372\":1}}],[\"需要配置一个系统服务文件\",{\"1\":{\"370\":1}}],[\"需要手动反序列化对象\",{\"1\":{\"355\":1}}],[\"需要给redis\",{\"1\":{\"342\":1}}],[\"需要在\",{\"1\":{\"326\":1}}],[\"需要在集群间共享\",{\"1\":{\"280\":1}}],[\"需要修改\",{\"1\":{\"320\":1}}],[\"需要预留一部分缓冲空间\",{\"1\":{\"319\":1}}],[\"需要一种自动的故障恢复手段\",{\"1\":{\"318\":1}}],[\"需要先对\",{\"1\":{\"288\":1}}],[\"需要认真学习\",{\"1\":{\"257\":1}}],[\"需要我们使用指令进行提交\",{\"1\":{\"256\":1}}],[\"需要我们建立一张中间表\",{\"1\":{\"92\":1}}],[\"需要使用declare声明\",{\"1\":{\"244\":1}}],[\"需要通过关键字delimiter指定sql语句的结束符\",{\"1\":{\"240\":1}}],[\"需要通过建立中间临时表对所需要的数据进行查询\",{\"1\":{\"213\":1}}],[\"需要优化的没有被统计\",{\"1\":{\"227\":1}}],[\"需要把数据一行一行地从引擎里面读出来\",{\"1\":{\"219\":1}}],[\"需要对此优化\",{\"1\":{\"216\":1}}],[\"需要严格谨慎检查自己的sql语句\",{\"1\":{\"181\":1,\"182\":1}}],[\"需要注意的是\",{\"1\":{\"36\":2,\"226\":1,\"534\":1}}],[\"需要经过时间等待计时器设置的时间后\",{\"1\":{\"17\":1}}],[\"需要做出回应\",{\"1\":{\"17\":1}}],[\"需要进行连接的释放\",{\"1\":{\"17\":1}}],[\"we\",{\"1\":{\"426\":1,\"432\":2}}],[\"web服务流程\",{\"0\":{\"409\":1}}],[\"web\",{\"1\":{\"304\":6,\"409\":1}}],[\"wan\",{\"1\":{\"557\":1}}],[\"wantedby=multi\",{\"1\":{\"370\":1}}],[\"want\",{\"1\":{\"344\":2}}],[\"was\",{\"1\":{\"432\":1,\"447\":1}}],[\"watched\",{\"1\":{\"454\":1}}],[\"watch\",{\"1\":{\"399\":2}}],[\"wait\",{\"1\":{\"360\":1,\"407\":1,\"408\":3,\"410\":1,\"459\":1,\"462\":1}}],[\"worker\",{\"1\":{\"306\":2}}],[\"world\",{\"1\":{\"282\":1,\"287\":2}}],[\"will\",{\"1\":{\"447\":1}}],[\"windows系统下的客户端种类很多\",{\"1\":{\"373\":1}}],[\"windows系统\",{\"1\":{\"373\":1}}],[\"wiki\",{\"1\":{\"281\":1}}],[\"within\",{\"1\":{\"432\":1}}],[\"withhash\",{\"1\":{\"396\":2}}],[\"withdist\",{\"1\":{\"396\":2}}],[\"withcoord\",{\"1\":{\"396\":2}}],[\"with\",{\"1\":{\"139\":1,\"163\":3,\"195\":1,\"344\":1}}],[\"www\",{\"1\":{\"105\":1,\"171\":1,\"266\":3,\"286\":1,\"291\":2,\"351\":2,\"546\":1,\"549\":1}}],[\"write这个队列\",{\"1\":{\"462\":1}}],[\"writer\",{\"1\":{\"422\":8}}],[\"writefds\",{\"1\":{\"405\":1}}],[\"write兼容\",{\"1\":{\"144\":2}}],[\"write\",{\"0\":{\"71\":1},\"1\":{\"73\":1,\"143\":2,\"144\":3,\"145\":2,\"275\":2,\"319\":1,\"462\":1}}],[\"what\",{\"1\":{\"344\":1}}],[\"where之后包含了子查询\",{\"1\":{\"229\":1}}],[\"where不能对聚合函数进行判断\",{\"1\":{\"190\":1}}],[\"where是分组之前进行过滤\",{\"1\":{\"190\":1}}],[\"where\",{\"1\":{\"94\":1,\"98\":1,\"126\":2,\"130\":3,\"131\":1,\"134\":1,\"181\":1,\"182\":1,\"184\":1,\"185\":1,\"187\":1,\"190\":3,\"193\":1,\"229\":1,\"240\":1,\"432\":2}}],[\"when\",{\"1\":{\"56\":4,\"247\":6,\"432\":3}}],[\"while刚好相反\",{\"1\":{\"250\":1}}],[\"while循环时有条件的循环控制语句\",{\"1\":{\"249\":1}}],[\"while循环\",{\"0\":{\"249\":1},\"1\":{\"289\":1}}],[\"while\",{\"1\":{\"22\":1,\"23\":1,\"24\":1,\"37\":1,\"249\":2,\"250\":1,\"289\":2,\"432\":2,\"462\":1,\"482\":1,\"494\":1,\"512\":1,\"517\":1,\"543\":2}}],[\"w为服务端成功传输最后一个数据包的序号\",{\"1\":{\"17\":1}}],[\"w\",{\"1\":{\"17\":2}}],[\"vue3\",{\"0\":{\"582\":1}}],[\"v6\",{\"1\":{\"458\":1}}],[\"v4\",{\"1\":{\"458\":1}}],[\"v1\",{\"1\":{\"373\":2}}],[\"v是对应索引的数组元素值\",{\"1\":{\"289\":1}}],[\"void\",{\"1\":{\"282\":1,\"334\":1,\"351\":3,\"354\":1,\"360\":1,\"422\":2,\"436\":3,\"456\":1,\"462\":6,\"465\":1,\"543\":3}}],[\"volatile\",{\"1\":{\"276\":4,\"456\":4}}],[\"voldemort\",{\"1\":{\"109\":1}}],[\"vi\",{\"1\":{\"305\":1,\"370\":1}}],[\"video\",{\"1\":{\"171\":1,\"266\":1,\"546\":1}}],[\"view\",{\"1\":{\"85\":1,\"163\":5}}],[\"var=exp1\",{\"1\":{\"289\":1}}],[\"variables\",{\"1\":{\"234\":1,\"242\":2}}],[\"var\",{\"1\":{\"227\":1,\"243\":8,\"311\":2}}],[\"varchar\",{\"1\":{\"132\":1,\"232\":1,\"244\":1}}],[\"val\",{\"1\":{\"436\":1}}],[\"valenc\",{\"1\":{\"432\":2}}],[\"val2\",{\"1\":{\"56\":2}}],[\"val1\",{\"1\":{\"56\":2}}],[\"value字节\",{\"1\":{\"419\":1}}],[\"value支持多种不同的数据结构\",{\"1\":{\"365\":1}}],[\"valueoperations\",{\"1\":{\"359\":2}}],[\"values\",{\"1\":{\"180\":4,\"199\":2,\"200\":6}}],[\"value2\",{\"1\":{\"56\":1,\"247\":1}}],[\"value1\",{\"1\":{\"56\":1,\"247\":1}}],[\"value\",{\"1\":{\"56\":1,\"109\":1,\"157\":2,\"158\":2,\"159\":2,\"247\":1,\"253\":4,\"281\":1,\"334\":6,\"352\":1,\"353\":1,\"355\":3,\"365\":1,\"376\":1,\"377\":1,\"386\":3,\"397\":1,\"417\":2,\"418\":1,\"419\":1,\"425\":1,\"432\":24,\"447\":1,\"454\":5}}],[\"version>\",{\"1\":{\"351\":2}}],[\"version\",{\"1\":{\"79\":1}}],[\"v=31​s∗h\",{\"1\":{\"29\":1}}],[\"v为服务端最后一次传输成功的报文段的序号\",{\"1\":{\"17\":1}}],[\"v\",{\"1\":{\"17\":1,\"289\":2,\"436\":1}}],[\"u64\",{\"1\":{\"436\":1}}],[\"uint64\",{\"1\":{\"426\":2,\"436\":1}}],[\"uint32\",{\"1\":{\"426\":2,\"431\":2,\"432\":2}}],[\"uint16\",{\"1\":{\"426\":2}}],[\"uint8\",{\"1\":{\"426\":2,\"432\":5}}],[\"utf\",{\"1\":{\"422\":3}}],[\"utils\",{\"1\":{\"305\":1}}],[\"url\",{\"1\":{\"351\":6}}],[\"uroot\",{\"1\":{\"139\":1,\"140\":1}}],[\"usage\",{\"1\":{\"447\":1}}],[\"usr\",{\"1\":{\"305\":2,\"306\":1,\"307\":2,\"309\":2,\"370\":2}}],[\"using\",{\"1\":{\"131\":3,\"209\":2,\"210\":1,\"213\":2}}],[\"used的2n\",{\"1\":{\"438\":2}}],[\"used\",{\"1\":{\"426\":5,\"436\":1,\"437\":1,\"438\":2,\"447\":1,\"456\":2}}],[\"use\",{\"1\":{\"130\":2,\"176\":1,\"195\":1,\"349\":1}}],[\"user相关的key\",{\"1\":{\"376\":1}}],[\"users\",{\"1\":{\"232\":1}}],[\"user表中数据删除时\",{\"1\":{\"159\":1}}],[\"user表中数据更新时\",{\"1\":{\"158\":1}}],[\"user表中数据插入时\",{\"1\":{\"157\":1}}],[\"username2\",{\"1\":{\"282\":3}}],[\"username\",{\"1\":{\"129\":5,\"157\":2,\"158\":2,\"159\":2,\"232\":1,\"282\":6}}],[\"user\",{\"1\":{\"126\":2,\"130\":6,\"132\":2,\"139\":2,\"140\":2,\"157\":4,\"158\":4,\"159\":4,\"195\":4,\"306\":1,\"354\":15,\"370\":1,\"376\":2}}],[\"unlike\",{\"1\":{\"458\":1}}],[\"unlock\",{\"1\":{\"139\":1,\"143\":1}}],[\"unused\",{\"1\":{\"426\":4}}],[\"unsigned\",{\"1\":{\"426\":5,\"432\":2,\"436\":3,\"447\":15,\"452\":2,\"454\":1,\"456\":3,\"465\":3}}],[\"unsubscribe\",{\"1\":{\"381\":1}}],[\"unwatch\",{\"1\":{\"399\":1}}],[\"until\",{\"1\":{\"289\":1}}],[\"until条件\",{\"1\":{\"250\":1}}],[\"uncommitted\",{\"1\":{\"259\":2}}],[\"unit\",{\"1\":{\"370\":1}}],[\"union中的第二个或者后面的查询语句\",{\"1\":{\"229\":1}}],[\"union\",{\"1\":{\"97\":3,\"166\":2,\"229\":1,\"436\":1}}],[\"uniquepaths\",{\"1\":{\"512\":1}}],[\"unique\",{\"1\":{\"47\":1,\"90\":1,\"124\":1,\"127\":2}}],[\"undo页的回收\",{\"1\":{\"73\":1}}],[\"undo\",{\"0\":{\"69\":1,\"76\":1,\"83\":1,\"84\":1},\"1\":{\"63\":1,\"66\":1,\"73\":2,\"76\":6,\"79\":1,\"83\":2,\"84\":2,\"86\":2}}],[\"up\",{\"1\":{\"512\":4}}],[\"upgrades\",{\"1\":{\"432\":1}}],[\"upper\",{\"1\":{\"53\":1}}],[\"update优化\",{\"0\":{\"222\":1}}],[\"update型触发器\",{\"1\":{\"154\":1}}],[\"update\",{\"1\":{\"50\":1,\"80\":1,\"83\":1,\"98\":1,\"114\":1,\"144\":2,\"145\":2,\"153\":1,\"155\":1,\"158\":3,\"181\":1,\"196\":1,\"226\":2,\"305\":1}}],[\"u为此前传输数据包的报文段的序号\",{\"1\":{\"17\":1}}],[\"u\",{\"1\":{\"17\":4,\"202\":1}}],[\"将工作任务均衡地分配给计算机网络中的各台计算机\",{\"1\":{\"577\":1}}],[\"将dp数组进行优化\",{\"1\":{\"538\":1}}],[\"将客户端添加到server\",{\"1\":{\"462\":1}}],[\"将rehashidx赋值为\",{\"1\":{\"438\":1}}],[\"将rdb文件保存位置都修改为自己所在目录\",{\"1\":{\"295\":1}}],[\"将用户空间中创建的\",{\"1\":{\"405\":1}}],[\"将⼀个或多个hll合并后的结果存储在另⼀个hll中\",{\"1\":{\"398\":1}}],[\"将指定的地理空间位置\",{\"1\":{\"396\":1}}],[\"将消息标记为\",{\"1\":{\"385\":1}}],[\"将所有元素添加到指定hyperloglog数据结构中\",{\"1\":{\"398\":1}}],[\"将所有加入的消息都串起来\",{\"1\":{\"385\":1}}],[\"将所有数据保存在内存中\",{\"1\":{\"237\":1}}],[\"将脚本添加到脚本缓存\",{\"1\":{\"384\":1}}],[\"将以下内容作为文件内容\",{\"1\":{\"370\":1}}],[\"将对象手动序列化为\",{\"1\":{\"356\":1}}],[\"将对象的类路径地址也序列化进\",{\"1\":{\"354\":1}}],[\"将这个对象的\",{\"1\":{\"470\":1}}],[\"将这个文件拷贝到每个目录下\",{\"1\":{\"339\":1}}],[\"将这两张表进行连接查询\",{\"1\":{\"96\":1}}],[\"将端口分别修改为27002\",{\"1\":{\"331\":1}}],[\"将端口分别修改为7001\",{\"1\":{\"295\":1}}],[\"将故障节点标记为\",{\"1\":{\"327\":1}}],[\"将方法导出\",{\"1\":{\"307\":1}}],[\"将\",{\"1\":{\"300\":1,\"343\":1,\"354\":1,\"356\":1,\"406\":1,\"438\":3}}],[\"将完整内存数据生成\",{\"1\":{\"300\":1,\"302\":1}}],[\"将其插入返回链表中\",{\"1\":{\"481\":1}}],[\"将其中的6379修改为与所在目录一致\",{\"1\":{\"339\":1}}],[\"将其中的持久化模式改为默认的rdb模式\",{\"1\":{\"295\":1}}],[\"将其ack位置为1\",{\"1\":{\"17\":1}}],[\"将自动被弱引用或者软引用所封装\",{\"1\":{\"281\":1}}],[\"将自动被弱引用所封装\",{\"1\":{\"281\":1}}],[\"将根据缓存中的元素上一次访问或者被修改的时间进行基于过期时间的驱逐\",{\"1\":{\"281\":1}}],[\"将会持有所有加入到缓存当中的元素\",{\"1\":{\"281\":1}}],[\"将会生成该隐藏字段\",{\"1\":{\"82\":1}}],[\"将缓存和数据库操作放在同一个事务内\",{\"1\":{\"275\":1}}],[\"将一个fd添加到epol的红黑树中\",{\"1\":{\"407\":1}}],[\"将一些语句封装起来\",{\"1\":{\"239\":1}}],[\"将一列数据作为一个整体\",{\"1\":{\"189\":1}}],[\"将主键为50的这行数据\",{\"1\":{\"205\":1}}],[\"将后半段数据移动到page3\",{\"1\":{\"205\":1}}],[\"将page1中50\",{\"1\":{\"205\":1}}],[\"将page分为三种类型\",{\"1\":{\"61\":1}}],[\"将准备好的数据加载到数据表内\",{\"1\":{\"202\":1}}],[\"将数据量的存储起来\",{\"1\":{\"220\":1}}],[\"将数据分组提交\",{\"1\":{\"200\":1}}],[\"将数据表内的所有数据全部清空\",{\"1\":{\"177\":1}}],[\"将数据和索引分开存储\",{\"1\":{\"124\":1}}],[\"将数据和索引的存储放到了一块\",{\"1\":{\"124\":1}}],[\"将使用第一个唯一unique索引作为聚集索引\",{\"1\":{\"124\":1}}],[\"将键值换算成新的hash值\",{\"1\":{\"121\":1}}],[\"将字符串str全部转成大写\",{\"1\":{\"53\":1}}],[\"将字符串str全部转成小写\",{\"1\":{\"53\":1}}],[\"将s1\",{\"1\":{\"53\":1}}],[\"将syn同步位置为1\",{\"1\":{\"15\":1}}],[\"将新节点插入表中\",{\"1\":{\"37\":1}}],[\"将被删除的元素赋值给\",{\"1\":{\"36\":1}}],[\"将第\",{\"1\":{\"36\":2}}],[\"将fin置为1\",{\"1\":{\"17\":1}}],[\"将fin位置为1\",{\"1\":{\"17\":1}}],[\"将ack位置为1\",{\"1\":{\"17\":1}}],[\"四次挥手是发生在tcp的连接释放过程中\",{\"1\":{\"17\":1}}],[\"四次挥手\",{\"0\":{\"17\":1}}],[\"四次握手将会导致连接时间变长\",{\"1\":{\"16\":1}}],[\"肯定是更加的安全和可靠\",{\"1\":{\"16\":1}}],[\"再进行判断\",{\"1\":{\"516\":1}}],[\"再进行一次抽样\",{\"1\":{\"455\":2}}],[\"再读数据\",{\"1\":{\"422\":1}}],[\"再跟上元素\",{\"1\":{\"421\":1}}],[\"再次调用\",{\"1\":{\"408\":1}}],[\"再次存储\",{\"1\":{\"342\":1}}],[\"再次建立连接\",{\"1\":{\"16\":1}}],[\"再判断\",{\"1\":{\"300\":1}}],[\"再执行set\",{\"1\":{\"298\":2}}],[\"再执行循环体中的sql语句\",{\"1\":{\"249\":1}}],[\"再往缓存中存储数据时就会有额外的性能开销\",{\"1\":{\"273\":1}}],[\"再也不会被访问到\",{\"1\":{\"273\":1}}],[\"再更新缓存\",{\"1\":{\"272\":1}}],[\"再不损失精度的前提下\",{\"1\":{\"229\":1}}],[\"再哈希法\",{\"1\":{\"121\":1}}],[\"再将数据从内核中拷贝至用户空间\",{\"1\":{\"403\":1}}],[\"再将数据恢复到\",{\"1\":{\"62\":1}}],[\"再将合并后的数据写回磁盘内\",{\"1\":{\"62\":1}}],[\"再从磁盘加载并且缓存\",{\"1\":{\"61\":1}}],[\"再删除父表数据时产生的约束行为\",{\"1\":{\"50\":1}}],[\"再返回\",{\"1\":{\"24\":1}}],[\"再阅读本文\",{\"1\":{\"20\":1}}],[\"再发一个连接请求报文段\",{\"1\":{\"16\":1}}],[\"同一个数据库的不同表可以选择不同的存储引擎\",{\"1\":{\"232\":1}}],[\"同理\",{\"1\":{\"205\":1}}],[\"同理即可\",{\"1\":{\"16\":1}}],[\"同时还满足\",{\"1\":{\"477\":1}}],[\"同时失效或者\",{\"1\":{\"271\":1}}],[\"同时成立\",{\"1\":{\"187\":1}}],[\"同时锁住数据\",{\"1\":{\"146\":1}}],[\"同时却也降低更新表的速度\",{\"1\":{\"114\":1}}],[\"同样\",{\"1\":{\"23\":1,\"62\":1}}],[\"同意连接\",{\"1\":{\"16\":1}}],[\"同步和异步\",{\"0\":{\"413\":1}}],[\"同步刷盘\",{\"1\":{\"320\":1}}],[\"同步发送状态\",{\"1\":{\"15\":1}}],[\"同步收到\",{\"1\":{\"15\":2}}],[\"同步已发送状态\",{\"1\":{\"15\":1}}],[\"则一般称为多处理器系统\",{\"1\":{\"557\":1}}],[\"则一个extent内包含了64个page\",{\"1\":{\"204\":1}}],[\"则直接跳出循环\",{\"1\":{\"516\":1}}],[\"则直接写入ht\",{\"1\":{\"438\":1}}],[\"则相加之后必为一个\",{\"1\":{\"482\":1}}],[\"则相同的在数据删除时\",{\"1\":{\"205\":1}}],[\"则说明可以跳到下一个位置\",{\"1\":{\"516\":1}}],[\"则说明值太大了\",{\"1\":{\"481\":1}}],[\"则说明值太小了\",{\"1\":{\"481\":1}}],[\"则说明对象无人引用\",{\"1\":{\"465\":1}}],[\"则下一步必然是更新i++\",{\"1\":{\"481\":1}}],[\"则三者之和必小于0\",{\"1\":{\"481\":1}}],[\"则更新后的三者必不可能为0\",{\"1\":{\"481\":1}}],[\"则就不会再被使用\",{\"1\":{\"470\":1}}],[\"则就可以通过索引进行查询\",{\"1\":{\"210\":1}}],[\"则写到\",{\"1\":{\"462\":1}}],[\"则是单线程\",{\"1\":{\"458\":1}}],[\"则计数器\",{\"1\":{\"456\":1}}],[\"则使用该饼干\",{\"1\":{\"492\":1}}],[\"则使用到该对象的次数和频率都会很低\",{\"1\":{\"469\":1}}],[\"则使用\",{\"1\":{\"443\":1}}],[\"则使用一个字节保存这个长度\",{\"1\":{\"443\":1}}],[\"则新size为第一个大于等于dict\",{\"1\":{\"438\":4}}],[\"则新空间为扩展后字符串长度\",{\"1\":{\"427\":1}}],[\"则新空间扩展后字符串长度的两倍\",{\"1\":{\"427\":1}}],[\"则查询效率会大大降低\",{\"1\":{\"437\":1}}],[\"则查询出来的数据是两张表的笛卡尔积组合\",{\"1\":{\"93\":1}}],[\"则代表该对象没有被引用\",{\"1\":{\"470\":1}}],[\"则代表\",{\"1\":{\"448\":2}}],[\"则代表不存在\",{\"1\":{\"421\":1}}],[\"则代表空字符串\",{\"1\":{\"421\":1}}],[\"则遍历\",{\"1\":{\"406\":1}}],[\"则将该位置的\",{\"1\":{\"405\":1}}],[\"则用户进程可以直接进入第二阶段\",{\"1\":{\"404\":1}}],[\"则立刻返回\",{\"1\":{\"403\":1}}],[\"则立刻发送确认报文段\",{\"1\":{\"17\":1}}],[\"则创建一个队列\",{\"1\":{\"386\":1}}],[\"则创建的是常规索引\",{\"1\":{\"127\":1}}],[\"则必须修改redis配置文件\",{\"1\":{\"369\":1}}],[\"则必须关闭redis服务\",{\"1\":{\"368\":1}}],[\"则调用\",{\"1\":{\"359\":1}}],[\"则释放资源\",{\"1\":{\"351\":1}}],[\"则根据\",{\"1\":{\"343\":1}}],[\"则集群开始创建\",{\"1\":{\"341\":1}}],[\"则判定服务下线\",{\"1\":{\"328\":1}}],[\"则判断\",{\"1\":{\"326\":1}}],[\"则永不参与选举\",{\"1\":{\"326\":1}}],[\"则该实例客观下线\",{\"1\":{\"325\":1}}],[\"则该视图就不可更新\",{\"1\":{\"166\":1}}],[\"则认为该实例主观下线\",{\"1\":{\"325\":1}}],[\"则触发重写\",{\"1\":{\"320\":1}}],[\"则触发器会触发三次\",{\"1\":{\"153\":1}}],[\"则需要先求f\",{\"1\":{\"498\":3,\"521\":3}}],[\"则需要将后续的所有节点进行移动\",{\"1\":{\"443\":1}}],[\"则需要两倍原来的内存\",{\"1\":{\"319\":1}}],[\"则需要对数据进行拷贝\",{\"1\":{\"319\":1}}],[\"则需要移动除表头元素以外的所有元素\",{\"1\":{\"36\":1}}],[\"则服务不可用\",{\"1\":{\"318\":1}}],[\"则运行\",{\"1\":{\"305\":1}}],[\"则可以推断到达任何一的网格之中仅有两种方式\",{\"1\":{\"511\":1}}],[\"则可以求的结果\",{\"1\":{\"498\":1,\"521\":1}}],[\"则可以将对象序列化为json字符串后存储\",{\"1\":{\"376\":1}}],[\"则可以采用\",{\"1\":{\"301\":1}}],[\"则可以继续进行传输数据\",{\"1\":{\"17\":1}}],[\"则执行\",{\"1\":{\"319\":3}}],[\"则执行增量同步\",{\"1\":{\"301\":1}}],[\"则执行逻辑\",{\"1\":{\"249\":1}}],[\"则\",{\"1\":{\"270\":1,\"442\":2,\"468\":1}}],[\"则开启自动提交\",{\"1\":{\"256\":1}}],[\"则开启下一个页\",{\"1\":{\"205\":1}}],[\"则继续下一次循环\",{\"1\":{\"250\":1}}],[\"则退出\",{\"1\":{\"250\":1}}],[\"则表示没有使用索引\",{\"1\":{\"229\":1}}],[\"则会多循环一次\",{\"1\":{\"481\":1}}],[\"则会采用int\",{\"1\":{\"415\":1}}],[\"则会采用\",{\"1\":{\"415\":1}}],[\"则会排除该\",{\"1\":{\"326\":1}}],[\"则会拷贝一份数据\",{\"1\":{\"319\":1}}],[\"则会继承\",{\"1\":{\"300\":1}}],[\"则会被视为慢查询\",{\"1\":{\"227\":1}}],[\"则会占用的是整张表的资源\",{\"1\":{\"224\":1}}],[\"则再进行查询时\",{\"1\":{\"210\":1}}],[\"则再次发送确认报文段\",{\"1\":{\"16\":1}}],[\"则此时不会以默认的\",{\"1\":{\"240\":1}}],[\"则此时需要进行数据的移动\",{\"1\":{\"205\":1}}],[\"则此时客户端就不能够再发送数据\",{\"1\":{\"17\":1}}],[\"则向日志表中插入一条数据\",{\"1\":{\"157\":1,\"158\":1,\"159\":1}}],[\"则不会使用索引\",{\"1\":{\"129\":1}}],[\"则不走索引\",{\"1\":{\"129\":1}}],[\"则索引失效\",{\"1\":{\"129\":1}}],[\"则从哪里断开\",{\"1\":{\"129\":1}}],[\"则走索引\",{\"1\":{\"129\":2}}],[\"则在筛选该数据记录值时会进行全表扫描\",{\"1\":{\"224\":1}}],[\"则在使用的时候根据\",{\"1\":{\"129\":1}}],[\"则在长度为\",{\"1\":{\"36\":3}}],[\"则建立哈希索引\",{\"1\":{\"64\":1}}],[\"则也删除\",{\"1\":{\"50\":1}}],[\"则赋予该默认值\",{\"1\":{\"47\":1}}],[\"则当单链表长为\",{\"1\":{\"37\":1}}],[\"则只需要比较一次\",{\"1\":{\"36\":1}}],[\"则无需插入\",{\"1\":{\"432\":1}}],[\"则无需移动元素\",{\"1\":{\"36\":1}}],[\"则无法共享\",{\"1\":{\"469\":1}}],[\"则无法实现增量同步\",{\"1\":{\"301\":1}}],[\"则无法插入\",{\"1\":{\"36\":1}}],[\"则平均时间复杂度为\",{\"1\":{\"36\":3}}],[\"则返回1\",{\"1\":{\"398\":1}}],[\"则返回res2\",{\"1\":{\"56\":1}}],[\"则返回res1\",{\"1\":{\"56\":1}}],[\"则返回value1\",{\"1\":{\"56\":1}}],[\"则返回t\",{\"1\":{\"56\":1}}],[\"则返回true\",{\"1\":{\"35\":1}}],[\"则返回\",{\"1\":{\"36\":2}}],[\"则为\",{\"1\":{\"30\":2}}],[\"则对应的时间复杂度\",{\"1\":{\"27\":1}}],[\"则对应的时间复杂度为\",{\"1\":{\"24\":1,\"29\":1}}],[\"则浪费更多的资源\",{\"1\":{\"16\":1}}],[\"则现在客户端只有一个连接\",{\"1\":{\"16\":1}}],[\"则做出响应\",{\"1\":{\"16\":1}}],[\"则进行超时重传\",{\"1\":{\"16\":1}}],[\"如同交通规则制约汽车驾驶一样\",{\"1\":{\"569\":1}}],[\"如网卡\",{\"1\":{\"569\":1}}],[\"如路由器\",{\"1\":{\"569\":1}}],[\"如双绞线\",{\"1\":{\"569\":1}}],[\"如仅1m的数量级或甚至更小\",{\"1\":{\"557\":1}}],[\"如上图所示\",{\"1\":{\"514\":2}}],[\"如java语言的jedis客户端\",{\"1\":{\"374\":1}}],[\"如操作系统\",{\"1\":{\"569\":1}}],[\"如操作\",{\"1\":{\"359\":1}}],[\"如下\",{\"1\":{\"346\":1}}],[\"如图片等\",{\"1\":{\"425\":1}}],[\"如图\",{\"1\":{\"330\":1}}],[\"如请求不存在的数据\",{\"1\":{\"270\":1}}],[\"如02000\",{\"1\":{\"253\":1}}],[\"如sql接口\",{\"1\":{\"231\":1}}],[\"如未使用索引字段进行数据更新\",{\"1\":{\"224\":1}}],[\"如何建立联系\",{\"1\":{\"444\":1}}],[\"如何将同一类数据固定的保存在同一个\",{\"1\":{\"343\":1}}],[\"如何判断一个\",{\"1\":{\"328\":1}}],[\"如何不可避免的出现filesort\",{\"1\":{\"211\":1}}],[\"如何保证数据并发访问的一致性\",{\"1\":{\"136\":1}}],[\"如身份证号\",{\"1\":{\"207\":1}}],[\"如limit\",{\"1\":{\"192\":1}}],[\"如一个sql语句更新了3行数据\",{\"1\":{\"153\":1}}],[\"如为\",{\"1\":{\"129\":1}}],[\"如对表进行insert\",{\"1\":{\"114\":1}}],[\"如数字\",{\"1\":{\"99\":1}}],[\"如学生和课程之间的关系\",{\"1\":{\"92\":1}}],[\"如\",{\"1\":{\"80\":1,\"121\":1,\"217\":1,\"231\":1}}],[\"如栈\",{\"1\":{\"32\":1}}],[\"如类实例化的一个对象就是数据元素\",{\"1\":{\"32\":1}}],[\"如若第二次服务端接收到了请求\",{\"1\":{\"16\":1}}],[\"如果想等则已经巡视完全程\",{\"1\":{\"516\":1}}],[\"如果可以\",{\"1\":{\"492\":1}}],[\"如果连最小的数都是\",{\"1\":{\"482\":1}}],[\"如果对复杂度较高的对象创建共享对象\",{\"1\":{\"469\":1}}],[\"如果对数据安全性要求较高\",{\"1\":{\"321\":1}}],[\"如果共享对象是包含多个值的对象\",{\"1\":{\"469\":1}}],[\"如果共享对象是保存字符串值的字符串对象\",{\"1\":{\"469\":1}}],[\"如果共享对象是保存字符串对象\",{\"1\":{\"469\":1}}],[\"如果c\",{\"1\":{\"462\":1}}],[\"如果count函数的参数不是null\",{\"1\":{\"221\":1}}],[\"如果针对\",{\"1\":{\"458\":1}}],[\"如果仅仅针对\",{\"1\":{\"458\":1}}],[\"如果仅仅是尾部模糊匹配\",{\"1\":{\"129\":1}}],[\"如果没找到\",{\"1\":{\"468\":1}}],[\"如果没达到时间上限\",{\"1\":{\"455\":2}}],[\"如果没有就绪\",{\"1\":{\"405\":1}}],[\"如果没有准备就绪那么就会一直等待\",{\"1\":{\"402\":1}}],[\"如果没有指定session\",{\"1\":{\"242\":1}}],[\"如果没有指定schema\",{\"1\":{\"155\":1}}],[\"如果没有主键\",{\"1\":{\"124\":1}}],[\"如果没有找到\",{\"1\":{\"36\":1}}],[\"如果已经过期\",{\"1\":{\"455\":1}}],[\"如果已经存在则更新其score值\",{\"1\":{\"380\":1}}],[\"如果我们要想在其中查找某个数据\",{\"1\":{\"450\":1}}],[\"如果值为负\",{\"1\":{\"448\":1}}],[\"如果值为正\",{\"1\":{\"448\":1}}],[\"如果内存占用较多\",{\"1\":{\"444\":1}}],[\"如果列表数据较多\",{\"1\":{\"444\":1}}],[\"如果后续空间不足\",{\"1\":{\"443\":1}}],[\"如果保存在redis中的键值对只有几个几十个\",{\"1\":{\"438\":1}}],[\"如果执行扩展操作\",{\"1\":{\"437\":1}}],[\"如果执⾏命令后hll估计的近似基数发⽣变化\",{\"1\":{\"398\":1}}],[\"如果找到了\",{\"1\":{\"432\":1}}],[\"如果新字符串大于\",{\"1\":{\"427\":1}}],[\"如果新字符串小于\",{\"1\":{\"427\":1}}],[\"如果大于等于254字节\",{\"1\":{\"443\":1}}],[\"如果大小为\",{\"1\":{\"421\":1}}],[\"如果大小为0\",{\"1\":{\"421\":1}}],[\"如果大多数\",{\"1\":{\"328\":1}}],[\"如果存储的字符串是整数型\",{\"1\":{\"415\":1}}],[\"如果存储的\",{\"1\":{\"415\":1}}],[\"如果存在和排序列表中相符合或者完全相反的索引\",{\"1\":{\"210\":1}}],[\"如果存在多个查询条件\",{\"1\":{\"133\":1}}],[\"如果存在主键\",{\"1\":{\"124\":1}}],[\"如果监听较多\",{\"1\":{\"410\":1}}],[\"如果正在处理\",{\"1\":{\"404\":1}}],[\"如果调用\",{\"1\":{\"404\":2}}],[\"如果数据没有就绪\",{\"1\":{\"403\":1}}],[\"如果指定的队列不存在\",{\"1\":{\"386\":1}}],[\"如果出现网络断开\",{\"1\":{\"385\":1}}],[\"如果jedis被使用过\",{\"1\":{\"351\":1}}],[\"如果要降序则在命令的z后面添加rev即可\",{\"1\":{\"380\":1}}],[\"如果要让redis以后台方式启动\",{\"1\":{\"369\":1}}],[\"如果要关闭所有进程\",{\"1\":{\"340\":1}}],[\"如果要一键停止\",{\"1\":{\"296\":1}}],[\"如果超过一定时间没有相向则认为是主观下线\",{\"1\":{\"328\":1}}],[\"如果超过指定值\",{\"1\":{\"326\":1}}],[\"如果某\",{\"1\":{\"325\":1}}],[\"如果至少有\",{\"1\":{\"319\":3}}],[\"如果你想安装命令行工具\",{\"1\":{\"305\":1}}],[\"如果你需要设置函数为局部函数需要使用关键字\",{\"1\":{\"291\":1}}],[\"如果提示说命令不存在\",{\"1\":{\"305\":1}}],[\"如果实在是太多\",{\"1\":{\"301\":1}}],[\"如果未命中则查询数据库\",{\"1\":{\"279\":1}}],[\"如果未指定该字段的值\",{\"1\":{\"47\":1}}],[\"如果过限\",{\"1\":{\"276\":1,\"456\":1}}],[\"如果缓存写满了\",{\"1\":{\"273\":1}}],[\"如果不相符\",{\"1\":{\"468\":1}}],[\"如果不存在就创建\",{\"1\":{\"386\":1,\"393\":1}}],[\"如果不存在匹配串返回nil\",{\"1\":{\"291\":1}}],[\"如果不存在主键\",{\"1\":{\"124\":1}}],[\"如果不在sql逻辑中增加退出循环的条件\",{\"1\":{\"251\":1}}],[\"如果不满足\",{\"1\":{\"250\":1}}],[\"如果满足\",{\"1\":{\"250\":1}}],[\"如果条件为true\",{\"1\":{\"249\":1}}],[\"如果应用是以读操作和插入操作为主\",{\"1\":{\"237\":1}}],[\"如果应用对事务的完整性有比较高的要求\",{\"1\":{\"237\":1}}],[\"如果为null\",{\"1\":{\"229\":1}}],[\"如果全部都能通过索引则仅为using\",{\"1\":{\"210\":1}}],[\"如果一行的数据过大\",{\"1\":{\"205\":1}}],[\"如果一次性需要插入大量的数据\",{\"1\":{\"202\":1}}],[\"如果查询的是第一页数据\",{\"1\":{\"192\":1}}],[\"如果视图包含了以下任意一项\",{\"1\":{\"166\":1}}],[\"如果在事务执行之前这个\",{\"1\":{\"399\":1}}],[\"如果在从库上备份\",{\"1\":{\"140\":1}}],[\"如果在主库上备份\",{\"1\":{\"140\":1}}],[\"如果索引列不能存储null值\",{\"1\":{\"134\":1}}],[\"如果索引了多列\",{\"1\":{\"129\":1}}],[\"如果mysql评估使用索引比全表更慢\",{\"1\":{\"129\":1}}],[\"如果or前的条件中的列有索引\",{\"1\":{\"129\":1}}],[\"如果是普通的数组\",{\"1\":{\"441\":1}}],[\"如果是则将dict\",{\"1\":{\"438\":1}}],[\"如果是收缩\",{\"1\":{\"438\":2}}],[\"如果是扩容\",{\"1\":{\"438\":2}}],[\"如果是\",{\"1\":{\"326\":1,\"343\":1}}],[\"如果是多字段排序\",{\"1\":{\"191\":1}}],[\"如果是字符串类型和字段\",{\"1\":{\"134\":1}}],[\"如果是开头模糊匹配\",{\"1\":{\"129\":1}}],[\"如果是四次握手\",{\"1\":{\"16\":1}}],[\"如果跳跃某一列\",{\"1\":{\"129\":1}}],[\"如果都不选的话\",{\"1\":{\"127\":1}}],[\"如果\",{\"1\":{\"86\":1,\"300\":1,\"301\":1,\"318\":1,\"324\":1,\"326\":1,\"438\":1,\"456\":1,\"491\":1,\"514\":1}}],[\"如果表结构没有指定主键\",{\"1\":{\"82\":1}}],[\"如果表是在系统表空间而不是每个表文件或通用表空间中创建的\",{\"1\":{\"66\":1}}],[\"如果观察到哈希索引可以提升速度\",{\"1\":{\"64\":1}}],[\"如果需要更新\",{\"1\":{\"63\":1}}],[\"如果每一次都操作磁盘\",{\"1\":{\"62\":1}}],[\"如果这些数据page没有在buffer\",{\"1\":{\"62\":1}}],[\"如果expr的值等于val1\",{\"1\":{\"56\":1}}],[\"如果val2为true\",{\"1\":{\"56\":1}}],[\"如果val1为true\",{\"1\":{\"56\":1}}],[\"如果value是一个java对象\",{\"1\":{\"376\":1}}],[\"如果value1不为null\",{\"1\":{\"56\":1}}],[\"如果value为true\",{\"1\":{\"56\":1}}],[\"如果有则设置子表中该外键值为null\",{\"1\":{\"50\":1}}],[\"如果有则不允许删除\",{\"1\":{\"50\":2}}],[\"如果有\",{\"1\":{\"50\":1,\"516\":1}}],[\"如果网络信道非常差\",{\"1\":{\"16\":1}}],[\"如果从持久层查不到数据则不写入缓存层\",{\"1\":{\"2\":1}}],[\"如果以做出完美的笔记为目的\",{\"1\":{\"2\":1}}],[\"即用户不可见的\",{\"1\":{\"567\":1}}],[\"即最小值为math\",{\"1\":{\"534\":1}}],[\"即dp数组的最后一个数并不一定是最小的花费\",{\"1\":{\"534\":1}}],[\"即此时\",{\"1\":{\"534\":1}}],[\"即该阶梯前两个阶梯的最小花费\",{\"1\":{\"534\":1}}],[\"即该操作是需要将两者同时进行更新的\",{\"1\":{\"481\":1}}],[\"即无法巡视完棋盘\",{\"1\":{\"516\":1}}],[\"即判断\",{\"1\":{\"516\":1}}],[\"即f\",{\"1\":{\"498\":1}}],[\"即使用三个指针i\",{\"1\":{\"480\":1}}],[\"即其它对象中嵌套了字符串对象\",{\"1\":{\"469\":1}}],[\"即每秒执行10次\",{\"1\":{\"455\":1}}],[\"即每张表都有独立的空间\",{\"1\":{\"67\":1}}],[\"即便链表中存储的数据是有序的\",{\"1\":{\"450\":1}}],[\"即client\",{\"1\":{\"421\":1}}],[\"即消息长度\",{\"1\":{\"385\":1,\"389\":1}}],[\"即可选择向上爬一个或者两个台阶\",{\"1\":{\"532\":1}}],[\"即可后台启动redis\",{\"1\":{\"369\":1}}],[\"即可\",{\"1\":{\"344\":1}}],[\"即这些操作要么同时成功\",{\"1\":{\"255\":1}}],[\"即这些操作要么同时成功要么同时失败\",{\"1\":{\"74\":1}}],[\"即定义为\",{\"1\":{\"240\":1}}],[\"即外层的查询\",{\"1\":{\"229\":1}}],[\"即不使用表连接或者子查询\",{\"1\":{\"229\":1}}],[\"即只要从左往右开始\",{\"1\":{\"210\":1}}],[\"即以什么标准判断数据行之间的分隔\",{\"1\":{\"202\":1}}],[\"即下一小节\",{\"1\":{\"177\":1}}],[\"即保证返回的字段\",{\"1\":{\"131\":1}}],[\"即尽量保证所需要的数据在使用索引内包含\",{\"1\":{\"131\":1}}],[\"即索引列表有多个字段\",{\"1\":{\"127\":1}}],[\"即多个键值对映射到了同一个槽位上\",{\"1\":{\"121\":1}}],[\"即在sql语句中嵌套使用select语句\",{\"1\":{\"98\":1}}],[\"即按行将两张表排列组合\",{\"1\":{\"93\":1}}],[\"即事务已经提交了\",{\"1\":{\"86\":1}}],[\"即当前还未提交的事务id集合\",{\"1\":{\"85\":1}}],[\"即一个索引值包含了多个列\",{\"1\":{\"133\":1}}],[\"即一个索引值包含了单个列\",{\"1\":{\"133\":1}}],[\"即一个区中一共有64个连续的页\",{\"1\":{\"58\":1}}],[\"即一共循环了\",{\"1\":{\"22\":1}}],[\"即头结点之后\",{\"1\":{\"37\":1}}],[\"即\",{\"1\":{\"36\":2,\"446\":1,\"516\":1}}],[\"即通过首地址和元素需要可在\",{\"1\":{\"36\":1}}],[\"即l中元素的个数\",{\"1\":{\"35\":1}}],[\"即从逻辑关系上描述数据\",{\"1\":{\"33\":1}}],[\"即同属于一个类的对象实例\",{\"1\":{\"32\":1}}],[\"即客户端发送连接请求\",{\"1\":{\"16\":1}}],[\"即发送的数据有可能存在丢失或者延迟发送的可能\",{\"1\":{\"16\":1}}],[\"即收到大量的连接请求而占用资源\",{\"1\":{\"15\":1}}],[\"这时nums\",{\"1\":{\"481\":1}}],[\"这时候还需要解决的一个问题是遍历元素时如何定位下一个元素呢\",{\"1\":{\"441\":1}}],[\"这时候就需要使用profile分析\",{\"1\":{\"227\":1}}],[\"这时候的查询过程为\",{\"1\":{\"125\":1}}],[\"这多个\",{\"1\":{\"444\":1}}],[\"这代表每次写操作都会进行内存分配操作\",{\"1\":{\"443\":1}}],[\"这和计算基数时\",{\"1\":{\"398\":1}}],[\"这⾥我选择的是another\",{\"1\":{\"373\":1}}],[\"这也是一种常见的文档编写规范\",{\"1\":{\"372\":1}}],[\"这一概念无疑是一种全新的思维的注入\",{\"1\":{\"363\":1}}],[\"这一类数据使用相同的有效部分\",{\"1\":{\"343\":1}}],[\"这次可以了\",{\"1\":{\"342\":1}}],[\"这部分开销主要是指往缓存中写数据时判断缓存淘汰策略\",{\"1\":{\"273\":1}}],[\"这些都是redis操作过程中的一些常见指令\",{\"1\":{\"361\":1}}],[\"这些请求都会打到数据库\",{\"1\":{\"270\":1}}],[\"这些数据结构以某种方式饮用\",{\"1\":{\"113\":1}}],[\"这条sql是通过全表扫描进行查询的\",{\"1\":{\"210\":1}}],[\"这两个实际上没有区别\",{\"1\":{\"243\":1}}],[\"这两个角度来探究这个问题\",{\"1\":{\"205\":1}}],[\"这两种情况时\",{\"1\":{\"227\":1}}],[\"这两次握手\",{\"1\":{\"16\":1}}],[\"这是能让孩子们满足胃口的饼干的最小尺寸\",{\"1\":{\"491\":1}}],[\"这是一个链表\",{\"1\":{\"462\":1}}],[\"这是\",{\"1\":{\"459\":1}}],[\"这是新手阶段容易忽视的一点\",{\"1\":{\"372\":1}}],[\"这是因为\",{\"1\":{\"352\":1,\"425\":1}}],[\"这是为什么呢\",{\"1\":{\"352\":1}}],[\"这是由于mysql底层的数据结构造成的\",{\"1\":{\"201\":1}}],[\"这是最好的索引选择性\",{\"1\":{\"132\":1}}],[\"这类sql开发人员操作的比较少\",{\"1\":{\"195\":1}}],[\"这本工具书\",{\"1\":{\"171\":1}}],[\"这与其他的数据库是相似的\",{\"1\":{\"153\":1}}],[\"这并不是一条sql语句\",{\"1\":{\"139\":1}}],[\"这会让索引变得很大\",{\"1\":{\"132\":1}}],[\"这个孩子会得到满足\",{\"1\":{\"491\":1}}],[\"这个值越大则淘汰优先级越高\",{\"1\":{\"456\":1}}],[\"这个参数是控制首尾不压缩的节点个数\",{\"1\":{\"448\":1}}],[\"这个结构是\",{\"1\":{\"446\":1}}],[\"这个规范就是通信协议\",{\"1\":{\"421\":1}}],[\"这个阶段用户进程是阻塞的\",{\"1\":{\"403\":1}}],[\"这个过程称为\",{\"1\":{\"438\":1}}],[\"这个过程用户进程是非阻塞的\",{\"1\":{\"403\":1}}],[\"这个过程我们就叫做回表查询\",{\"1\":{\"125\":1}}],[\"这个消息就会被发送给订阅它的三个客户端\",{\"1\":{\"381\":1}}],[\"这个格式并非固定\",{\"1\":{\"376\":1}}],[\"这个依赖项\",{\"1\":{\"353\":1}}],[\"这个\",{\"1\":{\"344\":1}}],[\"这个方法写在项目启动类中\",{\"1\":{\"334\":1}}],[\"这个文件来决定\",{\"1\":{\"309\":1}}],[\"这个路径的监听\",{\"1\":{\"309\":1}}],[\"这个最简单\",{\"1\":{\"288\":1}}],[\"这个顺序来判断是否走索引\",{\"1\":{\"129\":1}}],[\"这个字段在后面的mvcc版本控制时会使用到\",{\"1\":{\"58\":1}}],[\"这样可使程序避免了重复分配的麻烦\",{\"1\":{\"469\":1}}],[\"这样可以确保ht\",{\"1\":{\"438\":1}}],[\"这样可以大大节约索引空间\",{\"1\":{\"132\":1}}],[\"这样可以极大的提高数据库的性能\",{\"1\":{\"73\":1}}],[\"这样查找效率就会很低\",{\"1\":{\"450\":1}}],[\"这样在进行渐进式\",{\"1\":{\"438\":1}}],[\"这样的高并发场景\",{\"1\":{\"318\":1}}],[\"这样就可以便于未来安装或更新我们的软件包\",{\"1\":{\"305\":1}}],[\"这样就可以在这些数据结构上实现高级查找算法\",{\"1\":{\"113\":1}}],[\"这样\",{\"1\":{\"304\":1}}],[\"这样缓存永远不会生效\",{\"1\":{\"270\":1}}],[\"这样我们可以根据自己的需要\",{\"1\":{\"231\":1}}],[\"这样导致一页中存储的键值减少\",{\"1\":{\"122\":1}}],[\"这张中间表的字段最少包含了两个外键\",{\"1\":{\"92\":1}}],[\"这种特殊情况下产生的连续多次空间扩展操作称之为\",{\"1\":{\"443\":1}}],[\"这种方式通过记录字符串长度\",{\"1\":{\"421\":1}}],[\"这种情况\",{\"1\":{\"516\":1}}],[\"这种情况会导致数据的存储和查找变得复杂\",{\"1\":{\"435\":1}}],[\"这种情况即为using\",{\"1\":{\"209\":1}}],[\"这种情况经常用于多表的拆分\",{\"1\":{\"90\":1}}],[\"这种存储方式的表称为索引组织表\",{\"1\":{\"204\":1}}],[\"这种数据结构就是索引\",{\"1\":{\"113\":1}}],[\"这种关系的实现相对来说较为复杂\",{\"1\":{\"92\":1}}],[\"这种关系也是我们经常遇到的一种关系\",{\"1\":{\"92\":1}}],[\"这种关系就是一对多关系\",{\"1\":{\"91\":1}}],[\"这就容易造成混淆\",{\"1\":{\"243\":1}}],[\"这就是一种多对多的关系\",{\"1\":{\"92\":1}}],[\"这就要求该外键允许取null\",{\"1\":{\"50\":1}}],[\"这就使得服务器容易遭受syn洪范攻击\",{\"1\":{\"15\":1}}],[\"这里也可以逆向思维\",{\"1\":{\"492\":1}}],[\"这里也是满足索引的最左前缀法则\",{\"1\":{\"210\":1}}],[\"这里将i和j都进行更新\",{\"1\":{\"482\":1}}],[\"这里将nginx\",{\"1\":{\"306\":1}}],[\"这里让k\",{\"1\":{\"482\":1}}],[\"这里需要判断\",{\"1\":{\"516\":1}}],[\"这里需要说明一下的是\",{\"1\":{\"481\":1}}],[\"这里需要小于\",{\"1\":{\"481\":1}}],[\"这里不做过多赘述\",{\"1\":{\"480\":1}}],[\"这里不再赘述\",{\"1\":{\"366\":1}}],[\"这里只有\",{\"1\":{\"467\":1}}],[\"这里因为空间不够\",{\"1\":{\"427\":1}}],[\"这里写的是\",{\"1\":{\"419\":1}}],[\"这里写的是去数据库查询的业务逻辑\",{\"1\":{\"282\":1}}],[\"这里就不做过多赘述\",{\"1\":{\"492\":1}}],[\"这里就不赘述\",{\"1\":{\"373\":1}}],[\"这里就只了解增\",{\"1\":{\"179\":1}}],[\"这里要注意的是\",{\"1\":{\"372\":1}}],[\"这里options为选项\",{\"1\":{\"372\":1}}],[\"这里以操作string类型为例\",{\"1\":{\"351\":1}}],[\"这里设置为\",{\"1\":{\"347\":3}}],[\"这里选取\",{\"1\":{\"345\":1}}],[\"这里输入\",{\"1\":{\"344\":1}}],[\"这里输入yes\",{\"1\":{\"341\":1}}],[\"这里返回\",{\"1\":{\"309\":1}}],[\"这里会用到两个很重要的概念\",{\"1\":{\"300\":1}}],[\"这里我们会在同一台虚拟机中开启6个redis实例\",{\"1\":{\"338\":1}}],[\"这里我们会在同一台虚拟机中开启3个redis实例\",{\"1\":{\"294\":1}}],[\"这里我们搭建一个最小的分片集群\",{\"1\":{\"338\":1}}],[\"这里我们搭建一个三节点形成的sentinel集群\",{\"1\":{\"330\":1}}],[\"这里我们使用\",{\"1\":{\"308\":1}}],[\"这里我们为了演示方便\",{\"1\":{\"297\":1}}],[\"这里我个人理解的是\",{\"1\":{\"239\":1}}],[\"这里表示感谢\",{\"1\":{\"266\":1}}],[\"这里查询完成以后就能够看到增删改查的执行次数\",{\"1\":{\"226\":1}}],[\"这里一共有7个空格\",{\"1\":{\"226\":1}}],[\"这里一一进行说明\",{\"1\":{\"20\":1}}],[\"这里删除数据的筛选条件可有可无\",{\"1\":{\"182\":1}}],[\"这里修改数据的筛选条件可有可无\",{\"1\":{\"181\":1}}],[\"这里的extent和page的空间大小是固定的\",{\"1\":{\"204\":1}}],[\"这里的\",{\"1\":{\"177\":1,\"256\":1,\"310\":1}}],[\"这里的功能可以看作\",{\"1\":{\"177\":1}}],[\"这里的具体细节可以去学习数据结构中的b树\",{\"1\":{\"118\":1}}],[\"这里在此对黑马开源教学视频\",{\"1\":{\"171\":1,\"266\":1}}],[\"这里仅对外键约束做详细介绍\",{\"1\":{\"48\":1}}],[\"这里实现了顺序表的插入\",{\"1\":{\"36\":1}}],[\"这里实际上就可以拆分为两条语句\",{\"1\":{\"24\":1}}],[\"这里主要对递归操作进行说明\",{\"1\":{\"30\":1}}],[\"这里主要总结数据结构中时间复杂度的计算方法\",{\"1\":{\"20\":1}}],[\"这里是先\",{\"1\":{\"24\":1}}],[\"这里确认报文段也不携带数据\",{\"1\":{\"15\":1}}],[\"而整个网络就像一个大的计算机系统一样对用户是透明的\",{\"1\":{\"567\":1}}],[\"而整数集合和压缩列表这些只能保存字符串\",{\"1\":{\"469\":1}}],[\"而没有提到\",{\"1\":{\"467\":1}}],[\"而用户在对集合进行操作时\",{\"1\":{\"464\":1}}],[\"而用户线程就会处于阻塞状态\",{\"1\":{\"402\":1}}],[\"而有些指令却能够针对所有的类型\",{\"1\":{\"464\":1}}],[\"而所有\",{\"1\":{\"425\":1}}],[\"而对于一些二进制文件\",{\"1\":{\"425\":1}}],[\"而在\",{\"1\":{\"421\":1}}],[\"而redis仅仅是一组命令的顺序执行集合\",{\"1\":{\"399\":1}}],[\"而无法进行其他操作\",{\"1\":{\"368\":1}}],[\"而无法优化的又被统计到\",{\"1\":{\"227\":1}}],[\"而使用的步骤与哨兵模式基本一致\",{\"1\":{\"346\":1}}],[\"而使用name字段查询\",{\"1\":{\"126\":1}}],[\"而小容量缓存不一定就起不到加速访问的效果\",{\"1\":{\"273\":1}}],[\"而存储过程是使用call调用\",{\"1\":{\"254\":1}}],[\"而且性能也会大打折扣\",{\"1\":{\"458\":1}}],[\"而且更耗费内存\",{\"1\":{\"419\":1}}],[\"而且内核空间与用户空间的频繁信号交互性能也较低\",{\"1\":{\"411\":1}}],[\"而且增删改查效率都非常高\",{\"1\":{\"410\":1}}],[\"而且忙等机制会导致\",{\"1\":{\"403\":1}}],[\"而且不能直接调用系统资源\",{\"1\":{\"401\":1}}],[\"而且里面的\",{\"1\":{\"352\":1}}],[\"而且\",{\"1\":{\"320\":1}}],[\"而且无法保障数据的安全性\",{\"1\":{\"237\":1}}],[\"而且只能有一个\",{\"1\":{\"124\":1}}],[\"而这些的命令中\",{\"1\":{\"464\":1}}],[\"而这些方式并不能够真正的评判一条sql的性能\",{\"1\":{\"229\":1}}],[\"而这类sql是非常需要我们进行优化的\",{\"1\":{\"227\":1}}],[\"而耗费的时间又在我们慢日志统计时间的临界值\",{\"1\":{\"227\":1}}],[\"而完全相反时只需要反向扫描即可\",{\"1\":{\"210\":1}}],[\"而不称为计算机网络\",{\"1\":{\"557\":1}}],[\"而不满足排序列表的索引则会通过全表扫描\",{\"1\":{\"209\":1}}],[\"而不是阻塞用户进程\",{\"1\":{\"403\":1}}],[\"而不是直接返回nil\",{\"1\":{\"378\":1}}],[\"而不是直接添加到页尾\",{\"1\":{\"205\":1}}],[\"而不是复制真实的数据\",{\"1\":{\"319\":1}}],[\"而不是\",{\"1\":{\"243\":1,\"428\":1}}],[\"而不是基于库的\",{\"1\":{\"232\":1}}],[\"而不是对记录加的锁\",{\"1\":{\"146\":1}}],[\"而不是比较索引中的值\",{\"1\":{\"124\":1}}],[\"而having可以\",{\"1\":{\"190\":1}}],[\"而having是在分组之后进行过滤\",{\"1\":{\"190\":1}}],[\"而delete\",{\"1\":{\"177\":1}}],[\"而local只会检查定义检查条件的视图\",{\"1\":{\"164\":1}}],[\"而非单列索引\",{\"1\":{\"133\":1}}],[\"而选择性是指不重复的索引值\",{\"1\":{\"132\":1}}],[\"而后面的列中没有索引\",{\"1\":{\"129\":1}}],[\"而第一条sql只查询了一次b+树\",{\"1\":{\"126\":1}}],[\"而主键会建立聚集索引\",{\"1\":{\"126\":1}}],[\"而是存储在数组\",{\"1\":{\"541\":1}}],[\"而是通过运算\",{\"1\":{\"456\":1}}],[\"而是在访问一个\",{\"1\":{\"455\":1}}],[\"而是在一次读或者写操作后\",{\"1\":{\"283\":1}}],[\"而是采用\",{\"1\":{\"454\":1}}],[\"而是采用了如下的结构\",{\"1\":{\"441\":1}}],[\"而是记录上一个节点和本节点长度来寻址\",{\"1\":{\"444\":1}}],[\"而是分多次\",{\"1\":{\"438\":1}}],[\"而是以\",{\"1\":{\"425\":1}}],[\"而是统一使用\",{\"1\":{\"355\":1}}],[\"而是与插槽绑定\",{\"1\":{\"343\":1}}],[\"而是我们设置的$$\",{\"1\":{\"240\":1}}],[\"而是专门做了优化\",{\"1\":{\"221\":1}}],[\"而是一条shell脚本\",{\"1\":{\"139\":1}}],[\"而是二级索引中的值\",{\"1\":{\"125\":1}}],[\"而是提供不可靠的包交换\",{\"1\":{\"14\":1}}],[\"而当我们的查询条件并不是聚集索引中的值\",{\"1\":{\"125\":1}}],[\"而innodb存储引擎中\",{\"1\":{\"204\":1}}],[\"而innodb中具有自适应hash功能\",{\"1\":{\"121\":1}}],[\"而io\",{\"1\":{\"73\":1}}],[\"而\",{\"1\":{\"97\":1,\"385\":1,\"406\":1,\"438\":1}}],[\"而一门课程中也可以有多个学生\",{\"1\":{\"92\":1}}],[\"而update\",{\"1\":{\"83\":1}}],[\"而会将数据变更存在更改缓冲区\",{\"1\":{\"62\":1}}],[\"而索引是从\",{\"1\":{\"36\":2}}],[\"而数组中元素的下标是从\",{\"1\":{\"36\":1}}],[\"而算法的视线依赖于所采用的存储结构\",{\"1\":{\"33\":1}}],[\"而客户端收到重复的确认报文段以为是失效报文段\",{\"1\":{\"16\":1}}],[\"而客户端的资源是在第三次握手时创建的\",{\"1\":{\"15\":1}}],[\"而此时网络信道恢复\",{\"1\":{\"16\":1}}],[\"rdlist\",{\"1\":{\"407\":1}}],[\"rdb和aof各有自己的优缺点\",{\"1\":{\"321\":1}}],[\"rdb与aof对比\",{\"0\":{\"321\":1}}],[\"rdbcompression\",{\"1\":{\"319\":1}}],[\"rdb持久化\",{\"0\":{\"319\":1}}],[\"rdb到\",{\"1\":{\"300\":1}}],[\"rdb\",{\"1\":{\"300\":3,\"301\":1,\"302\":2,\"319\":24,\"320\":1,\"321\":1}}],[\"rdbms\",{\"1\":{\"104\":1}}],[\"rpop\",{\"1\":{\"378\":1}}],[\"rpush\",{\"1\":{\"378\":1}}],[\"rpad\",{\"1\":{\"53\":1}}],[\"rubygems\",{\"1\":{\"341\":1}}],[\"ruby\",{\"1\":{\"341\":1}}],[\"runtimeexception\",{\"1\":{\"422\":2}}],[\"run\",{\"1\":{\"339\":1}}],[\"runoob\",{\"1\":{\"266\":1,\"291\":3}}],[\"rbr\",{\"1\":{\"407\":1}}],[\"rb\",{\"1\":{\"341\":2,\"407\":1}}],[\"rb是有ruby语言编写的所以需要安装ruby环境\",{\"1\":{\"341\":1}}],[\"rb来实现的\",{\"1\":{\"341\":1}}],[\"rfds\",{\"1\":{\"405\":4}}],[\"rf\",{\"1\":{\"339\":1}}],[\"rm\",{\"1\":{\"339\":1}}],[\"rr隔离级别下都支持\",{\"1\":{\"146\":1}}],[\"raw编码动态字符串\",{\"1\":{\"466\":1}}],[\"raw==1\",{\"1\":{\"447\":1}}],[\"raw\",{\"1\":{\"415\":1,\"466\":1,\"467\":1}}],[\"radius\",{\"1\":{\"396\":2}}],[\"range\",{\"1\":{\"229\":1}}],[\"random\",{\"1\":{\"276\":2,\"456\":2}}],[\"rand\",{\"1\":{\"54\":1}}],[\"ram\",{\"1\":{\"136\":1}}],[\"r\",{\"1\":{\"115\":1,\"123\":1,\"421\":20,\"456\":3}}],[\"ring0\",{\"1\":{\"401\":1}}],[\"ring3\",{\"1\":{\"401\":1}}],[\"riak\",{\"1\":{\"109\":1}}],[\"right\",{\"1\":{\"95\":1}}],[\"robj\",{\"1\":{\"456\":1,\"462\":1,\"465\":1}}],[\"routine\",{\"1\":{\"240\":1}}],[\"routines\",{\"1\":{\"240\":1}}],[\"round\",{\"1\":{\"54\":1}}],[\"root\",{\"1\":{\"202\":1,\"306\":2,\"407\":1}}],[\"rows\",{\"1\":{\"229\":1}}],[\"row\",{\"1\":{\"82\":2,\"155\":1,\"157\":1,\"158\":1,\"159\":1,\"204\":1,\"514\":4}}],[\"roll\",{\"1\":{\"58\":1,\"82\":2}}],[\"rollback\",{\"1\":{\"58\":1,\"256\":1}}],[\"regress\",{\"1\":{\"553\":1}}],[\"reg\",{\"1\":{\"553\":1}}],[\"ret++\",{\"1\":{\"494\":1}}],[\"ret\",{\"1\":{\"482\":3,\"494\":2,\"517\":8}}],[\"returns\",{\"1\":{\"254\":1}}],[\"return\",{\"1\":{\"22\":1,\"23\":1,\"24\":1,\"26\":1,\"27\":1,\"29\":1,\"36\":9,\"37\":2,\"254\":1,\"282\":1,\"291\":1,\"307\":4,\"334\":3,\"347\":1,\"353\":1,\"422\":8,\"432\":11,\"482\":1,\"488\":2,\"494\":1,\"500\":2,\"503\":2,\"506\":2,\"512\":1,\"517\":13,\"523\":2,\"526\":2,\"529\":2,\"536\":2,\"538\":2}}],[\"rehash时ht\",{\"1\":{\"439\":1}}],[\"rehash时使用\",{\"1\":{\"436\":1}}],[\"rehashid\",{\"1\":{\"438\":1}}],[\"rehashidx是否大于\",{\"1\":{\"438\":1}}],[\"rehashidx=0\",{\"1\":{\"438\":2}}],[\"rehashidx\",{\"1\":{\"436\":1}}],[\"rehash是否暂停\",{\"1\":{\"436\":1}}],[\"rehash\",{\"0\":{\"438\":1},\"1\":{\"436\":1,\"437\":1,\"438\":10}}],[\"rehard\",{\"1\":{\"344\":1}}],[\"revents\",{\"1\":{\"406\":1}}],[\"revoke\",{\"1\":{\"196\":1}}],[\"requirepass\",{\"1\":{\"369\":1}}],[\"remote\",{\"1\":{\"365\":1}}],[\"recently\",{\"1\":{\"456\":1}}],[\"receiving\",{\"1\":{\"344\":1}}],[\"recompress\",{\"1\":{\"447\":1}}],[\"record\",{\"1\":{\"146\":1}}],[\"recvfrom\",{\"1\":{\"403\":1,\"404\":3}}],[\"rewrite\",{\"1\":{\"320\":2}}],[\"releases\",{\"1\":{\"373\":2}}],[\"reload\",{\"1\":{\"306\":1,\"310\":1,\"370\":1}}],[\"relational或者not\",{\"1\":{\"109\":1}}],[\"relational\",{\"1\":{\"104\":1,\"363\":1}}],[\"refcount\",{\"1\":{\"456\":1,\"465\":1,\"470\":2}}],[\"ref\",{\"1\":{\"229\":2}}],[\"references\",{\"1\":{\"49\":2,\"50\":1}}],[\"rename\",{\"1\":{\"177\":1}}],[\"repo\",{\"1\":{\"305\":2}}],[\"repl\",{\"1\":{\"300\":2,\"301\":3,\"302\":3}}],[\"replid\",{\"1\":{\"300\":3}}],[\"replicas\",{\"1\":{\"341\":5}}],[\"replication\",{\"1\":{\"297\":1,\"300\":3}}],[\"replica\",{\"1\":{\"293\":1,\"295\":5,\"334\":2,\"339\":1}}],[\"replace关键字\",{\"1\":{\"163\":1}}],[\"replace\",{\"1\":{\"163\":2}}],[\"repeat\",{\"1\":{\"250\":2,\"289\":1}}],[\"repeat是有条件的循环控制语句\",{\"1\":{\"250\":1}}],[\"repeat循环\",{\"0\":{\"250\":1},\"1\":{\"289\":1}}],[\"repeatable\",{\"1\":{\"86\":1,\"259\":2}}],[\"repeated\",{\"1\":{\"81\":1}}],[\"red\",{\"1\":{\"307\":5}}],[\"redis预分配的值对象如下\",{\"1\":{\"469\":1}}],[\"redis是纯内存操作\",{\"1\":{\"458\":1}}],[\"redisdb\",{\"1\":{\"454\":2}}],[\"redis3\",{\"1\":{\"444\":1,\"446\":1}}],[\"redisobject\",{\"0\":{\"465\":1},\"1\":{\"415\":1,\"456\":1,\"464\":1,\"465\":2,\"470\":1}}],[\"redisobject对象机制\",{\"0\":{\"463\":1},\"1\":{\"265\":1}}],[\"redis事务命令\",{\"1\":{\"399\":1}}],[\"redis基于该类型\",{\"1\":{\"396\":1}}],[\"redis发布订阅命令\",{\"1\":{\"381\":1}}],[\"redis的字符串表示为\",{\"1\":{\"428\":1}}],[\"redis的事务和mysql的事务是不同的\",{\"1\":{\"399\":1}}],[\"redis的sortedset又可以成为zset\",{\"1\":{\"380\":1}}],[\"redis的set结构与java中的hashset类似\",{\"1\":{\"379\":1}}],[\"redis的key中虽然没有目录结构\",{\"1\":{\"376\":1}}],[\"redis中的list类型与java中的linkedlist类似\",{\"1\":{\"378\":1}}],[\"redis图形化客户端\",{\"1\":{\"373\":1}}],[\"redis命令行连接\",{\"1\":{\"372\":1}}],[\"redis本身仅有一个基于命令行的客户端\",{\"1\":{\"371\":1}}],[\"redis后台启动\",{\"1\":{\"369\":1}}],[\"redis启动的三种方式\",{\"0\":{\"367\":1}}],[\"redis安装完成后就自带了命令行客户端\",{\"1\":{\"372\":1}}],[\"redis安装\",{\"1\":{\"366\":1}}],[\"redis6\",{\"1\":{\"365\":1}}],[\"redis特征\",{\"1\":{\"365\":1}}],[\"redis诞生于2009年\",{\"1\":{\"365\":1}}],[\"redistest\",{\"1\":{\"360\":1}}],[\"redistemplate<>\",{\"1\":{\"353\":1}}],[\"redistemplate<string\",{\"1\":{\"353\":2}}],[\"redistemplate访问分片集群\",{\"0\":{\"346\":1}}],[\"redistemplate\",{\"1\":{\"334\":1,\"346\":1,\"352\":3,\"353\":9,\"354\":2,\"355\":1,\"356\":1,\"358\":1,\"359\":8,\"360\":7}}],[\"redistemplate连接集群\",{\"0\":{\"334\":1}}],[\"redis依赖\",{\"1\":{\"360\":1}}],[\"redisconnectionfactory\",{\"1\":{\"353\":1}}],[\"redisconfig\",{\"0\":{\"353\":1}}],[\"rediscontroller\",{\"1\":{\"334\":1}}],[\"redis如何判断某个\",{\"1\":{\"343\":1}}],[\"redis5\",{\"1\":{\"341\":3}}],[\"redis<\",{\"1\":{\"334\":1,\"360\":1}}],[\"redis缓存预热\",{\"0\":{\"315\":1}}],[\"redis实例的声明\",{\"1\":{\"295\":1}}],[\"redis教程\",{\"1\":{\"266\":1}}],[\"redis网络模型\",{\"0\":{\"457\":1},\"1\":{\"265\":1}}],[\"redis原理\",{\"0\":{\"265\":1,\"400\":1,\"414\":1,\"420\":1,\"423\":1,\"454\":1,\"457\":1,\"463\":1},\"1\":{\"265\":7}}],[\"redis分片集群\",{\"0\":{\"336\":1},\"1\":{\"264\":1}}],[\"redis哨兵\",{\"0\":{\"322\":1},\"1\":{\"264\":1}}],[\"redis主从\",{\"0\":{\"292\":1},\"1\":{\"264\":1}}],[\"redis持久化\",{\"0\":{\"318\":1},\"1\":{\"264\":1}}],[\"redis进阶\",{\"0\":{\"264\":1,\"267\":1,\"268\":1,\"277\":1,\"278\":1,\"279\":1,\"284\":1,\"285\":1,\"292\":1,\"303\":1,\"318\":1,\"322\":1,\"335\":1,\"336\":1},\"1\":{\"264\":13}}],[\"redisserializer\",{\"0\":{\"352\":1},\"1\":{\"263\":1}}],[\"redis客户端等\",{\"1\":{\"374\":1}}],[\"redis客户端\",{\"0\":{\"263\":1,\"347\":1,\"348\":1,\"352\":1,\"357\":1,\"371\":1},\"1\":{\"263\":4}}],[\"redis概念和基础\",{\"0\":{\"362\":1},\"1\":{\"262\":1}}],[\"redis入门到实战教程\",{\"1\":{\"266\":1}}],[\"redis入门\",{\"0\":{\"262\":1,\"361\":1,\"362\":1,\"375\":1,\"381\":1,\"382\":1,\"385\":1,\"395\":1,\"399\":1},\"1\":{\"262\":8}}],[\"redis\",{\"0\":{\"260\":1,\"385\":1},\"1\":{\"109\":1,\"260\":1,\"262\":1,\"266\":1,\"270\":1,\"271\":2,\"273\":2,\"274\":1,\"276\":1,\"279\":2,\"280\":1,\"283\":1,\"293\":3,\"295\":17,\"296\":7,\"297\":3,\"301\":2,\"304\":1,\"307\":3,\"318\":6,\"319\":14,\"320\":5,\"324\":3,\"328\":1,\"332\":3,\"334\":3,\"339\":2,\"340\":5,\"341\":8,\"342\":2,\"343\":3,\"344\":9,\"346\":2,\"349\":1,\"350\":1,\"352\":3,\"354\":2,\"356\":1,\"358\":7,\"359\":2,\"360\":1,\"363\":1,\"364\":1,\"366\":2,\"369\":2,\"370\":9,\"372\":2,\"373\":2,\"374\":1,\"376\":1,\"381\":2,\"382\":2,\"385\":9,\"386\":1,\"398\":2,\"399\":4,\"415\":1,\"416\":3,\"417\":1,\"418\":2,\"421\":6,\"422\":1,\"425\":5,\"426\":1,\"428\":2,\"430\":3,\"433\":1,\"435\":1,\"436\":1,\"438\":2,\"448\":1,\"454\":2,\"455\":2,\"456\":4,\"458\":6,\"459\":2,\"460\":2,\"461\":1,\"464\":4,\"465\":2,\"466\":1,\"467\":1,\"468\":3,\"469\":2,\"470\":1}}],[\"redolog\",{\"1\":{\"86\":1}}],[\"redo\",{\"0\":{\"72\":1,\"75\":1},\"1\":{\"63\":1,\"75\":2,\"86\":1}}],[\"readlen\",{\"1\":{\"462\":1}}],[\"readline\",{\"1\":{\"422\":6}}],[\"readable\",{\"1\":{\"462\":1}}],[\"readqueryfromclient\",{\"1\":{\"460\":1,\"462\":3}}],[\"ready\",{\"1\":{\"454\":1}}],[\"readbulkstring\",{\"1\":{\"422\":2}}],[\"reader\",{\"1\":{\"422\":11}}],[\"readfds\",{\"1\":{\"405\":1}}],[\"readfrom\",{\"1\":{\"334\":4}}],[\"reads\",{\"1\":{\"254\":1}}],[\"readview创建者的事务id\",{\"1\":{\"85\":1}}],[\"readview中包含了4个核心字段\",{\"1\":{\"85\":1}}],[\"readview决定回滚到哪个链条节点\",{\"1\":{\"84\":1}}],[\"readview\",{\"0\":{\"85\":1},\"1\":{\"79\":1}}],[\"read\",{\"1\":{\"73\":1,\"81\":2,\"85\":1,\"86\":2,\"139\":1,\"143\":2,\"144\":6,\"145\":2,\"259\":6,\"275\":1,\"307\":4,\"422\":1}}],[\"resis\",{\"1\":{\"421\":1}}],[\"reshard\",{\"1\":{\"344\":1}}],[\"restart\",{\"1\":{\"370\":1}}],[\"restcontroller\",{\"1\":{\"334\":1}}],[\"restrict\",{\"1\":{\"50\":1}}],[\"resp3\",{\"1\":{\"421\":1}}],[\"resp2\",{\"1\":{\"421\":2}}],[\"resp协议\",{\"0\":{\"421\":1}}],[\"response\",{\"1\":{\"310\":1}}],[\"resp\",{\"1\":{\"307\":8,\"421\":4}}],[\"result\",{\"1\":{\"291\":2,\"351\":4}}],[\"res2\",{\"1\":{\"56\":2}}],[\"res1\",{\"1\":{\"56\":2}}],[\"rvcd\",{\"1\":{\"15\":1}}],[\"rcvd\",{\"1\":{\"15\":1}}],[\"yuque\",{\"1\":{\"549\":1}}],[\"yum\",{\"1\":{\"305\":7,\"341\":1,\"366\":1}}],[\"you\",{\"1\":{\"344\":2}}],[\"yes\",{\"1\":{\"301\":1,\"319\":1,\"320\":1,\"339\":2,\"344\":2,\"369\":1}}],[\"year\",{\"1\":{\"55\":1}}],[\"y\",{\"1\":{\"15\":1,\"54\":3,\"305\":4,\"341\":1,\"552\":1,\"553\":1}}],[\"1oximgcfgfg34mkmuvx19ow\",{\"1\":{\"546\":1}}],[\"14\",{\"1\":{\"514\":1}}],[\"19\",{\"1\":{\"514\":1}}],[\"192\",{\"1\":{\"294\":3,\"295\":5,\"297\":2,\"306\":1,\"327\":1,\"330\":3,\"331\":4,\"334\":3,\"338\":6,\"339\":1,\"341\":12,\"344\":3,\"346\":6,\"347\":1,\"351\":1,\"360\":1}}],[\"17\",{\"1\":{\"514\":1}}],[\"13\",{\"1\":{\"503\":1,\"514\":1}}],[\"132537\",{\"1\":{\"372\":1}}],[\"11111111\",{\"1\":{\"442\":1}}],[\"11111110\",{\"1\":{\"442\":1}}],[\"1111xxxx\",{\"1\":{\"442\":1}}],[\"11110000\",{\"1\":{\"442\":1}}],[\"11100000\",{\"1\":{\"442\":1}}],[\"11010000\",{\"1\":{\"442\":1}}],[\"11000000\",{\"1\":{\"442\":1}}],[\"11\",{\"1\":{\"442\":1,\"465\":1,\"466\":2,\"514\":1}}],[\"1171\",{\"1\":{\"126\":3}}],[\"1170\",{\"1\":{\"126\":1}}],[\"1时\",{\"1\":{\"439\":1}}],[\"1的2n\",{\"1\":{\"439\":1}}],[\"1的\",{\"1\":{\"438\":2}}],[\"1的整型数组\",{\"1\":{\"397\":1}}],[\"1则暂停\",{\"1\":{\"436\":1}}],[\"1ms\",{\"1\":{\"455\":1}}],[\"1m\",{\"1\":{\"427\":3}}],[\"1kb\",{\"1\":{\"408\":1}}],[\"1永不超时\",{\"1\":{\"407\":1}}],[\"1代表就绪\",{\"1\":{\"405\":1}}],[\"1或者\",{\"1\":{\"341\":1}}],[\"128\",{\"1\":{\"419\":1}}],[\"12\",{\"1\":{\"398\":1,\"514\":1}}],[\"127\",{\"1\":{\"334\":3,\"372\":1,\"422\":1}}],[\"123\",{\"1\":{\"298\":1,\"342\":1}}],[\"1a\",{\"1\":{\"295\":4}}],[\"1取数据\",{\"1\":{\"282\":1}}],[\"150m\",{\"1\":{\"307\":1}}],[\"150\",{\"1\":{\"294\":3,\"295\":5,\"297\":2,\"306\":1,\"327\":1,\"330\":3,\"331\":4,\"338\":6,\"339\":1,\"341\":12,\"344\":3,\"346\":6}}],[\"15\",{\"0\":{\"476\":1},\"1\":{\"273\":1,\"361\":1,\"454\":1,\"478\":1,\"514\":1,\"532\":4}}],[\"1qthvvyoxlfioei09gilm6w\",{\"1\":{\"171\":1}}],[\"18\",{\"1\":{\"129\":1,\"354\":1,\"514\":1}}],[\"18736\",{\"1\":{\"126\":1}}],[\"1646\",{\"0\":{\"483\":1},\"1\":{\"485\":1}}],[\"16384\",{\"1\":{\"343\":4,\"344\":1}}],[\"168\",{\"1\":{\"294\":3,\"295\":5,\"297\":2,\"306\":1,\"327\":1,\"330\":3,\"331\":4,\"334\":3,\"338\":6,\"339\":1,\"341\":12,\"344\":3,\"346\":6,\"347\":1,\"351\":1,\"360\":1}}],[\"16\",{\"1\":{\"126\":3,\"426\":1,\"430\":1,\"441\":1,\"447\":1,\"448\":1,\"514\":1}}],[\"109\",{\"1\":{\"509\":1,\"541\":2}}],[\"105\",{\"1\":{\"477\":2}}],[\"10k\",{\"1\":{\"304\":1}}],[\"1001\",{\"1\":{\"311\":3}}],[\"1000\",{\"1\":{\"319\":1,\"344\":1,\"347\":1,\"532\":1}}],[\"1000代表什么含义\",{\"1\":{\"319\":1}}],[\"10001\",{\"1\":{\"310\":1}}],[\"1000k\",{\"1\":{\"304\":1}}],[\"10000代表60秒内至少执行\",{\"1\":{\"319\":1}}],[\"10000\",{\"1\":{\"295\":1,\"307\":1,\"319\":2}}],[\"1000条\",{\"1\":{\"199\":1}}],[\"100\",{\"1\":{\"295\":1,\"307\":1,\"320\":1,\"347\":2,\"360\":3,\"509\":1,\"532\":3}}],[\"101\",{\"1\":{\"294\":3,\"295\":5,\"297\":2,\"306\":1,\"327\":1,\"330\":3,\"331\":4,\"334\":3,\"338\":6,\"339\":1,\"341\":12,\"344\":3,\"346\":6}}],[\"107\",{\"1\":{\"281\":2}}],[\"10\",{\"1\":{\"126\":1,\"192\":1,\"201\":2,\"232\":1,\"283\":2,\"291\":1,\"319\":2,\"326\":1,\"421\":2,\"442\":1,\"455\":1,\"456\":1,\"466\":1,\"514\":1,\"532\":1}}],[\"1024\",{\"1\":{\"76\":1,\"126\":1,\"306\":1,\"405\":1,\"406\":1,\"410\":1}}],[\"1个数据\",{\"1\":{\"118\":1}}],[\"1\",{\"0\":{\"21\":1,\"31\":1,\"143\":1,\"294\":1,\"305\":1,\"480\":1,\"552\":1,\"557\":1,\"563\":1,\"564\":2,\"565\":3,\"566\":2,\"567\":2,\"568\":1,\"569\":2,\"570\":1,\"571\":1,\"572\":1,\"573\":2,\"574\":1,\"575\":1,\"576\":1,\"577\":1},\"1\":{\"15\":2,\"17\":7,\"22\":3,\"23\":4,\"24\":4,\"26\":4,\"27\":4,\"29\":3,\"36\":22,\"37\":1,\"63\":2,\"73\":2,\"126\":1,\"132\":1,\"192\":1,\"193\":1,\"201\":2,\"202\":2,\"221\":3,\"227\":1,\"228\":1,\"256\":1,\"270\":2,\"272\":3,\"282\":1,\"283\":2,\"288\":2,\"295\":2,\"306\":1,\"311\":2,\"319\":2,\"320\":1,\"325\":1,\"328\":1,\"331\":1,\"339\":2,\"341\":4,\"342\":1,\"343\":1,\"344\":1,\"351\":3,\"353\":1,\"364\":2,\"369\":1,\"372\":2,\"376\":6,\"394\":1,\"405\":3,\"407\":1,\"421\":3,\"422\":4,\"426\":1,\"427\":3,\"432\":11,\"436\":2,\"437\":2,\"438\":13,\"439\":2,\"440\":1,\"442\":4,\"447\":3,\"448\":3,\"453\":1,\"456\":6,\"466\":1,\"467\":1,\"469\":1,\"477\":22,\"482\":10,\"484\":6,\"488\":7,\"491\":8,\"496\":14,\"498\":9,\"500\":1,\"503\":9,\"506\":8,\"507\":1,\"509\":2,\"512\":7,\"514\":4,\"516\":2,\"517\":43,\"519\":10,\"521\":8,\"523\":1,\"526\":4,\"529\":7,\"530\":1,\"532\":16,\"534\":12,\"536\":6,\"538\":7,\"539\":1,\"541\":16,\"543\":3,\"566\":1}}],[\"+1\",{\"1\":{\"432\":4}}],[\"+ok\",{\"1\":{\"421\":1}}],[\"+=\",{\"1\":{\"24\":1}}],[\"++i\",{\"1\":{\"24\":2}}],[\"++\",{\"1\":{\"22\":1,\"24\":1,\"26\":2,\"27\":2,\"29\":1,\"36\":3,\"37\":1,\"462\":1,\"512\":1,\"543\":8}}],[\"+\",{\"1\":{\"15\":2,\"17\":7,\"24\":1,\"26\":1,\"27\":1,\"36\":3,\"86\":2,\"126\":2,\"129\":2,\"282\":2,\"341\":1,\"351\":2,\"360\":1,\"390\":1,\"391\":1,\"405\":2,\"421\":1,\"422\":7,\"427\":3,\"430\":2,\"432\":3,\"438\":2,\"439\":1,\"456\":2,\"460\":1,\"477\":14,\"481\":2,\"482\":9,\"484\":5,\"488\":6,\"496\":7,\"498\":1,\"500\":1,\"503\":3,\"506\":1,\"511\":1,\"512\":2,\"516\":2,\"517\":41,\"519\":5,\"523\":1,\"526\":2,\"529\":1,\"534\":6,\"536\":2,\"538\":2,\"541\":4,\"543\":2}}],[\"x2\",{\"1\":{\"553\":1}}],[\"x1\",{\"1\":{\"553\":1}}],[\"xfds\",{\"1\":{\"406\":1}}],[\"xor\",{\"1\":{\"397\":2}}],[\"xinfo\",{\"1\":{\"385\":3}}],[\"xclaim\",{\"1\":{\"385\":1}}],[\"xpending\",{\"1\":{\"385\":1}}],[\"xreadgroup\",{\"0\":{\"394\":1},\"1\":{\"385\":1,\"394\":3}}],[\"xread\",{\"0\":{\"392\":1},\"1\":{\"385\":1,\"392\":2}}],[\"xrevrange\",{\"0\":{\"391\":1},\"1\":{\"385\":1,\"391\":2}}],[\"xrange\",{\"0\":{\"390\":1},\"1\":{\"385\":1,\"390\":2}}],[\"xlen\",{\"0\":{\"389\":1},\"1\":{\"385\":1,\"389\":2}}],[\"xdel\",{\"0\":{\"388\":1},\"1\":{\"385\":1,\"388\":2}}],[\"xtrim\",{\"0\":{\"387\":1},\"1\":{\"385\":1,\"387\":2}}],[\"xgroup\",{\"0\":{\"393\":1},\"1\":{\"385\":5,\"393\":4}}],[\"x09codermast\",{\"1\":{\"352\":1}}],[\"x04name\",{\"1\":{\"352\":1}}],[\"x05t\",{\"1\":{\"352\":2}}],[\"x00\",{\"1\":{\"352\":4}}],[\"xed\",{\"1\":{\"352\":2}}],[\"xadd\",{\"0\":{\"386\":1},\"1\":{\"385\":2,\"386\":3}}],[\"xack\",{\"1\":{\"385\":1}}],[\"xac\",{\"1\":{\"352\":2}}],[\"xargs\",{\"1\":{\"295\":2,\"296\":1,\"331\":1,\"339\":2,\"340\":3}}],[\"xxx代表的是数据表名\",{\"1\":{\"234\":1}}],[\"xxx\",{\"1\":{\"144\":1,\"235\":3,\"236\":1,\"240\":1}}],[\"xxxx\",{\"1\":{\"132\":1,\"442\":1}}],[\"x版本中还包含innodb数据字典\",{\"1\":{\"66\":1}}],[\"x对y取模\",{\"1\":{\"54\":1}}],[\"x\",{\"1\":{\"15\":1,\"37\":5,\"54\":5,\"147\":1,\"435\":1,\"509\":1,\"514\":2,\"552\":1}}],[\"==\",{\"1\":{\"36\":1,\"86\":1,\"121\":1,\"243\":1,\"307\":1,\"422\":2,\"432\":2,\"477\":1,\"481\":1,\"482\":6,\"488\":1,\"512\":3,\"514\":2,\"516\":3,\"517\":10,\"536\":1,\"538\":1,\"541\":2,\"543\":2}}],[\"=n1​2n\",{\"1\":{\"36\":1}}],[\"=n1​i=1∑n​\",{\"1\":{\"36\":1}}],[\"=n+11​2n\",{\"1\":{\"36\":1}}],[\"=n+11​i=1∑n+1​\",{\"1\":{\"36\":1}}],[\"=i=1∑n​n1​∗\",{\"1\":{\"36\":1}}],[\"=i=1∑n+1​n+11​∗\",{\"1\":{\"36\":1}}],[\"=6n3+3n2+2n​\",{\"1\":{\"29\":1}}],[\"=21​\",{\"1\":{\"29\":1}}],[\"=\",{\"1\":{\"15\":2,\"17\":6,\"22\":4,\"23\":8,\"24\":5,\"26\":5,\"27\":4,\"29\":4,\"35\":1,\"36\":9,\"37\":11,\"68\":1,\"98\":1,\"99\":2,\"101\":2,\"126\":6,\"129\":1,\"130\":3,\"181\":2,\"187\":1,\"192\":1,\"202\":2,\"227\":2,\"228\":1,\"240\":1,\"242\":2,\"243\":10,\"244\":2,\"256\":1,\"282\":5,\"283\":2,\"288\":7,\"289\":1,\"291\":1,\"306\":1,\"307\":13,\"311\":1,\"334\":1,\"344\":1,\"347\":2,\"351\":8,\"352\":1,\"353\":3,\"354\":2,\"360\":1,\"405\":2,\"422\":21,\"430\":2,\"432\":25,\"435\":2,\"437\":1,\"462\":11,\"477\":12,\"481\":1,\"482\":5,\"484\":4,\"488\":8,\"491\":4,\"494\":3,\"496\":15,\"498\":1,\"503\":8,\"506\":7,\"509\":8,\"511\":1,\"512\":16,\"514\":2,\"517\":6,\"519\":2,\"526\":5,\"529\":7,\"532\":2,\"534\":7,\"536\":6,\"538\":8,\"541\":13,\"543\":19}}],[\"为对象引用计数器\",{\"1\":{\"470\":1}}],[\"为结点的双端链表结构\",{\"1\":{\"446\":1}}],[\"为结束符号\",{\"1\":{\"240\":1}}],[\"为结束标识符\",{\"1\":{\"240\":2}}],[\"为整数类型\",{\"1\":{\"442\":1}}],[\"为字符串类型\",{\"1\":{\"442\":1}}],[\"为消费者组设置新的最后递送消息id\",{\"1\":{\"385\":1}}],[\"为可选项\",{\"1\":{\"372\":1}}],[\"为前缀\",{\"1\":{\"343\":1}}],[\"为新的\",{\"1\":{\"327\":1,\"345\":1}}],[\"为主\",{\"1\":{\"324\":1}}],[\"为\",{\"1\":{\"290\":1,\"352\":1}}],[\"为索引的\",{\"1\":{\"288\":1}}],[\"为删除并且他的空间变得允许被其他记录值重新声明\",{\"1\":{\"206\":1}}],[\"为dql进行说明\",{\"1\":{\"179\":1}}],[\"为on\",{\"1\":{\"67\":1}}],[\"为有以下几种\",{\"1\":{\"50\":1}}],[\"为了应对这种情况\",{\"1\":{\"541\":1}}],[\"为了解决这个问题\",{\"1\":{\"450\":1}}],[\"为了解决以上问题\",{\"1\":{\"425\":1}}],[\"为了缓解这个问题\",{\"1\":{\"444\":1}}],[\"为了同时实现排序和快速访问的功能\",{\"1\":{\"419\":1}}],[\"为了查询效率和唯一性\",{\"1\":{\"418\":1}}],[\"为了节省内存空间\",{\"1\":{\"355\":1}}],[\"为了在反序列化时知道对象的类型\",{\"1\":{\"354\":1}}],[\"为了方便查找\",{\"1\":{\"430\":1}}],[\"为了方便查看日志\",{\"1\":{\"296\":1,\"332\":1}}],[\"为了方便操作\",{\"1\":{\"37\":1}}],[\"为了避免\",{\"1\":{\"448\":1}}],[\"为了避免用户应用导致冲突甚至内核崩溃\",{\"1\":{\"401\":1}}],[\"为了避免将来混乱\",{\"1\":{\"295\":1}}],[\"为了避免dml在执行时\",{\"1\":{\"145\":1}}],[\"为了避免dml与ddl冲突\",{\"1\":{\"144\":1}}],[\"为了提高集成度\",{\"1\":{\"281\":1}}],[\"为了确定检查的范围\",{\"1\":{\"164\":1}}],[\"为了保证页的连续性\",{\"1\":{\"58\":1}}],[\"为了保证数据库中数据的正确\",{\"1\":{\"46\":1}}],[\"为了表示自己成功接受到报文段\",{\"1\":{\"15\":1}}],[\"为元素\",{\"1\":{\"36\":1}}],[\"为什么redis不共享列表对象\",{\"1\":{\"469\":1}}],[\"为什么redis要选择单线程\",{\"1\":{\"458\":1}}],[\"为什么会设计redisobject\",{\"0\":{\"464\":1}}],[\"为什么节省内存\",{\"1\":{\"441\":1}}],[\"为什么ziplist特别省内存\",{\"1\":{\"441\":1}}],[\"为什么innodb存储引擎选择使用b+树索引结构\",{\"1\":{\"122\":1}}],[\"为什么需要三次握手而不是两次\",{\"0\":{\"16\":1}}],[\"为什么要反复造一些质量并不高的轮子呢\",{\"1\":{\"2\":1}}],[\"为什么\",{\"0\":{\"2\":1},\"1\":{\"126\":1}}],[\"状态和其他\",{\"1\":{\"345\":1}}],[\"状态码\",{\"1\":{\"253\":1}}],[\"状态转变为established\",{\"1\":{\"15\":1}}],[\"状态转变为syn\",{\"1\":{\"15\":1}}],[\"状态\",{\"1\":{\"15\":1}}],[\"状态变为syn\",{\"1\":{\"15\":1}}],[\"small\",{\"1\":{\"447\":1}}],[\"smembers\",{\"1\":{\"379\":1}}],[\"sz\",{\"1\":{\"447\":3}}],[\"s64\",{\"1\":{\"436\":1}}],[\"switch\",{\"1\":{\"422\":1}}],[\"s结构通常采取两层结构\",{\"1\":{\"421\":1}}],[\"sdslen\",{\"1\":{\"462\":3}}],[\"sds小结\",{\"0\":{\"428\":1}}],[\"sdshdr64\",{\"1\":{\"426\":1}}],[\"sdshdr32\",{\"1\":{\"426\":1}}],[\"sdshdr16\",{\"1\":{\"426\":1}}],[\"sdshdr8\",{\"1\":{\"426\":1}}],[\"sdshdr5\",{\"1\":{\"426\":2}}],[\"sds\",{\"1\":{\"415\":4,\"425\":2,\"426\":9,\"427\":3,\"428\":3,\"452\":1}}],[\"sdiff\",{\"1\":{\"379\":1}}],[\"sdi\",{\"1\":{\"234\":1,\"235\":1,\"236\":1}}],[\"srem\",{\"1\":{\"379\":1}}],[\"src\",{\"1\":{\"341\":1,\"370\":1,\"426\":2,\"465\":1}}],[\"s3两个文件夹内的配置文件\",{\"1\":{\"331\":1}}],[\"s3两个目录中\",{\"1\":{\"331\":1}}],[\"s3\",{\"1\":{\"330\":1,\"331\":6,\"332\":1}}],[\"sa\",{\"1\":{\"462\":1}}],[\"sadd\",{\"1\":{\"379\":1}}],[\"say\",{\"1\":{\"310\":2}}],[\"save命令\",{\"1\":{\"319\":1}}],[\"save\",{\"1\":{\"295\":4,\"319\":6}}],[\"sbin\",{\"1\":{\"305\":1}}],[\"skiplist小结\",{\"0\":{\"453\":1}}],[\"skiplist内存结构\",{\"1\":{\"451\":1}}],[\"skiplist\",{\"1\":{\"380\":1,\"417\":1,\"419\":3,\"451\":2,\"466\":1,\"467\":1}}],[\"skip\",{\"1\":{\"305\":1}}],[\"sync\",{\"1\":{\"301\":1}}],[\"systemctl\",{\"1\":{\"370\":6}}],[\"systemd\",{\"1\":{\"370\":1}}],[\"system\",{\"0\":{\"66\":1},\"1\":{\"104\":2,\"229\":1,\"282\":2,\"351\":2,\"354\":1,\"360\":1,\"370\":1,\"422\":4}}],[\"sleep\",{\"1\":{\"462\":2}}],[\"slots\",{\"1\":{\"344\":1}}],[\"slot\",{\"1\":{\"343\":2}}],[\"slow模式规则\",{\"1\":{\"455\":1}}],[\"slow\",{\"1\":{\"227\":2,\"455\":1}}],[\"slave1\",{\"1\":{\"327\":1}}],[\"slaveof\",{\"1\":{\"297\":4,\"327\":2,\"328\":3}}],[\"slave\",{\"1\":{\"293\":1,\"294\":2,\"300\":11,\"301\":5,\"302\":7,\"322\":1,\"324\":2,\"326\":8,\"327\":5,\"328\":1,\"337\":1,\"338\":3,\"345\":3}}],[\"span\",{\"1\":{\"452\":1}}],[\"split\",{\"1\":{\"202\":2}}],[\"springboot入门到实战\",{\"1\":{\"549\":1}}],[\"springboot3\",{\"1\":{\"548\":2,\"549\":1}}],[\"springboot\",{\"0\":{\"547\":1}}],[\"springboottest\",{\"1\":{\"360\":1}}],[\"spring对象的数据序列化和反序列化\",{\"1\":{\"358\":1}}],[\"springdata\",{\"1\":{\"358\":1}}],[\"springdataredis\",{\"0\":{\"357\":1},\"1\":{\"263\":1,\"358\":1,\"359\":1}}],[\"springframework\",{\"1\":{\"334\":1,\"360\":1}}],[\"spring\",{\"0\":{\"10\":1,\"360\":1,\"545\":1},\"1\":{\"280\":1,\"334\":2,\"346\":1,\"355\":1,\"358\":3,\"360\":2,\"549\":1}}],[\"script\",{\"1\":{\"383\":1,\"384\":8}}],[\"score\",{\"1\":{\"380\":1,\"419\":6,\"452\":1,\"453\":3}}],[\"scope>\",{\"1\":{\"351\":1}}],[\"scope\",{\"1\":{\"291\":2}}],[\"scard\",{\"1\":{\"379\":1}}],[\"scanf\",{\"1\":{\"37\":2}}],[\"schema\",{\"1\":{\"144\":2,\"145\":2,\"155\":1,\"240\":2}}],[\"short\",{\"1\":{\"406\":2}}],[\"show\",{\"1\":{\"127\":1,\"155\":1,\"163\":1,\"176\":1,\"177\":2,\"196\":1,\"226\":2,\"228\":3,\"232\":1,\"234\":1,\"240\":1,\"242\":2}}],[\"sha1\",{\"1\":{\"384\":2}}],[\"shared\",{\"1\":{\"144\":6,\"307\":1,\"462\":2,\"469\":2}}],[\"share\",{\"1\":{\"80\":1,\"144\":1,\"145\":1}}],[\"shutdown\",{\"1\":{\"296\":1,\"340\":1,\"361\":1}}],[\"shwo\",{\"1\":{\"228\":1}}],[\"sort\",{\"1\":{\"482\":1,\"494\":2,\"543\":1}}],[\"sortedset的常见命令有\",{\"1\":{\"380\":1}}],[\"sortedset具备下列特性\",{\"1\":{\"380\":1}}],[\"sortedset中的每一个元素都带有一个score属性\",{\"1\":{\"380\":1}}],[\"sortedset\",{\"0\":{\"380\":1},\"1\":{\"419\":1}}],[\"sortedset类型时\",{\"1\":{\"356\":1}}],[\"sorted\",{\"1\":{\"375\":1,\"395\":1,\"542\":1}}],[\"solution\",{\"1\":{\"482\":1,\"494\":1,\"512\":1,\"517\":1,\"543\":3}}],[\"solr\",{\"1\":{\"115\":1}}],[\"socket\",{\"1\":{\"404\":4,\"408\":2,\"422\":3,\"460\":5,\"462\":2}}],[\"so\",{\"1\":{\"307\":1,\"309\":1}}],[\"sourcekey\",{\"1\":{\"398\":1}}],[\"source\",{\"1\":{\"305\":1}}],[\"some\",{\"1\":{\"100\":2}}],[\"sql查询\",{\"1\":{\"364\":1}}],[\"sqlexception\",{\"1\":{\"253\":1}}],[\"sqlwarning\",{\"1\":{\"253\":1}}],[\"sqlstate\",{\"1\":{\"253\":2}}],[\"sql逻辑\",{\"1\":{\"249\":1,\"250\":1,\"251\":1}}],[\"sql的分析和优化\",{\"1\":{\"231\":1}}],[\"sql语句\",{\"1\":{\"240\":1,\"246\":1,\"254\":1}}],[\"sql语句执行超过两秒\",{\"1\":{\"227\":1}}],[\"sql语句可以使用空格\",{\"1\":{\"173\":1}}],[\"sql语句可以单行或者多行书写\",{\"1\":{\"173\":1}}],[\"sql执行频率\",{\"0\":{\"226\":1}}],[\"sql性能分析\",{\"0\":{\"225\":1}}],[\"sql分类\",{\"0\":{\"174\":1}}],[\"sql优化\",{\"0\":{\"197\":1},\"1\":{\"170\":1}}],[\"sql基础语法\",{\"0\":{\"172\":1},\"1\":{\"170\":1}}],[\"sql提示\",{\"0\":{\"130\":1},\"1\":{\"130\":1}}],[\"sql\",{\"1\":{\"104\":2,\"109\":1,\"139\":1,\"140\":1,\"157\":2,\"158\":2,\"159\":2,\"254\":2,\"363\":1,\"364\":1}}],[\"sqlist\",{\"1\":{\"36\":5}}],[\"simple\",{\"1\":{\"425\":1}}],[\"signed\",{\"1\":{\"447\":1}}],[\"signal\",{\"1\":{\"401\":1}}],[\"sigio\",{\"1\":{\"411\":3}}],[\"sinter\",{\"1\":{\"379\":1}}],[\"single\",{\"1\":{\"140\":2}}],[\"sismember\",{\"1\":{\"379\":1}}],[\"size命令查看\",{\"1\":{\"448\":1}}],[\"sizemask\",{\"1\":{\"435\":1,\"436\":2,\"438\":2}}],[\"size\",{\"1\":{\"211\":1,\"307\":2,\"320\":1,\"407\":1,\"436\":2,\"438\":1,\"447\":5,\"448\":1}}],[\"sizeof\",{\"1\":{\"37\":2}}],[\"sie\",{\"1\":{\"63\":1}}],[\"steal\",{\"1\":{\"447\":1}}],[\"storedist\",{\"1\":{\"396\":2}}],[\"store\",{\"1\":{\"396\":2}}],[\"stop\",{\"1\":{\"306\":1,\"370\":1}}],[\"standardcharsets\",{\"1\":{\"422\":3}}],[\"star\",{\"1\":{\"378\":1}}],[\"started\",{\"1\":{\"366\":1}}],[\"starter\",{\"1\":{\"334\":1,\"346\":1,\"360\":1}}],[\"start\",{\"1\":{\"53\":1,\"200\":1,\"256\":1,\"370\":1,\"390\":2,\"391\":2,\"397\":1,\"509\":1}}],[\"stata\",{\"0\":{\"550\":1,\"551\":1}}],[\"static\",{\"1\":{\"347\":3,\"422\":7,\"432\":2}}],[\"statements\",{\"1\":{\"289\":2}}],[\"statement\",{\"1\":{\"247\":6,\"253\":1}}],[\"status\",{\"1\":{\"226\":2,\"370\":1}}],[\"stmt\",{\"1\":{\"155\":1}}],[\"string来实现的\",{\"1\":{\"467\":1}}],[\"strings\",{\"1\":{\"426\":1}}],[\"string类型的常见操作命令\",{\"1\":{\"376\":1}}],[\"string类型\",{\"1\":{\"376\":1}}],[\"stringredisserializer\",{\"1\":{\"353\":5}}],[\"stringredistemplate\",{\"1\":{\"334\":4,\"355\":1,\"356\":1}}],[\"string\",{\"0\":{\"376\":1},\"1\":{\"282\":2,\"288\":1,\"291\":1,\"334\":6,\"351\":2,\"352\":1,\"353\":1,\"354\":1,\"355\":3,\"356\":1,\"359\":2,\"360\":2,\"375\":1,\"376\":3,\"395\":1,\"415\":1,\"422\":4,\"425\":1,\"426\":1,\"446\":1,\"467\":1}}],[\"string>\",{\"1\":{\"282\":1,\"283\":2}}],[\"stream流\",{\"1\":{\"466\":1}}],[\"streams\",{\"1\":{\"392\":1,\"394\":2}}],[\"stream\",{\"0\":{\"385\":1},\"1\":{\"262\":1,\"306\":1,\"385\":6,\"393\":1,\"466\":1}}],[\"str\",{\"1\":{\"53\":6,\"288\":1}}],[\"structured\",{\"1\":{\"104\":1}}],[\"struct\",{\"1\":{\"36\":1,\"37\":2,\"405\":2,\"406\":2,\"407\":5,\"426\":5,\"431\":1,\"436\":4,\"447\":8,\"452\":6,\"454\":1,\"456\":1,\"465\":1}}],[\"sunion\",{\"1\":{\"379\":1}}],[\"success\",{\"1\":{\"334\":1,\"432\":5}}],[\"subcommand\",{\"1\":{\"381\":1}}],[\"subscribe\",{\"1\":{\"381\":1}}],[\"substring\",{\"1\":{\"53\":1,\"132\":1}}],[\"sub\",{\"1\":{\"381\":2,\"385\":2}}],[\"subquery\",{\"1\":{\"229\":1}}],[\"sum\",{\"1\":{\"24\":7,\"166\":1,\"185\":1,\"189\":1,\"481\":3}}],[\"sn按照顺序拼接成一个字符串\",{\"1\":{\"53\":1}}],[\"sn\",{\"1\":{\"53\":1}}],[\"s2\",{\"1\":{\"53\":2,\"330\":1,\"331\":6,\"332\":1}}],[\"s1\",{\"1\":{\"53\":1,\"330\":1,\"331\":7,\"332\":1}}],[\"s\",{\"1\":{\"37\":5,\"147\":1,\"171\":1,\"283\":1,\"291\":2,\"295\":7,\"296\":1,\"306\":2,\"310\":1,\"331\":4,\"339\":2,\"340\":2,\"344\":1,\"421\":1,\"422\":6,\"462\":1,\"491\":4,\"494\":4,\"546\":1}}],[\"selec\",{\"1\":{\"405\":1}}],[\"select无法得知具体是哪个fd就绪\",{\"1\":{\"405\":1}}],[\"select结束还要再次拷贝回用户空间\",{\"1\":{\"405\":1}}],[\"select模式存在的问题\",{\"1\":{\"405\":1}}],[\"select函数\",{\"1\":{\"405\":1}}],[\"select语句\",{\"1\":{\"163\":3}}],[\"select操作中的任意一个\",{\"1\":{\"98\":1}}],[\"select\",{\"0\":{\"405\":1},\"1\":{\"80\":2,\"94\":2,\"95\":2,\"96\":1,\"97\":2,\"98\":2,\"126\":2,\"130\":3,\"132\":2,\"144\":4,\"145\":3,\"163\":1,\"176\":1,\"184\":1,\"186\":4,\"187\":1,\"189\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":1,\"195\":1,\"196\":1,\"210\":1,\"226\":2,\"228\":1,\"229\":5,\"240\":1,\"242\":1,\"243\":3,\"244\":1,\"256\":1,\"259\":1,\"351\":1,\"361\":1,\"404\":2,\"405\":2,\"406\":3,\"407\":1,\"410\":3,\"459\":2}}],[\"sendrequest\",{\"1\":{\"422\":5}}],[\"sendfile\",{\"1\":{\"306\":1}}],[\"sentinel\",{\"1\":{\"324\":4,\"325\":4,\"326\":1,\"327\":3,\"328\":3,\"331\":11,\"332\":6,\"334\":2}}],[\"sent\",{\"1\":{\"15\":2}}],[\"sed\",{\"1\":{\"295\":7,\"331\":2,\"339\":1,\"344\":1}}],[\"separated\",{\"1\":{\"291\":2}}],[\"search\",{\"1\":{\"247\":2,\"432\":1}}],[\"session|global\",{\"1\":{\"259\":1}}],[\"session|globle\",{\"1\":{\"228\":1}}],[\"session\",{\"1\":{\"226\":1,\"242\":6}}],[\"sericlization\",{\"1\":{\"421\":1}}],[\"serializable\",{\"1\":{\"81\":1,\"259\":2}}],[\"service\",{\"1\":{\"370\":2}}],[\"servercron\",{\"1\":{\"455\":1}}],[\"server命令即可启动redis\",{\"1\":{\"368\":1}}],[\"server\",{\"1\":{\"106\":1,\"296\":3,\"306\":2,\"340\":1,\"344\":1,\"365\":1,\"369\":1,\"370\":2,\"421\":2,\"455\":1,\"460\":2,\"462\":10,\"465\":1}}],[\"serevr\",{\"1\":{\"309\":1}}],[\"segment\",{\"1\":{\"58\":3,\"76\":2,\"204\":1}}],[\"setcommand\",{\"1\":{\"462\":1}}],[\"setconnectionfactory\",{\"1\":{\"353\":1}}],[\"sets\",{\"1\":{\"432\":2}}],[\"setsize\",{\"1\":{\"405\":1}}],[\"set监听的fd数量不能超过1024\",{\"1\":{\"405\":1}}],[\"set从用户空间拷贝到内核空间\",{\"1\":{\"405\":1}}],[\"set的最大fd\",{\"1\":{\"405\":1}}],[\"setbit\",{\"1\":{\"397\":1}}],[\"setid\",{\"1\":{\"385\":1,\"393\":1}}],[\"set中的指定元素自增\",{\"1\":{\"380\":1}}],[\"set中的指定元素的score值\",{\"1\":{\"380\":1}}],[\"set中的元素个数\",{\"1\":{\"380\":1}}],[\"set中的一个指定元素\",{\"1\":{\"380\":1}}],[\"setex\",{\"1\":{\"376\":1}}],[\"setnx\",{\"1\":{\"376\":1}}],[\"setname\",{\"1\":{\"354\":1}}],[\"setoperations\",{\"1\":{\"359\":1}}],[\"setage\",{\"1\":{\"354\":1}}],[\"sethashvalueserializer\",{\"1\":{\"353\":1}}],[\"sethashkeyserializer\",{\"1\":{\"353\":1}}],[\"setvalueserializer\",{\"1\":{\"353\":1}}],[\"setup\",{\"1\":{\"351\":1}}],[\"setmaxwaitmillis\",{\"1\":{\"347\":1}}],[\"setmaxidle\",{\"1\":{\"347\":2}}],[\"setmaxtotal\",{\"1\":{\"347\":1}}],[\"setkeyserializer\",{\"1\":{\"353\":1}}],[\"setkey\",{\"1\":{\"334\":1}}],[\"set\",{\"0\":{\"379\":1},\"1\":{\"50\":2,\"177\":1,\"181\":1,\"202\":1,\"228\":2,\"242\":2,\"243\":2,\"244\":2,\"256\":1,\"259\":1,\"273\":1,\"307\":1,\"334\":3,\"342\":2,\"351\":1,\"354\":2,\"356\":1,\"360\":1,\"361\":1,\"375\":2,\"376\":1,\"380\":2,\"395\":2,\"405\":9,\"406\":1,\"418\":4,\"422\":5,\"430\":1,\"432\":1,\"467\":1}}],[\"seq\",{\"1\":{\"15\":1,\"17\":2}}],[\"并输出这个最大数值\",{\"1\":{\"491\":1}}],[\"并没有新的底层实现方式\",{\"1\":{\"467\":1}}],[\"并绑定读处理器readqueryfromclient\",{\"1\":{\"462\":1}}],[\"并得到fd\",{\"1\":{\"462\":1}}],[\"并赋值给dict\",{\"1\":{\"438\":2}}],[\"并将分散在不同地理位置的计算机联系起来\",{\"1\":{\"573\":1}}],[\"并将length\",{\"1\":{\"432\":1}}],[\"并将读取到的数据存放到新节点的数据域中\",{\"1\":{\"37\":1}}],[\"并设置ep\",{\"1\":{\"407\":1}}],[\"并在某个\",{\"1\":{\"404\":1}}],[\"并返回结果给用户线程\",{\"1\":{\"402\":1}}],[\"并集图示\",{\"1\":{\"379\":1}}],[\"并集\",{\"1\":{\"379\":1,\"380\":1,\"397\":1,\"418\":1}}],[\"并作为一个\",{\"1\":{\"344\":1}}],[\"并存储\",{\"1\":{\"344\":1}}],[\"并存储在文件系统上的单个数据文件中\",{\"1\":{\"67\":1}}],[\"并解析响应\",{\"1\":{\"307\":1}}],[\"并持续将\",{\"1\":{\"300\":1}}],[\"并不想关心具体的底层实现是什么样的\",{\"1\":{\"464\":1}}],[\"并不是在\",{\"1\":{\"455\":1}}],[\"并不是到期立刻删除\",{\"1\":{\"454\":1}}],[\"并不是一次性完成的\",{\"1\":{\"438\":1}}],[\"并不像普通链表那样记录前后节点的指针\",{\"1\":{\"441\":1}}],[\"并不需要指定数据类型\",{\"1\":{\"288\":1}}],[\"并不会立即删除undo\",{\"1\":{\"76\":1}}],[\"并以超时剔除作为兜底方案\",{\"1\":{\"274\":1}}],[\"并完成缓存的查询\",{\"1\":{\"231\":1}}],[\"并非实际使用长度\",{\"1\":{\"229\":1}}],[\"并非所有内容都是本人原创\",{\"1\":{\"3\":1}}],[\"并锁住数据前面的间隙gap\",{\"1\":{\"146\":1}}],[\"并发能力虽然不错\",{\"1\":{\"318\":1}}],[\"并发能力问题\",{\"1\":{\"318\":1}}],[\"并发性要求不是很高\",{\"1\":{\"237\":1}}],[\"并发程度高\",{\"1\":{\"146\":1}}],[\"并发度最低\",{\"1\":{\"142\":1}}],[\"并每秒刷新到磁盘一次\",{\"1\":{\"63\":1}}],[\"并释放线性表l所占用的内存空间\",{\"1\":{\"35\":1}}],[\"并用e返回删除元素的值\",{\"1\":{\"35\":1}}],[\"并且访问棋盘上的每个格子\",{\"1\":{\"514\":1}}],[\"并且给定了f\",{\"1\":{\"498\":1}}],[\"并且给定了相关的递推公式\",{\"1\":{\"486\":1}}],[\"并且每块饼干\",{\"1\":{\"491\":1}}],[\"并且使得i++和j\",{\"1\":{\"481\":1}}],[\"并且使用jedis连接池较为可靠\",{\"1\":{\"347\":1}}],[\"并且对象的复杂度过高\",{\"1\":{\"469\":1}}],[\"并且对事务的完整性\",{\"1\":{\"237\":1}}],[\"并且带有其底层的编码方式\",{\"1\":{\"464\":1}}],[\"并且带有以下三个重要的保证\",{\"1\":{\"399\":1}}],[\"并且支持各种不同的多路复用实现\",{\"1\":{\"459\":1}}],[\"并且过期key比例大于10\",{\"1\":{\"455\":2}}],[\"并且该操作的时间复杂度为\",{\"1\":{\"440\":1}}],[\"并且该索引不能失效\",{\"1\":{\"223\":1}}],[\"并且服务器没有执行\",{\"1\":{\"437\":1}}],[\"并且这个集合的元素数量不多时\",{\"1\":{\"430\":1}}],[\"并且具备长度可变\",{\"1\":{\"430\":1}}],[\"并且可以根据\",{\"1\":{\"419\":1}}],[\"并且可以同时存储\",{\"1\":{\"419\":1}}],[\"并且元素数量不超过set\",{\"1\":{\"418\":1}}],[\"并且大小在\",{\"1\":{\"415\":1}}],[\"并且是很⼩的\",{\"1\":{\"398\":1}}],[\"并且是在使用视图时动态生成的\",{\"1\":{\"162\":1}}],[\"并且能记住每一个客户端的访问位置\",{\"1\":{\"385\":1}}],[\"并且指定有效期\",{\"1\":{\"376\":1}}],[\"并且将这些实现进行封装\",{\"1\":{\"459\":1}}],[\"并且将rehashidx++\",{\"1\":{\"438\":1}}],[\"并且将不同数据类型的操作api封装到了不同的类型中\",{\"1\":{\"359\":1}}],[\"并且将客户端的tcp连接断开\",{\"1\":{\"17\":1}}],[\"并且频繁的创建和销毁连接会有性能损耗\",{\"1\":{\"347\":1}}],[\"并且在移除结点后\",{\"1\":{\"443\":1}}],[\"并且在集群伸缩的同时\",{\"1\":{\"344\":1}}],[\"并且在\",{\"1\":{\"302\":1}}],[\"并且在叶子结点中\",{\"1\":{\"119\":1}}],[\"并且设置存储引擎为innodb\",{\"1\":{\"232\":1}}],[\"并且设置唯一约束\",{\"1\":{\"90\":1}}],[\"并且\",{\"1\":{\"187\":1,\"425\":1}}],[\"并且重新创建该表\",{\"1\":{\"177\":1}}],[\"并且最后一个字段后没有逗号\",{\"1\":{\"177\":1}}],[\"并且检查定义检查条件的依赖的视图\",{\"1\":{\"164\":1}}],[\"并且需要返回的列\",{\"1\":{\"131\":1}}],[\"并且不跳过索引中的列\",{\"1\":{\"129\":1}}],[\"并且以相对随机的顺序插入二级索引\",{\"1\":{\"62\":1}}],[\"并且建立连接\",{\"1\":{\"16\":1}}],[\"并且为自己也选一个初始序列号seq=y\",{\"1\":{\"15\":1}}],[\"并且选择一个初始序列号seq=x\",{\"1\":{\"15\":1}}],[\"像管道一样的连接\",{\"1\":{\"14\":1}}],[\"不断接收\",{\"1\":{\"460\":1}}],[\"不执行\",{\"1\":{\"455\":1}}],[\"不执行逻辑\",{\"1\":{\"249\":1}}],[\"不方便管理和查找\",{\"1\":{\"444\":1}}],[\"不得小于4\",{\"1\":{\"438\":2}}],[\"不包括pipeline\",{\"1\":{\"421\":1}}],[\"不包含sql语句\",{\"1\":{\"254\":1}}],[\"不包含该记录值\",{\"1\":{\"146\":1}}],[\"不一定确保元素有序\",{\"1\":{\"418\":1}}],[\"不再需要\",{\"1\":{\"415\":1}}],[\"不管是扩容还是收缩\",{\"1\":{\"438\":1}}],[\"不管是哪种格式\",{\"1\":{\"376\":1}}],[\"不管数据是否被处理完成\",{\"1\":{\"408\":1}}],[\"不为空则返回就绪的fd的数量\",{\"1\":{\"407\":1}}],[\"不为null\",{\"1\":{\"221\":1}}],[\"不阻塞等待\",{\"1\":{\"405\":1}}],[\"不指定commond时\",{\"1\":{\"372\":1}}],[\"不指定条件列表\",{\"1\":{\"93\":1}}],[\"不建议在⽣产环境设备上使⽤\",{\"1\":{\"361\":1}}],[\"不建议使用\",{\"1\":{\"283\":1}}],[\"不需要记录整个dp数组\",{\"1\":{\"506\":1}}],[\"不需要我们创建\",{\"1\":{\"339\":1}}],[\"不需要额外排序\",{\"1\":{\"209\":1}}],[\"不完整\",{\"1\":{\"321\":1}}],[\"不能满足时\",{\"1\":{\"492\":1}}],[\"不能包含特殊字符\",{\"1\":{\"425\":1}}],[\"不能像集合那样\",{\"1\":{\"398\":1}}],[\"不能将所有的实际内存分配给\",{\"1\":{\"319\":1}}],[\"不能只删除某一个字段的值\",{\"1\":{\"182\":1}}],[\"不仅仅对\",{\"1\":{\"304\":1}}],[\"不仅如此还会记录自己在学习生活中的一些感想感悟\",{\"1\":{\"1\":1}}],[\"不存在则从数据库查询\",{\"1\":{\"282\":1}}],[\"不存在则返回\",{\"1\":{\"282\":1}}],[\"不用自己维护\",{\"1\":{\"274\":1}}],[\"不过在其\",{\"1\":{\"454\":1}}],[\"不过需要同时满足连个条件\",{\"1\":{\"419\":1}}],[\"不过根据字符串的格式不同\",{\"1\":{\"376\":1}}],[\"不过\",{\"1\":{\"273\":1}}],[\"不过可以使用update语句来进行修改\",{\"1\":{\"182\":1}}],[\"不取值\",{\"1\":{\"221\":1}}],[\"不通过innodb引擎提供的计数方式进行计算\",{\"1\":{\"220\":1}}],[\"不符合where条件的不参与分组\",{\"1\":{\"190\":1}}],[\"不是以空字符串来判断是否结束\",{\"1\":{\"425\":1}}],[\"不是与节点绑定\",{\"1\":{\"343\":1}}],[\"不是用户定义的\",{\"1\":{\"242\":1}}],[\"不是针对记录值加的锁\",{\"1\":{\"223\":1}}],[\"不是\",{\"1\":{\"187\":1}}],[\"不等于\",{\"1\":{\"187\":1}}],[\"不保证有序\",{\"1\":{\"418\":1}}],[\"不保证一致性\",{\"1\":{\"272\":1}}],[\"不保证遵循acid原则的数据存储系统\",{\"1\":{\"109\":1}}],[\"不保存查询的结果\",{\"1\":{\"162\":1}}],[\"不支持外键\",{\"1\":{\"235\":1}}],[\"不支持事务\",{\"1\":{\"235\":1}}],[\"不支持语句级触发\",{\"1\":{\"153\":1}}],[\"不支持范围查找\",{\"1\":{\"121\":1}}],[\"不支持范围查询\",{\"1\":{\"115\":1}}],[\"不回表查询\",{\"1\":{\"131\":1}}],[\"不加引号\",{\"1\":{\"129\":1}}],[\"不加锁\",{\"1\":{\"81\":2}}],[\"不要在索引列上进行运算操作\",{\"1\":{\"129\":1}}],[\"不要求逻辑上相邻的元素在物理位置上也相邻\",{\"1\":{\"33\":1}}],[\"不提供技术支持\",{\"1\":{\"106\":1}}],[\"不在指定的集合范围内\",{\"1\":{\"100\":1}}],[\"不在\",{\"1\":{\"86\":1}}],[\"不可见的\",{\"1\":{\"464\":1}}],[\"不可修改\",{\"1\":{\"425\":1}}],[\"不可重复读\",{\"1\":{\"258\":1,\"259\":1}}],[\"不可以对元数据进行写入操作\",{\"1\":{\"144\":1}}],[\"不可以访问该版本\",{\"1\":{\"86\":1}}],[\"不可分割\",{\"1\":{\"32\":1}}],[\"不单单依赖undo\",{\"1\":{\"84\":1}}],[\"不同路径\",{\"0\":{\"508\":1},\"1\":{\"510\":1}}],[\"不同层指针到下一个节点的跨度不同\",{\"1\":{\"453\":1}}],[\"不同的三元组是\",{\"1\":{\"477\":1}}],[\"不同的存储引擎具有不同的功能\",{\"1\":{\"231\":1}}],[\"不同的存储引擎有不同的结构\",{\"1\":{\"115\":1}}],[\"不同的数据库拥有不同的语法实现\",{\"1\":{\"192\":1}}],[\"不同的隔离级别\",{\"1\":{\"86\":1}}],[\"不同事务或者相同事务对同一条数据记录进行操作\",{\"1\":{\"84\":1}}],[\"不同主机的应用层之间经常需要可靠的\",{\"1\":{\"14\":1}}],[\"不会\",{\"1\":{\"432\":1}}],[\"不会产生数据丢失\",{\"1\":{\"432\":1}}],[\"不会自动立即将其清理和驱逐\",{\"1\":{\"283\":1}}],[\"不会驱逐任何键\",{\"1\":{\"276\":1,\"456\":1}}],[\"不会立刻被删除\",{\"1\":{\"83\":1}}],[\"不会直接操作磁盘\",{\"1\":{\"62\":1}}],[\"不重复的\",{\"1\":{\"47\":1}}],[\"不容易出错\",{\"1\":{\"21\":1}}],[\"不以理睬\",{\"1\":{\"16\":1}}],[\"可见字符串是\",{\"1\":{\"425\":1}}],[\"可写事件\",{\"1\":{\"406\":1}}],[\"可写时得到通知\",{\"1\":{\"404\":1}}],[\"可读事件\",{\"1\":{\"406\":1}}],[\"可读\",{\"1\":{\"404\":1,\"460\":1}}],[\"可读性差\",{\"1\":{\"352\":1}}],[\"可排序这几个需求\",{\"1\":{\"419\":1}}],[\"可排序\",{\"1\":{\"380\":1}}],[\"可靠性差\",{\"1\":{\"320\":1}}],[\"可靠性高\",{\"1\":{\"320\":1}}],[\"可靠性能较低\",{\"1\":{\"280\":1}}],[\"可靠性要求较高\",{\"1\":{\"280\":1}}],[\"可靠性更好\",{\"1\":{\"280\":1}}],[\"可靠的\",{\"1\":{\"14\":1}}],[\"可控性更高\",{\"1\":{\"275\":1}}],[\"可选\",{\"1\":{\"245\":2,\"392\":1}}],[\"可以选择向上两个台阶或者一个台阶\",{\"1\":{\"534\":1}}],[\"可以选择⾃⼰喜欢的⼀款就可以\",{\"1\":{\"373\":1}}],[\"可以证明这是一个有效的巡视方案\",{\"1\":{\"514\":1}}],[\"可以按行s形遍历\",{\"1\":{\"511\":1}}],[\"可以被回收\",{\"1\":{\"465\":1}}],[\"可以被立即删除\",{\"1\":{\"83\":1}}],[\"可以使用config\",{\"1\":{\"448\":1}}],[\"可以使用\",{\"1\":{\"448\":1}}],[\"可以使用角标获取\",{\"1\":{\"311\":1}}],[\"可以简单的理解为慢慢的将旧的哈希表\",{\"1\":{\"438\":1}}],[\"可以简单的理解为cascaded是强制检查所有相关的视图\",{\"1\":{\"164\":1}}],[\"可以节省内存空间\",{\"1\":{\"433\":1}}],[\"可以是上述所有类型\",{\"1\":{\"421\":1}}],[\"可以是多列的数据集\",{\"1\":{\"101\":1}}],[\"可以是多行的数据集\",{\"1\":{\"100\":1}}],[\"可以实现\",{\"1\":{\"481\":1}}],[\"可以实现快速访问功能\",{\"1\":{\"419\":1}}],[\"可以实现排序功能\",{\"1\":{\"419\":1}}],[\"可以键值存储\",{\"1\":{\"419\":1}}],[\"可以排序\",{\"1\":{\"419\":1}}],[\"可以根据\",{\"1\":{\"419\":1}}],[\"可以根据score\",{\"1\":{\"419\":1}}],[\"可以根据索引的选择性来决定\",{\"1\":{\"132\":1}}],[\"可以根据索引长度来判断\",{\"1\":{\"129\":1}}],[\"可以满足元素唯一\",{\"1\":{\"418\":1}}],[\"可以判断元素是否存在\",{\"1\":{\"418\":1}}],[\"可以从首\",{\"1\":{\"416\":1}}],[\"可以从以下几个方面来优化\",{\"1\":{\"301\":1}}],[\"可以看做一种连续内存空间的\",{\"1\":{\"444\":1}}],[\"可以看做一种特殊的双端链表\",{\"1\":{\"440\":1}}],[\"可以看做是特殊的整数数组\",{\"1\":{\"433\":1}}],[\"可以看做是一个value为null的hashmap\",{\"1\":{\"379\":1}}],[\"可以看做是一个双向链表结构\",{\"1\":{\"378\":1}}],[\"可以看做是命令日志文件\",{\"1\":{\"320\":1}}],[\"可以看如下对比\",{\"1\":{\"428\":1}}],[\"可以看到\",{\"1\":{\"402\":1,\"403\":1}}],[\"可以计算多个hll\",{\"1\":{\"398\":1}}],[\"可以随时对任意⼀位进⾏运算\",{\"1\":{\"397\":1}}],[\"可以自定义大小\",{\"1\":{\"406\":1}}],[\"可以自定义\",{\"1\":{\"386\":1}}],[\"可以自己设置\",{\"1\":{\"206\":1}}],[\"可以分发消息\",{\"1\":{\"385\":1}}],[\"可以基于score属性对元素排序\",{\"1\":{\"380\":1}}],[\"可以针对单个字段做crud\",{\"1\":{\"377\":1}}],[\"可以针对于字段的特点\",{\"1\":{\"134\":1}}],[\"可以做自增\",{\"1\":{\"376\":2}}],[\"可以包含任何数据\",{\"1\":{\"376\":1}}],[\"可以直接在国内的gitee中下载安装\",{\"1\":{\"373\":1}}],[\"可以参考redis官方的安装文档\",{\"1\":{\"366\":1}}],[\"可以查看⼀个命令的具体⽤法\",{\"1\":{\"361\":1}}],[\"可以查看当前数据库的insert\",{\"1\":{\"226\":1}}],[\"可以接收任意\",{\"1\":{\"352\":1}}],[\"可以接收参数\",{\"1\":{\"239\":1}}],[\"可以明显的看到\",{\"1\":{\"352\":1}}],[\"可以将其处理的某个复杂任务分配给网络中的其他计算机系统\",{\"1\":{\"575\":1}}],[\"可以将注意力集中于业务逻辑上\",{\"1\":{\"347\":1}}],[\"可以将共享看作是只读\",{\"1\":{\"147\":1}}],[\"可以执行命令\",{\"1\":{\"340\":1}}],[\"可以让任何客户端访问任何时刻的数据\",{\"1\":{\"385\":1}}],[\"可以让\",{\"1\":{\"320\":1}}],[\"可以帮助我们安装一个第三方的lua模块\",{\"1\":{\"305\":1}}],[\"可以发现\",{\"1\":{\"298\":1}}],[\"可以运行下面命令\",{\"1\":{\"296\":1}}],[\"可以重复执行指定语句\",{\"1\":{\"289\":1}}],[\"可以再集群间共享\",{\"1\":{\"280\":1}}],[\"可以用其来实现简单的死循环\",{\"1\":{\"251\":1}}],[\"可以作存储过程内的局部变量和输入参数\",{\"1\":{\"244\":1}}],[\"可以适当增大排序缓冲区大小sort\",{\"1\":{\"211\":1}}],[\"可以手动开启事务\",{\"1\":{\"200\":1}}],[\"可以理解为给sql语句设置别名\",{\"1\":{\"162\":1}}],[\"可以讲索引分为两种类型\",{\"1\":{\"127\":1}}],[\"可以存储到\",{\"1\":{\"344\":1}}],[\"可以存储大量数据\",{\"1\":{\"37\":1}}],[\"可以存在多个\",{\"1\":{\"124\":1}}],[\"可以有多个\",{\"1\":{\"124\":3}}],[\"可以通过redis\",{\"1\":{\"344\":1}}],[\"可以通过like模糊匹配的方式查找变量\",{\"1\":{\"242\":1}}],[\"可以通过\",{\"1\":{\"228\":1,\"361\":1}}],[\"可以通过覆盖索引加子查询形式进行优化\",{\"1\":{\"218\":1}}],[\"可以通过索引来提高效率\",{\"1\":{\"214\":1}}],[\"可以通过构建链表来解决\",{\"1\":{\"121\":1}}],[\"可以通过它来找到该记录修改前的信息\",{\"1\":{\"58\":1}}],[\"可以访问该版本\",{\"1\":{\"86\":2}}],[\"可以认为当delete一条记录时\",{\"1\":{\"76\":1}}],[\"可以指定该表空间\",{\"1\":{\"68\":1}}],[\"可以在任意一端压入弹出操作\",{\"1\":{\"440\":1}}],[\"可以在\",{\"1\":{\"242\":1,\"319\":1}}],[\"可以在sql语句中实现条件筛选\",{\"1\":{\"56\":1}}],[\"可以在创建表\",{\"1\":{\"47\":1}}],[\"可以在看完视频后\",{\"1\":{\"20\":1}}],[\"可能的8个点位的值\",{\"1\":{\"516\":1}}],[\"可能会影响查询效率\",{\"1\":{\"444\":1}}],[\"可能会产生一系列的问题\",{\"1\":{\"258\":1}}],[\"可能丢失大量数据\",{\"1\":{\"320\":1}}],[\"可能有死锁风险\",{\"1\":{\"272\":1}}],[\"可能造成短期的不一致\",{\"1\":{\"270\":1}}],[\"可能并不总是准确的\",{\"1\":{\"229\":1}}],[\"可能不用了\",{\"1\":{\"73\":1}}],[\"可能客户端发送很多请求以后\",{\"1\":{\"16\":1}}],[\"可能也会有对知识的误解和遗漏\",{\"1\":{\"3\":1}}],[\"工具类\",{\"1\":{\"359\":1}}],[\"工具使用\",{\"0\":{\"11\":1}}],[\"工作和生活\",{\"1\":{\"577\":1}}],[\"工作目录\",{\"1\":{\"295\":1}}],[\"工作总结\",{\"1\":{\"3\":1}}],[\"希望读者们不吝赐教\",{\"1\":{\"3\":1}}],[\"也称端系统\",{\"1\":{\"569\":1}}],[\"也称为物理结构\",{\"1\":{\"33\":1}}],[\"也节约了一些cpu时间\",{\"1\":{\"469\":1}}],[\"也叫做\",{\"1\":{\"465\":1}}],[\"也叫散列\",{\"1\":{\"377\":1}}],[\"也只能从头到尾遍历链表\",{\"1\":{\"450\":1}}],[\"也会对负载因子做检查\",{\"1\":{\"437\":1}}],[\"也会在触发阈值时自动去重写\",{\"1\":{\"320\":1}}],[\"也读一行\",{\"1\":{\"422\":1}}],[\"也没有键值对的概念\",{\"1\":{\"419\":1}}],[\"也没有合适的唯一索引\",{\"1\":{\"124\":1}}],[\"也做了同样的处理\",{\"1\":{\"352\":1}}],[\"也伴随着槽位及槽位中数据在节点之间的移动\",{\"1\":{\"344\":1}}],[\"也被叫做\",{\"1\":{\"319\":1}}],[\"也是立即缩容\",{\"1\":{\"443\":1}}],[\"也是我们需要重点掌握的协议\",{\"1\":{\"421\":1}}],[\"也是返回0\",{\"1\":{\"397\":1}}],[\"也是实际业务中容易出错的一个点\",{\"1\":{\"257\":1}}],[\"也是遵循最最前缀法则的\",{\"1\":{\"211\":1}}],[\"也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表\",{\"1\":{\"437\":1}}],[\"也就是\",{\"1\":{\"417\":1,\"419\":1,\"496\":1}}],[\"也就是阶段二是同步还是异步\",{\"1\":{\"413\":1}}],[\"也就是字符串类型\",{\"1\":{\"376\":1}}],[\"也就是本地缓存\",{\"1\":{\"307\":1}}],[\"也就是该参数可以作为返回值\",{\"1\":{\"246\":1}}],[\"也就是需要调用时传入值\",{\"1\":{\"246\":1}}],[\"也就是说扩容和收缩操作不是一次性\",{\"1\":{\"438\":1}}],[\"也就是说\",{\"1\":{\"232\":1}}],[\"也就是数据表之间的关系\",{\"1\":{\"89\":1}}],[\"也可以是硬件共享\",{\"1\":{\"574\":1}}],[\"也可以是外连接查询\",{\"1\":{\"96\":1}}],[\"也可以按列s型遍历\",{\"1\":{\"511\":1}}],[\"也可以将bitmap想象成⼀个只能存储0\",{\"1\":{\"397\":1}}],[\"也可以根据自己的需求来删除或添加词条\",{\"1\":{\"376\":1}}],[\"也可以作为输出参数\",{\"1\":{\"246\":1}}],[\"也可以返回数据\",{\"1\":{\"239\":1}}],[\"也可以建立相关的表\",{\"1\":{\"220\":1}}],[\"也可以填充100\",{\"1\":{\"205\":1}}],[\"也可以填充一半\",{\"1\":{\"205\":1}}],[\"也可以归纳为字段操作\",{\"1\":{\"177\":1}}],[\"也可以简化他们的操作\",{\"1\":{\"167\":1}}],[\"也更加复杂\",{\"1\":{\"136\":1}}],[\"也要消耗掉一个序号\",{\"1\":{\"17\":1}}],[\"也能够后续的读者展现出更高质量的文章\",{\"1\":{\"3\":1}}],[\"也希望读者朋友们保持一个批判性思维\",{\"1\":{\"3\":1}}],[\"也希望其他人在对本人文章进行参考时\",{\"1\":{\"3\":1}}],[\"也加上文章的来源\",{\"1\":{\"3\":1}}],[\"也不预留内存空间\",{\"1\":{\"443\":1}}],[\"也不会随着报错而停止\",{\"1\":{\"399\":1}}],[\"也不会造成后续的指令不做\",{\"1\":{\"399\":1}}],[\"也不存在数据的移动问题\",{\"1\":{\"205\":1}}],[\"也不乏来源于互联网\",{\"1\":{\"3\":1}}],[\"也不见得这些笔记没有价值\",{\"1\":{\"2\":1}}],[\"本身可以包含字符串对象\",{\"1\":{\"469\":1}}],[\"本身是一个典型的\",{\"1\":{\"454\":1}}],[\"本身是有一个\",{\"1\":{\"385\":1}}],[\"本身没有排序功能\",{\"1\":{\"419\":1}}],[\"本质是\",{\"1\":{\"405\":1}}],[\"本质是字符串key\",{\"1\":{\"397\":1}}],[\"本质上就是\",{\"1\":{\"460\":1}}],[\"本质上是一个东西\",{\"1\":{\"293\":1}}],[\"本质上都是对数据的缓存\",{\"1\":{\"283\":1}}],[\"本地进程缓存\",{\"0\":{\"280\":1}}],[\"本人所写的所有内容也并非100\",{\"1\":{\"3\":1}}],[\"本人根据互联网上的资料加上本人对知识的理解\",{\"1\":{\"3\":1}}],[\"本项目中的内容除了自己的日常学习\",{\"1\":{\"3\":1}}],[\"失去了缓存保护后端持久的意义\",{\"1\":{\"2\":1}}],[\"是从楼梯第\",{\"1\":{\"532\":1}}],[\"是骑士访问的第\",{\"1\":{\"514\":1}}],[\"是保证k在i和j之前\",{\"1\":{\"482\":1}}],[\"是不合适的\",{\"1\":{\"469\":1}}],[\"是不是\",{\"1\":{\"454\":1}}],[\"是不是第一次来同步数据\",{\"1\":{\"300\":1}}],[\"是因为需要保证其指针后最少有一个i指针和j指针的存在\",{\"1\":{\"481\":1}}],[\"是因为这三种特殊类型的底层是使用obj\",{\"1\":{\"467\":1}}],[\"是因为并不是每次\",{\"1\":{\"456\":1}}],[\"是因为其具备动态扩容的能力\",{\"1\":{\"427\":1}}],[\"是如何知道一个\",{\"1\":{\"454\":1}}],[\"是如何判断\",{\"1\":{\"300\":1}}],[\"是以\",{\"1\":{\"442\":2}}],[\"是分多次\",{\"1\":{\"438\":1}}],[\"是使用\",{\"1\":{\"425\":1}}],[\"是字符串\",{\"1\":{\"425\":1}}],[\"是紧挨在一起的两个\",{\"1\":{\"419\":1}}],[\"是连续内存\",{\"1\":{\"419\":1}}],[\"是与内核建立\",{\"1\":{\"411\":1}}],[\"是谁\",{\"1\":{\"410\":1}}],[\"是利用单个线程来同时监听多个\",{\"1\":{\"404\":1}}],[\"是⽤来做基数统计的算法\",{\"1\":{\"398\":1}}],[\"是redis中最简单的存储类型\",{\"1\":{\"376\":1}}],[\"是当前sentinel实例的端口\",{\"1\":{\"331\":1}}],[\"是记录命令\",{\"1\":{\"320\":1}}],[\"是默认方案\",{\"1\":{\"320\":1}}],[\"是需要写入磁盘中\",{\"1\":{\"319\":1}}],[\"是内存存储\",{\"1\":{\"318\":1}}],[\"是内存的缓存\",{\"1\":{\"269\":1}}],[\"是否和棋盘的长乘宽相等\",{\"1\":{\"516\":1}}],[\"是否和现在所占据的点位的值是否差1\",{\"1\":{\"516\":1}}],[\"是否过期呢\",{\"1\":{\"454\":1}}],[\"是否大于\",{\"1\":{\"406\":1}}],[\"是否确认移动\",{\"1\":{\"344\":1}}],[\"是否按照预期工作\",{\"1\":{\"324\":1}}],[\"是否开启\",{\"1\":{\"320\":1}}],[\"是否压缩\",{\"1\":{\"319\":1}}],[\"是否相同\",{\"1\":{\"300\":1}}],[\"是否为null\",{\"1\":{\"187\":1}}],[\"是数据集的标记\",{\"1\":{\"300\":1}}],[\"是数据的一个子集\",{\"1\":{\"32\":1}}],[\"是数据的基本单位\",{\"1\":{\"32\":1}}],[\"是\",{\"1\":{\"281\":1,\"343\":1,\"352\":1,\"358\":1,\"385\":1,\"405\":1,\"408\":1,\"415\":1,\"418\":2,\"430\":1,\"450\":1}}],[\"是存储数据的临时地方\",{\"1\":{\"269\":1}}],[\"是面试中经常被问到的一个知识点\",{\"1\":{\"257\":1}}],[\"是mysql的默认存储引擎\",{\"1\":{\"237\":1}}],[\"是通过一个定时任务\",{\"1\":{\"455\":1}}],[\"是通过索引查询的\",{\"1\":{\"210\":1}}],[\"是通过将一张表复制成两张\",{\"1\":{\"96\":1}}],[\"是using\",{\"1\":{\"209\":2}}],[\"是可有可无的\",{\"1\":{\"177\":1}}],[\"是可选项\",{\"1\":{\"127\":1}}],[\"是一段连续空间\",{\"1\":{\"415\":1}}],[\"是一种以\",{\"1\":{\"446\":1}}],[\"是一种消息通信模式\",{\"1\":{\"381\":1}}],[\"是一种轻量小巧的脚本语言\",{\"1\":{\"286\":1}}],[\"是一种通过建立倒排索引\",{\"1\":{\"115\":1}}],[\"是一些客户端和链接服务\",{\"1\":{\"231\":1}}],[\"是一个节点为\",{\"1\":{\"449\":1}}],[\"是一个\",{\"1\":{\"421\":1}}],[\"是一个从\",{\"1\":{\"404\":1}}],[\"是一个可排序的set集合\",{\"1\":{\"380\":1}}],[\"是一个基于内存的键值型的nosql数据库\",{\"1\":{\"365\":1}}],[\"是一个基于\",{\"1\":{\"280\":1,\"281\":1,\"304\":1}}],[\"是一个估计值\",{\"1\":{\"229\":1}}],[\"是一个聚合函数\",{\"1\":{\"221\":1}}],[\"是一个比较重的操作\",{\"1\":{\"140\":1}}],[\"是优化数据库的一个重要手段\",{\"1\":{\"130\":1}}],[\"是哈希结构\",{\"1\":{\"121\":1}}],[\"是非阻塞读\",{\"1\":{\"81\":1}}],[\"是非随机存取的存储结构\",{\"1\":{\"37\":1}}],[\"是用来实现事务的原子性\",{\"1\":{\"76\":1}}],[\"是用来实现事务的持久性\",{\"1\":{\"75\":1}}],[\"是系统根据情况自动完成的\",{\"1\":{\"64\":1}}],[\"是删除第\",{\"1\":{\"36\":1}}],[\"是在第\",{\"1\":{\"36\":2}}],[\"是线性表的元素类型\",{\"1\":{\"36\":1}}],[\"是指在使用哈希表存储数据时\",{\"1\":{\"435\":1}}],[\"是指数据结构在计算机中的表示\",{\"1\":{\"33\":1}}],[\"是指数据元素之间的逻辑关系\",{\"1\":{\"33\":1}}],[\"是指查询一个根本不存在的数据\",{\"1\":{\"2\":1}}],[\"是相互之间存在的一种或多种特定关系的数据元素的集合\",{\"1\":{\"32\":1}}],[\"是描述客观事物属性的数\",{\"1\":{\"32\":1}}],[\"是什么\",{\"0\":{\"1\":1}}],[\"一定是在新的哈希表上进行的\",{\"1\":{\"438\":1}}],[\"一段时间内不能进行别的操作\",{\"1\":{\"438\":1}}],[\"一种是dict\",{\"1\":{\"417\":1}}],[\"一种是ziplist\",{\"1\":{\"417\":1}}],[\"一颗红黑树\",{\"1\":{\"407\":1}}],[\"一键启动所有服务\",{\"1\":{\"340\":1}}],[\"一键拷贝\",{\"1\":{\"295\":1,\"331\":1}}],[\"一样的元素的角标\",{\"1\":{\"432\":1}}],[\"一样\",{\"1\":{\"326\":1}}],[\"一致\",{\"1\":{\"482\":2}}],[\"一致则说明是同一数据集\",{\"1\":{\"300\":1}}],[\"一致性要求较高\",{\"1\":{\"364\":1}}],[\"一致性数据备份\",{\"0\":{\"139\":1}}],[\"一致性\",{\"1\":{\"74\":1,\"86\":1,\"257\":1,\"274\":1}}],[\"一组被重复执行的语句称之为循环体\",{\"1\":{\"289\":1}}],[\"一旦你支付此费用\",{\"1\":{\"532\":1}}],[\"一旦发现master\",{\"1\":{\"326\":1}}],[\"一旦确定了缓存最大容量\",{\"1\":{\"273\":1}}],[\"一旦深入一点\",{\"1\":{\"2\":1}}],[\"一行行地判断\",{\"1\":{\"221\":1}}],[\"一行数据大小为1k=1024b=1024字节\",{\"1\":{\"126\":1}}],[\"一般认为\",{\"1\":{\"564\":1}}],[\"一般会把一些常见的值放到一个共享对象中\",{\"1\":{\"469\":1}}],[\"一般为\",{\"1\":{\"465\":1}}],[\"一般为null\",{\"1\":{\"229\":1}}],[\"一般情况下使用的格式为\",{\"1\":{\"376\":1}}],[\"一般情况下都使用第一种方法\",{\"1\":{\"275\":1}}],[\"一般适用于网络带宽较大的情况下\",{\"1\":{\"301\":1}}],[\"一般\",{\"1\":{\"274\":1}}],[\"一般来说\",{\"1\":{\"273\":1,\"428\":1}}],[\"一般读写性能比较高\",{\"1\":{\"269\":1}}],[\"一般分页查询时\",{\"1\":{\"218\":1}}],[\"一般是以阶树来衡量b树\",{\"1\":{\"118\":1}}],[\"一次性加载进数据库内\",{\"1\":{\"202\":1}}],[\"一次性可以插入多个数据\",{\"1\":{\"199\":1}}],[\"一次select的返回集又称为了另外一个select的数据集\",{\"1\":{\"98\":1}}],[\"一页中能存储16行这样的数据\",{\"1\":{\"126\":1}}],[\"一棵n阶b树的节点最多能存储n\",{\"1\":{\"118\":1}}],[\"一共支持\",{\"1\":{\"276\":1,\"456\":1}}],[\"一共有\",{\"1\":{\"93\":1}}],[\"一共执行的次数\",{\"1\":{\"27\":1}}],[\"一共执行的次数t\",{\"1\":{\"26\":1}}],[\"一对多的关系也可以看作多对一\",{\"1\":{\"91\":1}}],[\"一对多\",{\"0\":{\"91\":1}}],[\"一对一关系是我们比较常见的关系\",{\"1\":{\"90\":1}}],[\"一对一\",{\"0\":{\"90\":1}}],[\"一个完整的计算机网络主要由硬件\",{\"1\":{\"569\":1}}],[\"一个机器人位于一个\",{\"1\":{\"509\":1}}],[\"一个用来记录\",{\"1\":{\"454\":1}}],[\"一个dict包含两个哈希表\",{\"1\":{\"436\":1}}],[\"一个包含字符串name的sds结构如下\",{\"1\":{\"426\":1}}],[\"一个占3个字节\",{\"1\":{\"421\":1}}],[\"一个链表\",{\"1\":{\"407\":1}}],[\"一个消费组有多个消费者\",{\"1\":{\"385\":1}}],[\"一个主节点\",{\"1\":{\"294\":1}}],[\"一个事务从开始到执行会经历以下三个阶段\",{\"1\":{\"399\":1}}],[\"一个事务按照指定条件查询数据时\",{\"1\":{\"258\":1}}],[\"一个事务先后读取同一条记录\",{\"1\":{\"258\":1}}],[\"一个事务读到另外一个事务还没有提交的数据\",{\"1\":{\"258\":1}}],[\"一个或者多个\",{\"1\":{\"229\":1}}],[\"一个升序一个降序\",{\"1\":{\"211\":1}}],[\"一个索引可以关联多个字段\",{\"1\":{\"127\":1}}],[\"一个学生可以选择多门课程\",{\"1\":{\"92\":1}}],[\"一个部门下有多个员工\",{\"1\":{\"91\":1}}],[\"一个mysql实例可以对应多个表空间\",{\"1\":{\"58\":1}}],[\"一个算法的设计取决于所选定的逻辑结构\",{\"1\":{\"33\":1}}],[\"一个数据元素可由若干数据项组成\",{\"1\":{\"32\":1}}],[\"一些自己的思考和想法\",{\"1\":{\"1\":1}}],[\"但有的网格只有这两种方式的其中一个\",{\"1\":{\"511\":1}}],[\"但两次fast模式间隔不低于2ms\",{\"1\":{\"455\":1}}],[\"但由于编码方式只能写一种\",{\"1\":{\"419\":1}}],[\"但批量指令并非原子化的操作\",{\"1\":{\"399\":1}}],[\"但\",{\"1\":{\"399\":1}}],[\"但无法记录历史消息\",{\"1\":{\"385\":1}}],[\"但它有个缺点就是消息无法持久化\",{\"1\":{\"385\":1}}],[\"但底层数据结构却差别很大\",{\"1\":{\"380\":1}}],[\"但主要分为三种类型\",{\"1\":{\"371\":1}}],[\"但只有最后一次写操作才有意义\",{\"1\":{\"320\":1}}],[\"但如果\",{\"1\":{\"301\":1}}],[\"但还是有所区别\",{\"1\":{\"281\":1}}],[\"但这部分数据依然留在缓存中\",{\"1\":{\"273\":1}}],[\"但更多时候选择redis数据库\",{\"1\":{\"237\":1}}],[\"但不执行\",{\"1\":{\"384\":1}}],[\"但不包含写入数据的语句\",{\"1\":{\"254\":1}}],[\"但不支持行锁\",{\"1\":{\"235\":1}}],[\"但不取值\",{\"1\":{\"221\":1}}],[\"但长度为\",{\"1\":{\"129\":1}}],[\"但突然恢复以后\",{\"1\":{\"16\":1}}],[\"但是要正确实现这些命令\",{\"1\":{\"464\":1}}],[\"但是要自己保证递增性\",{\"1\":{\"386\":1}}],[\"但是与传统的链表相比有些差异\",{\"1\":{\"451\":1}}],[\"但是申请内存必须是连续空间\",{\"1\":{\"444\":1}}],[\"但是进行增加操作\",{\"1\":{\"438\":1}}],[\"但是目前\",{\"1\":{\"421\":1}}],[\"但是目前每个服务之间都是独立的\",{\"1\":{\"341\":1}}],[\"但是依然要遍历所有的\",{\"1\":{\"410\":1}}],[\"但是依然有两个问题没有解决\",{\"1\":{\"337\":1}}],[\"但是时间通知的模式有两种\",{\"1\":{\"408\":1}}],[\"但是不确定是那个\",{\"1\":{\"404\":1}}],[\"但是不能授权到数据库特定行和特定的列上\",{\"1\":{\"167\":1}}],[\"但是不能深究\",{\"1\":{\"2\":1}}],[\"但是性能提升并不明显\",{\"1\":{\"406\":1}}],[\"但是性能并没有得到提高\",{\"1\":{\"403\":1}}],[\"但是性能越低\",{\"1\":{\"259\":1}}],[\"但是用户进程会一直发起请求\",{\"1\":{\"403\":1}}],[\"但是还没有\",{\"1\":{\"385\":1}}],[\"但是允许有多个单词形成层级结构\",{\"1\":{\"376\":1}}],[\"但是这种方式在我们使用过程中不太直观\",{\"1\":{\"371\":1}}],[\"但是这里还是想整理成方法论\",{\"1\":{\"21\":1}}],[\"但是对命令的执行依然是单线程\",{\"1\":{\"365\":1}}],[\"但是对于innodb引擎\",{\"1\":{\"219\":1}}],[\"但是从代码中看\",{\"1\":{\"352\":1}}],[\"但是多线程环境下必须使用jedis连接池\",{\"1\":{\"347\":1}}],[\"但是也无法满足如\",{\"1\":{\"318\":1}}],[\"但是也要占用一个序号\",{\"1\":{\"15\":1}}],[\"但是\",{\"1\":{\"281\":1,\"398\":1,\"425\":1,\"441\":1,\"491\":1}}],[\"但是成本也会更高\",{\"1\":{\"273\":1}}],[\"但是两次读取的数据不一致\",{\"1\":{\"258\":1}}],[\"但是在高并发的访问下\",{\"1\":{\"412\":1}}],[\"但是在插入操作时\",{\"1\":{\"258\":1}}],[\"但是在并发环境下\",{\"1\":{\"258\":1}}],[\"但是在mysql中\",{\"1\":{\"243\":1}}],[\"但是repeat是满足条件则推出和do\",{\"1\":{\"250\":1}}],[\"但是存储过程中的sql语句\",{\"1\":{\"240\":1}}],[\"但是仍耗费了很长时间\",{\"1\":{\"227\":1}}],[\"但是仍要占用一个序号\",{\"1\":{\"15\":1}}],[\"但是有时候我们对于sql已经优化到了极致\",{\"1\":{\"227\":1}}],[\"但是如果键值对有几百万\",{\"1\":{\"438\":1}}],[\"但是如果对age字段建立索引\",{\"1\":{\"210\":1}}],[\"但是如果下一次想要插入的数据主键不为最大值\",{\"1\":{\"205\":1}}],[\"但是一次性插入的数据量不建议超过500\",{\"1\":{\"199\":1}}],[\"但是一个员工只能属于一个部门\",{\"1\":{\"91\":1}}],[\"但是常用的就以下几种\",{\"1\":{\"196\":1}}],[\"但是没有筛选条件时则会删除整张表的所有数据\",{\"1\":{\"182\":1}}],[\"但是没有筛选条件时则会修改整张表的所有数据\",{\"1\":{\"181\":1}}],[\"但是由于数据查询的操作使用频繁\",{\"1\":{\"179\":1}}],[\"但是例如字段自增的序号和建立的一些索引等是不会被清除的\",{\"1\":{\"177\":1}}],[\"但是实际存储的\",{\"1\":{\"352\":1}}],[\"但是实际上的操作流程是将表删除\",{\"1\":{\"177\":1}}],[\"但是实际的底层在b+树内查询了两次\",{\"1\":{\"125\":1}}],[\"但是会阻塞写\",{\"1\":{\"143\":1}}],[\"但是需要保证or\",{\"1\":{\"163\":1}}],[\"但是需要的数据都在索引列中能找到\",{\"1\":{\"131\":1}}],[\"但是需要回表查询数据\",{\"1\":{\"131\":1}}],[\"但是其可以对位进⾏操作\",{\"1\":{\"397\":1}}],[\"但是其为二级索引\",{\"1\":{\"126\":1}}],[\"但是其本质上仍然是二叉树\",{\"1\":{\"117\":1}}],[\"但是数据并未被修改过\",{\"1\":{\"61\":1}}],[\"但是tcp连接是全双工的\",{\"1\":{\"17\":1}}],[\"但是服务端还可以向客户端发送数据\",{\"1\":{\"17\":1}}],[\"但是三次握手已经足够保证连接可靠\",{\"1\":{\"16\":1}}],[\"但是网络信道并不可靠\",{\"1\":{\"16\":1}}],[\"但是ip层不提供这样的流机制\",{\"1\":{\"14\":1}}],[\"但时并未做到完美的点\",{\"1\":{\"3\":1}}],[\"但也绝不是简单的复制粘帖\",{\"1\":{\"3\":1}}],[\"但后期的维护和补丁也不可或缺\",{\"1\":{\"2\":1}}],[\"随后我们使i指针指向k指针的后面一个位置\",{\"1\":{\"481\":1}}],[\"随机分配到不同master\",{\"1\":{\"341\":1}}],[\"随着rehash最终为空\",{\"1\":{\"438\":1}}],[\"随着记录在\",{\"1\":{\"300\":1}}],[\"随着服务的不断运行\",{\"1\":{\"273\":1}}],[\"随着时间的变迁\",{\"1\":{\"1\":1}}],[\"随便提起来一些知识点也都能说上两嘴\",{\"1\":{\"2\":1}}],[\"会由命令回复处理器进行处理\",{\"1\":{\"460\":1}}],[\"会判断是客户端可读还是服务端可读\",{\"1\":{\"460\":1}}],[\"会统计每个\",{\"1\":{\"456\":1}}],[\"会设置一个定时任务\",{\"1\":{\"455\":1}}],[\"会基于原哈希表创建一个大小等于\",{\"1\":{\"437\":1}}],[\"会做哈希收缩\",{\"1\":{\"437\":1}}],[\"会确保\",{\"1\":{\"433\":1}}],[\"会不会做一个降级操作呢\",{\"1\":{\"432\":1}}],[\"会不断检查您的\",{\"1\":{\"324\":1}}],[\"会不断对知识进行迭代更新\",{\"1\":{\"1\":1}}],[\"会采用\",{\"1\":{\"418\":1}}],[\"会发出\",{\"1\":{\"411\":1}}],[\"会复杂一些\",{\"1\":{\"408\":1}}],[\"会重复通知多次\",{\"1\":{\"408\":1}}],[\"会通知用户进程\",{\"1\":{\"404\":1}}],[\"会使cpu空转\",{\"1\":{\"404\":1}}],[\"会使进程阻塞\",{\"1\":{\"404\":1}}],[\"会在处理客户端命令的方法\",{\"1\":{\"456\":1}}],[\"会在内核创建eventpoll结构体\",{\"1\":{\"407\":1}}],[\"会在用户空间和内核空间都加入缓冲区\",{\"1\":{\"401\":1}}],[\"会在什么时候执行\",{\"1\":{\"319\":1}}],[\"会自动过滤已经删除的消息\",{\"1\":{\"385\":1,\"390\":1,\"391\":1}}],[\"会进入redis\",{\"1\":{\"372\":1}}],[\"会带来额外的资源消耗\",{\"1\":{\"354\":1}}],[\"会根据\",{\"1\":{\"343\":1}}],[\"会把每一个\",{\"1\":{\"343\":1}}],[\"会将\",{\"1\":{\"430\":1}}],[\"会将最新信息推送给\",{\"1\":{\"324\":1}}],[\"会将一个\",{\"1\":{\"324\":1}}],[\"会将数据合并后去重\",{\"1\":{\"97\":1}}],[\"会有压缩\",{\"1\":{\"321\":1}}],[\"会记录对同一个\",{\"1\":{\"320\":1}}],[\"会阻塞所有命令\",{\"1\":{\"319\":1}}],[\"会对数据库产生冲击\",{\"1\":{\"279\":1}}],[\"会对读取的记录进行加锁\",{\"1\":{\"80\":1}}],[\"会话变量\",{\"1\":{\"242\":2}}],[\"会行溢出\",{\"1\":{\"205\":1}}],[\"会讲数据表内的所有数据清空\",{\"1\":{\"177\":1}}],[\"会讲全部的数据直接合并在一起\",{\"1\":{\"97\":1}}],[\"会导致只能在本地访问\",{\"1\":{\"369\":1}}],[\"会导致主从延迟\",{\"1\":{\"140\":1}}],[\"会导致该记录的\",{\"1\":{\"84\":1}}],[\"会影响增删改茶的效率\",{\"1\":{\"134\":1}}],[\"会选择该索引完成本次查询\",{\"1\":{\"133\":1}}],[\"会退化成为一个链表\",{\"1\":{\"116\":1}}],[\"会造成大量的磁盘io\",{\"1\":{\"62\":1}}],[\"会创建更多的连接\",{\"1\":{\"16\":1}}],[\"会给出参考的地址\",{\"1\":{\"3\":1}}],[\"会让你产生一种所有知识都懂假象\",{\"1\":{\"2\":1}}],[\"会让自己陷入一种自我麻痹且极度自信的状态\",{\"1\":{\"2\":1}}],[\"零散化地去学习\",{\"1\":{\"2\":1}}],[\"碎片化\",{\"1\":{\"2\":1}}],[\"目录创建文件夹\",{\"1\":{\"310\":1}}],[\"目录结构\",{\"1\":{\"305\":1}}],[\"目前\",{\"1\":{\"280\":1}}],[\"目前在互联网上有很多大佬开源了他们的学习笔记\",{\"1\":{\"2\":1}}],[\"目的是为了提高\",{\"1\":{\"461\":1}}],[\"目的是为了掌握知识点\",{\"1\":{\"2\":1}}],[\"目的都是为了加速数据的读取\",{\"1\":{\"283\":1}}],[\"目的\",{\"0\":{\"46\":1},\"1\":{\"566\":1}}],[\"盖好一栋大厦的关键在于打好地基\",{\"1\":{\"2\":1}}],[\"十分完美且科学\",{\"1\":{\"2\":1}}],[\"做压缩\",{\"1\":{\"448\":1}}],[\"做数据同步\",{\"1\":{\"300\":1}}],[\"做好数据的基础格式校验\",{\"1\":{\"270\":1}}],[\"做笔记并不是目的\",{\"1\":{\"2\":1}}],[\"做笔记其实并不是需要一步到位\",{\"1\":{\"2\":1}}],[\"做的堪称完美\",{\"1\":{\"2\":1}}],[\"以能够相互共享资源的方式互联起来的自治计算机系统的集合\",{\"1\":{\"566\":1}}],[\"以秒为单位记录最近一次访问时间\",{\"1\":{\"456\":1}}],[\"以\",{\"1\":{\"421\":1,\"425\":1,\"428\":1}}],[\"以crlf\",{\"1\":{\"421\":1}}],[\"以节省内存\",{\"1\":{\"418\":1}}],[\"以给定的经纬度为中⼼\",{\"1\":{\"396\":1}}],[\"以阻塞或非阻塞方式获取消息列表\",{\"1\":{\"385\":1,\"392\":1}}],[\"以上单机并发连接的高性能\",{\"1\":{\"304\":1}}],[\"以前的网络模型都是单线程的\",{\"1\":{\"460\":1}}],[\"以前\",{\"1\":{\"293\":1}}],[\"以限制其内存占用\",{\"1\":{\"281\":1}}],[\"以减少在并发环境下\",{\"1\":{\"223\":1}}],[\"以分号结尾\",{\"1\":{\"173\":1}}],[\"以使其符合视图的定义\",{\"1\":{\"164\":1}}],[\"以此类推\",{\"1\":{\"129\":1,\"191\":1,\"498\":1,\"521\":1}}],[\"以此类推即可\",{\"1\":{\"30\":1}}],[\"以下sql语句中\",{\"1\":{\"126\":1}}],[\"以其最大度数作为b树的阶数\",{\"1\":{\"118\":1}}],[\"以便于后续的理解和学习\",{\"1\":{\"104\":1}}],[\"以便于形成自己的知识体系\",{\"1\":{\"1\":1}}],[\"以循环方式写入重做日志文件\",{\"1\":{\"72\":1}}],[\"以后每次\",{\"1\":{\"410\":1}}],[\"以后\",{\"1\":{\"62\":1}}],[\"以及订阅这个频道的三个客户端\",{\"1\":{\"381\":1}}],[\"以及\",{\"1\":{\"304\":2}}],[\"以及相关的安全方案\",{\"1\":{\"231\":1}}],[\"以及两张表交集部分的数据\",{\"1\":{\"95\":2}}],[\"以及有哪些多表查询的情况\",{\"1\":{\"89\":1}}],[\"以及重做日志文件\",{\"1\":{\"75\":1}}],[\"以及每轮循环的变化值\",{\"1\":{\"21\":1,\"22\":1,\"23\":1,\"24\":1}}],[\"以及最后的解决方案\",{\"1\":{\"1\":1}}],[\"以为报文段丢失\",{\"1\":{\"16\":1}}],[\"在递推公式中\",{\"1\":{\"534\":1}}],[\"在有效的巡视方案中\",{\"1\":{\"514\":1}}],[\"在下图中标记为\",{\"1\":{\"509\":1}}],[\"在下一个循环内会变更另外一个指针\",{\"1\":{\"481\":1}}],[\"在解题之前\",{\"1\":{\"498\":1}}],[\"在k不变的情况下\",{\"1\":{\"481\":1}}],[\"在内\",{\"1\":{\"469\":1}}],[\"在内核中采用链表\",{\"1\":{\"406\":1}}],[\"在底层就需要调用不同的视线方式\",{\"1\":{\"464\":1}}],[\"在底层将数据序列化处理以后\",{\"1\":{\"352\":1}}],[\"在命令读处理和命令的响应两个部分引入了多线程\",{\"1\":{\"461\":1}}],[\"在命令行中\",{\"1\":{\"240\":1}}],[\"在ae\",{\"1\":{\"459\":1}}],[\"在核心网络模型中引入多线程\",{\"1\":{\"458\":1}}],[\"在两个重要的时间节点上引入了多线程的支持\",{\"1\":{\"458\":1}}],[\"在普通数组中每个元素定长\",{\"1\":{\"441\":1}}],[\"在设计时就很容易想到要尽量让每个元素按照实际的内容大小存储\",{\"1\":{\"441\":1}}],[\"在做特殊\",{\"1\":{\"436\":1}}],[\"在做题过程中\",{\"1\":{\"21\":1}}],[\"在哈希法\",{\"1\":{\"435\":1}}],[\"在添加数据时会进行扩容操作\",{\"1\":{\"432\":1}}],[\"在当前\",{\"1\":{\"432\":1}}],[\"在后\",{\"1\":{\"419\":1}}],[\"在异步\",{\"1\":{\"412\":1}}],[\"在单线程情况下\",{\"1\":{\"404\":1}}],[\"在单线程环境中可以不使用jedis连接池\",{\"1\":{\"347\":1}}],[\"在单线程环境下\",{\"1\":{\"258\":1}}],[\"在第二个阶段是阻塞的\",{\"1\":{\"403\":1}}],[\"在第一个实际节点之间附加一个头结点\",{\"1\":{\"37\":1}}],[\"在输⼊元素的数量或者体积⾮常⾮常⼤时\",{\"1\":{\"398\":1}}],[\"在地图上就是经纬度\",{\"1\":{\"396\":1}}],[\"在我们首次使用\",{\"1\":{\"385\":1}}],[\"在我们平常的业务中基本只会使用到redis的基本数据类型\",{\"1\":{\"375\":1,\"395\":1}}],[\"在使用redis\",{\"1\":{\"372\":1}}],[\"在获取数据以后\",{\"1\":{\"355\":1}}],[\"在上一篇中\",{\"1\":{\"352\":1}}],[\"在实际开发中往往会结合两者来使用\",{\"1\":{\"321\":1}}],[\"在linux的控制台输入命令以启动nginx\",{\"1\":{\"306\":1}}],[\"在最下面加入两行\",{\"1\":{\"305\":1}}],[\"在5\",{\"1\":{\"297\":1}}],[\"在函数参数列表中使用三点\",{\"1\":{\"291\":1}}],[\"在布尔表达式为\",{\"1\":{\"290\":2}}],[\"在条件进行判断前循环体都会执行一次\",{\"1\":{\"289\":1}}],[\"在条件表达式中相当于\",{\"1\":{\"288\":1}}],[\"在判断条件为\",{\"1\":{\"289\":1}}],[\"在正式介绍redis数据结构及其操作指令之前\",{\"1\":{\"361\":1}}],[\"在正式安装\",{\"1\":{\"304\":1}}],[\"在正式了解变量之前\",{\"1\":{\"288\":1}}],[\"在正式学习数据库的多表查询之前\",{\"1\":{\"89\":1}}],[\"在\",{\"1\":{\"287\":1,\"288\":1,\"293\":2,\"295\":3,\"301\":1,\"309\":2,\"310\":2,\"331\":1,\"334\":1,\"339\":1,\"360\":1,\"398\":1,\"404\":1,\"416\":2,\"421\":1,\"426\":1,\"458\":1,\"460\":1,\"464\":1,\"465\":1}}],[\"在默认情况下\",{\"1\":{\"283\":1}}],[\"在牺牲了功能和性能的代价下使代码更加规范\",{\"1\":{\"281\":1}}],[\"在某些场景下\",{\"1\":{\"281\":1}}],[\"在某个范围之内\",{\"1\":{\"187\":1}}],[\"在删除缓存\",{\"1\":{\"275\":1}}],[\"在操作缓存时\",{\"1\":{\"275\":1}}],[\"在更新数据库的同时更新缓存\",{\"1\":{\"275\":1}}],[\"在修改数据库的同时\",{\"1\":{\"274\":1}}],[\"在存储过程和函数中可以使用游标对结果集进行循环的处理\",{\"1\":{\"252\":1}}],[\"在存储元素信息时\",{\"1\":{\"33\":1}}],[\"在赋值时我们能看到有两种写法\",{\"1\":{\"243\":1}}],[\"在用的时候直接用\",{\"1\":{\"243\":1}}],[\"在并发条件下要求数据的一致性\",{\"1\":{\"237\":1}}],[\"在并发访问的情况下\",{\"1\":{\"84\":1}}],[\"在选择存储引擎时\",{\"1\":{\"237\":1}}],[\"在分组操作时\",{\"1\":{\"214\":1}}],[\"在没有建立任何索引的情况下\",{\"1\":{\"210\":1}}],[\"在order\",{\"1\":{\"209\":1}}],[\"在创建表或者创建索引时指定\",{\"1\":{\"206\":1}}],[\"在创建表时\",{\"1\":{\"68\":1}}],[\"在触发器内所执行的sql中\",{\"1\":{\"159\":1}}],[\"在rehash过程中\",{\"1\":{\"438\":1}}],[\"在redis5\",{\"1\":{\"341\":1}}],[\"在redis\",{\"1\":{\"297\":1}}],[\"在rr隔离级别下支持\",{\"1\":{\"146\":1}}],[\"在rr隔离级别下都支持\",{\"1\":{\"146\":1}}],[\"在rc\",{\"1\":{\"146\":1}}],[\"在访问一张表的时候会自动加上\",{\"1\":{\"144\":1}}],[\"在数据库字典中查找和他相对应的redisobject\",{\"1\":{\"468\":1}}],[\"在数据库中\",{\"1\":{\"136\":1}}],[\"在数据之外\",{\"1\":{\"113\":1}}],[\"在业务场景中\",{\"1\":{\"133\":1}}],[\"在该索引中已经全部能够找到\",{\"1\":{\"131\":1}}],[\"在字符串类型字段上使用时\",{\"1\":{\"129\":1}}],[\"在相同数据规模的情况下\",{\"1\":{\"122\":1}}],[\"在指定的条件下会自动的将b+树索引构建成hash索引\",{\"1\":{\"121\":1}}],[\"在指定的集合范围之内\",{\"1\":{\"100\":1}}],[\"在mysql数据库中\",{\"1\":{\"195\":1}}],[\"在mysql中\",{\"1\":{\"121\":1}}],[\"在mysql5\",{\"1\":{\"66\":1,\"144\":1,\"234\":1}}],[\"在原b+tree的基础上增加了一个指向相邻叶子结点的链表指针\",{\"1\":{\"120\":1}}],[\"在叶子结点中存储数据\",{\"1\":{\"119\":1}}],[\"在大量数据的情况下\",{\"1\":{\"117\":1}}],[\"在学习mysql之前\",{\"1\":{\"104\":1}}],[\"在学习过程中\",{\"1\":{\"20\":1}}],[\"在多次数据插入时\",{\"1\":{\"200\":1}}],[\"在多联合查询时\",{\"1\":{\"133\":1}}],[\"在多表查询时\",{\"1\":{\"93\":1}}],[\"在多的一方建立外键\",{\"1\":{\"91\":1}}],[\"在任意目录下输入redis\",{\"1\":{\"368\":1}}],[\"在任意一方加入外键\",{\"1\":{\"90\":1}}],[\"在任何时候\",{\"1\":{\"32\":1}}],[\"在事务执行过程\",{\"1\":{\"399\":1}}],[\"在事务中每一次执行快照读时生成readview\",{\"1\":{\"86\":1}}],[\"在事务提交后\",{\"1\":{\"83\":1}}],[\"在事务提交之后\",{\"1\":{\"73\":1}}],[\"在快照读时也需要\",{\"1\":{\"83\":1}}],[\"在in之后的列表中\",{\"1\":{\"187\":1}}],[\"在innodb引擎的表中\",{\"1\":{\"229\":1}}],[\"在innodb引擎中\",{\"1\":{\"140\":1}}],[\"在innodb中引入了意向锁\",{\"1\":{\"145\":1}}],[\"在innodb存储引擎中\",{\"1\":{\"73\":1,\"124\":1,\"204\":1}}],[\"在insert\",{\"1\":{\"83\":1}}],[\"在合适的时间内刷新到磁盘\",{\"1\":{\"73\":1}}],[\"在未来数据被读取时\",{\"1\":{\"62\":1}}],[\"在未来的发展过程中不断的巩固\",{\"1\":{\"2\":1}}],[\"在执行命令时\",{\"1\":{\"468\":1}}],[\"在执行dml语句时\",{\"1\":{\"62\":1}}],[\"在执行增删改查操作时\",{\"1\":{\"61\":1}}],[\"在日常开发中使用非常广泛\",{\"1\":{\"59\":1}}],[\"在日常工作中出于容错的考虑\",{\"1\":{\"2\":1}}],[\"在表上有活动事务的时候\",{\"1\":{\"144\":1}}],[\"在表\",{\"1\":{\"127\":1}}],[\"在表头插入\",{\"1\":{\"36\":2}}],[\"在表l中的第i个位置上插入指定的元素e\",{\"1\":{\"35\":1}}],[\"在表l中查找具有给定关键字值的元素\",{\"1\":{\"35\":1}}],[\"在位置\",{\"1\":{\"36\":1}}],[\"在顺序表\",{\"1\":{\"36\":3}}],[\"在线性表中的位序\",{\"1\":{\"36\":1}}],[\"在客户端传送完数据以后\",{\"1\":{\"17\":1}}],[\"在因特网协议族中\",{\"1\":{\"14\":1}}],[\"在简化的计算机网络osi模型中\",{\"1\":{\"14\":1}}],[\"在对参考的部分\",{\"1\":{\"3\":1}}],[\"在不同的人生阶段对于同一个事物的看法是不同的\",{\"1\":{\"1\":1}}],[\"在步入职场以后也会记录自己在工作中遇到的各种问题\",{\"1\":{\"1\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
